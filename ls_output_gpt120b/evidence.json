{
  "binary": {
    "path": "/usr/bin/ls",
    "sha256": "1bea8094b78a3910345d80af3d182390fda07ae5788352651eb7773505dc39af",
    "format_guess": "ELF",
    "arch": "x86_64",
    "platform": "linux-x86_64",
    "entry": "0x406d30",
    "size": 142312
  },
  "config": {
    "model": "gpt-oss-safeguard:120b",
    "top_n": 9999,
    "analysis_timeout": 600,
    "max_chars": 12000,
    "no_llm": false,
    "hybrid_mode": false,
    "skip_boring": false,
    "rename_prefix": "ai_",
    "rename_suffix": ""
  },
  "imports": [
    "_ITM_deregisterTMCloneTable",
    "_ITM_registerTMCloneTable",
    "__assert_fail",
    "__ctype_b_loc",
    "__ctype_get_mb_cur_max",
    "__ctype_tolower_loc",
    "__ctype_toupper_loc",
    "__cxa_atexit",
    "__cxa_finalize",
    "__errno_location",
    "__fpending",
    "__fprintf_chk",
    "__freading",
    "__gmon_start__",
    "__isoc23_strtoumax",
    "__libc_start_main",
    "__mbstowcs_chk",
    "__memcpy_chk",
    "__mempcpy_chk",
    "__overflow",
    "__printf_chk",
    "__readlink_chk",
    "__snprintf_chk",
    "__sprintf_chk",
    "__stack_chk_fail",
    "__strcpy_chk",
    "_exit",
    "_setjmp",
    "abort",
    "bindtextdomain",
    "calloc",
    "clock_gettime",
    "closedir",
    "dcgettext",
    "dirfd",
    "error",
    "exit",
    "fclose",
    "fflush",
    "fflush_unlocked",
    "fileno",
    "fnmatch",
    "fputc_unlocked",
    "fputs_unlocked",
    "free",
    "freecon",
    "fseeko",
    "fwrite",
    "fwrite_unlocked",
    "getcwd",
    "getenv",
    "getfilecon",
    "getgrgid",
    "gethostname",
    "getopt_long",
    "getpwuid",
    "getxattr",
    "gmtime_r",
    "ioctl",
    "isatty",
    "iswcntrl",
    "iswprint",
    "lgetfilecon",
    "listxattr",
    "localeconv",
    "localtime_r",
    "lseek",
    "malloc",
    "mbrtoc32",
    "mbrtowc",
    "mbsinit",
    "mbstowcs",
    "memcmp",
    "memcpy",
    "memmove",
    "mempcpy",
    "memset",
    "mktime",
    "nl_langinfo",
    "opendir",
    "optarg",
    "optind",
    "program_invocation_name",
    "program_invocation_short_name",
    "raise",
    "rawmemchr",
    "readdir",
    "readlink",
    "realloc",
    "reallocarray",
    "setenv",
    "setlocale",
    "sigaction",
    "sigaddset",
    "sigemptyset",
    "sigismember",
    "signal",
    "sigprocmask",
    "snprintf",
    "stat",
    "statx",
    "stderr",
    "stdout",
    "strchr",
    "strcmp",
    "strcoll",
    "strftime",
    "strlen",
    "strncmp",
    "strrchr",
    "tcgetpgrp",
    "textdomain",
    "timegm",
    "tzset",
    "unsetenv",
    "wcstombs",
    "wcswidth",
    "wcwidth"
  ],
  "exports": [
    "_FINI_0",
    "_INIT_0",
    "_fini",
    "_init",
    "_obstack_allocated_p",
    "_obstack_begin",
    "_obstack_begin_1",
    "_obstack_free",
    "_obstack_memory_used",
    "_obstack_newchunk",
    "_start",
    "main"
  ],
  "strings": [
    {
      "value": "https://www.gnu.org/software/coreutils/",
      "length": 39,
      "refs": 6,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "GNU coreutils",
      "length": 13,
      "refs": 5,
      "functions": [
        "0x404da0",
        "0x411790",
        "0x4090e0"
      ]
    },
    {
      "value": "%Y-%m-%d",
      "length": 8,
      "refs": 5,
      "functions": [
        "0x414780"
      ]
    },
    {
      "value": "src/ls.c",
      "length": 8,
      "refs": 4,
      "functions": [
        "0x404da0",
        "0x40e4b0"
      ]
    },
    {
      "value": "# Configuration file for dircolors, a utility to help you set the",
      "length": 65,
      "refs": 3,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "UTF-8",
      "length": 5,
      "refs": 3,
      "functions": [
        "0x408c20"
      ]
    },
    {
      "value": "*=>@|",
      "length": 5,
      "refs": 3,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "system.nfs4_acl",
      "length": 15,
      "refs": 3,
      "functions": [
        "0x417490"
      ]
    },
    {
      "value": "[A\\A]A^]",
      "length": 8,
      "refs": 2,
      "functions": [
        "0x408090"
      ]
    },
    {
      "value": "D9#u",
      "length": 4,
      "refs": 2,
      "functions": [
        "0x40f4c0"
      ]
    },
    {
      "value": "D9#u",
      "length": 4,
      "refs": 2,
      "functions": [
        "0x40f5f0"
      ]
    },
    {
      "value": "?pcdb-lswd",
      "length": 10,
      "refs": 2,
      "functions": [
        "0x40f6b0"
      ]
    },
    {
      "value": "posix-",
      "length": 6,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "main",
      "length": 4,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": " %ld",
      "length": 4,
      "refs": 2,
      "functions": [
        "0x408190"
      ]
    },
    {
      "value": "sha2 utilities",
      "length": 14,
      "refs": 2,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "test invocation",
      "length": 15,
      "refs": 2,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "Multi-call invocation",
      "length": 21,
      "refs": 2,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "sha224sum",
      "length": 9,
      "refs": 2,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "sha256sum",
      "length": 9,
      "refs": 2,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "sha384sum",
      "length": 9,
      "refs": 2,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "sha512sum",
      "length": 9,
      "refs": 2,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "Full documentation <%s%s>\n",
      "length": 26,
      "refs": 2,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "memory exhausted",
      "length": 16,
      "refs": 2,
      "functions": [
        "0x409a00",
        "0x40e430"
      ]
    },
    {
      "value": "%.0Lf",
      "length": 5,
      "refs": 2,
      "functions": [
        "0x40cb80"
      ]
    },
    {
      "value": "%.1Lf",
      "length": 5,
      "refs": 2,
      "functions": [
        "0x40cb80"
      ]
    },
    {
      "value": "unlabeled",
      "length": 9,
      "refs": 2,
      "functions": [
        "0x40e040",
        "0x417490"
      ]
    },
    {
      "value": "error canonicalizing %s",
      "length": 23,
      "refs": 2,
      "functions": [
        "0x417490",
        "0x410fc0"
      ]
    },
    {
      "value": "%s%s argument '%s' too large",
      "length": 28,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "full-iso",
      "length": 8,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "%s: %s",
      "length": 6,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "David MacKenzie",
      "length": 15,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "Richard M. Stallman",
      "length": 19,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "  - [posix-]%s\n",
      "length": 15,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "%Y-%m-%d %H:%M:%S.%N %z",
      "length": 23,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "%Y-%m-%d %H:%M",
      "length": 14,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "%Y-%m-%d ",
      "length": 9,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "TERM ",
      "length": 5,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "%s (%s) %s\n",
      "length": 11,
      "refs": 2,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "POSIXLY_CORRECT",
      "length": 15,
      "refs": 2,
      "functions": [
        "0x412420"
      ]
    },
    {
      "value": "%m/%d/%y",
      "length": 8,
      "refs": 2,
      "functions": [
        "0x414780"
      ]
    },
    {
      "value": "%H:%M:%S",
      "length": 8,
      "refs": 2,
      "functions": [
        "0x414780"
      ]
    },
    {
      "value": "cannot access %s",
      "length": 16,
      "refs": 2,
      "functions": [
        "0x417490"
      ]
    },
    {
      "value": "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",
      "length": 43,
      "refs": 2,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "License GPLv3+: GNU GPL version 3 or later <%s>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n",
      "length": 170,
      "refs": 2,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "https://gnu.org/licenses/gpl.html",
      "length": 33,
      "refs": 2,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Copyright %s %d Free Software Foundation, Inc.",
      "length": 46,
      "refs": 2,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "M;.u",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "[A\\A]A^]",
      "length": 8,
      "refs": 1,
      "functions": [
        "0x409d10"
      ]
    },
    {
      "value": "[A\\A]A^]",
      "length": 8,
      "refs": 1,
      "functions": [
        "0x40ab80"
      ]
    },
    {
      "value": "[A\\A]A^]",
      "length": 8,
      "refs": 1,
      "functions": [
        "0x40ac90"
      ]
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x40ada0"
      ]
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x40ade0"
      ]
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x40ae20"
      ]
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x40aed0"
      ]
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x40af90"
      ]
    },
    {
      "value": "H90s",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x40de30"
      ]
    },
    {
      "value": "L9(s9L",
      "length": 6,
      "refs": 1,
      "functions": [
        "0x40de70"
      ]
    },
    {
      "value": "[A\\A]A^]",
      "length": 8,
      "refs": 1,
      "functions": [
        "0x40f4c0"
      ]
    },
    {
      "value": "[A\\A]A^]",
      "length": 8,
      "refs": 1,
      "functions": [
        "0x40f5f0"
      ]
    },
    {
      "value": "<.u|",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x412600"
      ]
    },
    {
      "value": "sort_files",
      "length": 10,
      "refs": 1,
      "functions": [
        "0x40e4b0"
      ]
    },
    {
      "value": "dev_ino_pop",
      "length": 11,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "%.*s%s%s",
      "length": 8,
      "refs": 1,
      "functions": [
        "0x408280"
      ]
    },
    {
      "value": "ASCII",
      "length": 5,
      "refs": 1,
      "functions": [
        "0x408c20"
      ]
    },
    {
      "value": "\n%s online help: <%s>\n",
      "length": 22,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "%*lu ",
      "length": 5,
      "refs": 1,
      "functions": [
        "0x40af90"
      ]
    },
    {
      "value": "write error",
      "length": 11,
      "refs": 1,
      "functions": [
        "0x40b880"
      ]
    },
    {
      "value": "invalid argument %s for %s",
      "length": 26,
      "refs": 1,
      "functions": [
        "0x40c040"
      ]
    },
    {
      "value": "ambiguous argument %s for %s",
      "length": 28,
      "refs": 1,
      "functions": [
        "0x40c040"
      ]
    },
    {
      "value": "POSIX",
      "length": 5,
      "refs": 1,
      "functions": [
        "0x40c6a0"
      ]
    },
    {
      "value": "GB18030",
      "length": 7,
      "refs": 1,
      "functions": [
        "0x40df40"
      ]
    },
    {
      "value": "sort_type != sort_version",
      "length": 25,
      "refs": 1,
      "functions": [
        "0x40e4b0"
      ]
    },
    {
      "value": "%%%02x",
      "length": 6,
      "refs": 1,
      "functions": [
        "0x40e7a0"
      ]
    },
    {
      "value": "%s %*s ",
      "length": 7,
      "refs": 1,
      "functions": [
        "0x40f6b0"
      ]
    },
    {
      "value": "%*s, %*s ",
      "length": 9,
      "refs": 1,
      "functions": [
        "0x40f6b0"
      ]
    },
    {
      "value": " -> ",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x40f6b0"
      ]
    },
    {
      "value": "cannot open directory %s",
      "length": 24,
      "refs": 1,
      "functions": [
        "0x410fc0"
      ]
    },
    {
      "value": "reading directory %s",
      "length": 20,
      "refs": 1,
      "functions": [
        "0x410fc0"
      ]
    },
    {
      "value": "closing directory %s",
      "length": 20,
      "refs": 1,
      "functions": [
        "0x410fc0"
      ]
    },
    {
      "value": "total",
      "length": 5,
      "refs": 1,
      "functions": [
        "0x410fc0"
      ]
    },
    {
      "value": "invalid %s%s argument '%s'",
      "length": 26,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "/.libs/",
      "length": 7,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "/usr/share/locale",
      "length": 17,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "invalid line width",
      "length": 18,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--classify",
      "length": 10,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "invalid tab size",
      "length": 16,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--sort",
      "length": 6,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--time",
      "length": 6,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--format",
      "length": 8,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--color",
      "length": 7,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--hyperlink",
      "length": 11,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--indicator-style",
      "length": 17,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--quoting-style",
      "length": 15,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "LS_BLOCK_SIZE",
      "length": 13,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "COLUMNS",
      "length": 7,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "TABSIZE",
      "length": 7,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "QUOTING_STYLE",
      "length": 13,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "TIME_STYLE",
      "length": 10,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "invalid time style format %s",
      "length": 28,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "time style",
      "length": 10,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "Valid arguments are:\n",
      "length": 21,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "LS_COLORS",
      "length": 9,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "COLORTERM",
      "length": 9,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "unrecognized prefix: %s",
      "length": 23,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "target",
      "length": 6,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "found",
      "length": 5,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "//DIRED//",
      "length": 9,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "//SUBDIRED//",
      "length": 12,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "Written by %s.\n",
      "length": 15,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Written by %s and %s.\n",
      "length": 22,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Written by %s, %s, and %s.\n",
      "length": 27,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "BLOCKSIZE",
      "length": 9,
      "refs": 1,
      "functions": [
        "0x412420"
      ]
    },
    {
      "value": "eEgGkKmMpPtTyYzZ0",
      "length": 17,
      "refs": 1,
      "functions": [
        "0x412420"
      ]
    },
    {
      "value": "Valid arguments are:",
      "length": 20,
      "refs": 1,
      "functions": [
        "0x413ec0"
      ]
    },
    {
      "value": "\n  - %s",
      "length": 7,
      "refs": 1,
      "functions": [
        "0x413ec0"
      ]
    },
    {
      "value": ", %s",
      "length": 4,
      "refs": 1,
      "functions": [
        "0x413ec0"
      ]
    },
    {
      "value": "system.posix_acl_access",
      "length": 23,
      "refs": 1,
      "functions": [
        "0x417490"
      ]
    },
    {
      "value": "system.posix_acl_default",
      "length": 24,
      "refs": 1,
      "functions": [
        "0x417490"
      ]
    },
    {
      "value": "cannot read symbolic link %s",
      "length": 28,
      "refs": 1,
      "functions": [
        "0x417490"
      ]
    },
    {
      "value": "Try '%s --help' for more information.\n",
      "length": 38,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "Usage: %s [OPTION]... [FILE]...\n",
      "length": 32,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "List information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n",
      "length": 143,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "\nMandatory arguments to long options are mandatory for short options too.\n",
      "length": 74,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n",
      "length": 270,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;\n                             e.g., '--block-size=M'; see SIZE format below\n\n",
      "length": 154,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -B, --ignore-backups       do not list implied entries ending with ~\n",
      "length": 71,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -c                         with -lt: sort by, and show, ctime (time of last\n                             change of file status information);\n                             with -l: show ctime and sort by name;\n                             otherwise: sort by ctime, newest first\n\n",
      "length": 279,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -C                         list entries by columns\n      --color[=WHEN]         color the output WHEN; more info below\n  -d, --directory            list directories themselves, not their contents\n  -D, --dired                generate output designed for Emacs' dired mode\n",
      "length": 274,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -f                         list all entries in directory order\n  -F, --classify[=WHEN]      append indicator (one of */=>@|) to entries WHEN\n      --file-type            likewise, except do not append '*'\n",
      "length": 207,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n                             single-column -1, verbose -l, vertical -C\n\n",
      "length": 147,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --full-time            like -l --time-style=full-iso\n",
      "length": 59,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -g                         like -l, but do not list owner\n",
      "length": 60,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --group-directories-first\n                             group directories before files;\n                             can be augmented with a --sort option, but any\n                             use of --sort=none (-U) disables grouping\n\n",
      "length": 241,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -G, --no-group             in a long listing, don't print group names\n",
      "length": 72,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.\n      --si                   likewise, but use powers of 1000 not 1024\n",
      "length": 149,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -H, --dereference-command-line\n                             follow symbolic links listed on the command line\n",
      "length": 111,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --dereference-command-line-symlink-to-dir\n                             follow each command line symbolic link\n                             that points to a directory\n\n",
      "length": 173,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n                             (overridden by -a or -A)\n\n",
      "length": 135,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --hyperlink[=WHEN]     hyperlink file names WHEN\n",
      "length": 55,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --indicator-style=WORD\n                             append indicator with style WORD to entry names:\n                             none (default), slash (-p),\n                             file-type (--file-type), classify (-F)\n\n",
      "length": 233,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -i, --inode                print the index number of each file\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n",
      "length": 145,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -k, --kibibytes            default to 1024-byte blocks for file system usage;\n                             used only with -s and per directory totals\n\n",
      "length": 153,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -l                         use a long listing format\n",
      "length": 55,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -L, --dereference          when showing file information for a symbolic\n                             link, show information for the file the link\n                             references rather than for the link itself\n\n",
      "length": 221,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -m                         fill width with a comma separated list of entries\n",
      "length": 79,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n  -N, --literal              print entry names without quoting\n  -o                         like -l, but do not list group information\n  -p, --indicat",
      "length": 224,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -q, --hide-control-chars   print ? instead of nongraphic characters\n",
      "length": 70,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --show-control-chars   show nongraphic characters as-is (the default,\n                             unless program is 'ls' and output is a terminal)\n\n",
      "length": 155,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -Q, --quote-name           enclose entry names in double quotes\n",
      "length": 66,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --quoting-style=WORD   use quoting style WORD for entry names:\n                             literal, locale, shell, shell-always,\n                             shell-escape, shell-escape-always, c, escape\n                             (overrides QUOTING_STYLE environment variable)\n\n",
      "length": 287,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -r, --reverse              reverse order while sorting\n  -R, --recursive            list subdirectories recursively\n  -s, --size                 print the allocated size of each file, in blocks\n",
      "length": 196,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -S                         sort by file size, largest first\n",
      "length": 62,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\n                             time (-t), version (-v), extension (-X), width\n\n",
      "length": 158,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --time=WORD            select which timestamp used to display or sort;\n                               access time (-u): atime, access, use;\n                               metadat",
      "length": 184,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --time-style=TIME_STYLE\n                             time/date format with -l; see TIME_STYLE below\n",
      "length": 106,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -t                         sort by time, newest first; see --time\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n",
      "length": 140,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -u                         with -lt: sort by, and show, access time;\n                             with -l: show access time and sort by name;\n                             otherwise: ",
      "length": 184,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -U                         do not sort; list entries in directory order\n",
      "length": 74,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -v                         natural sort of (version) numbers within text\n",
      "length": 75,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "  -w, --width=COLS           set output width to COLS.  0 means no limit\n  -x                         list entries by lines instead of by columns\n  -X                         sort alphabetically by entry extension\n  -Z, --context              print any security context of each file\n      --zero                 ",
      "length": 312,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --help        display this help and exit\n",
      "length": 47,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "      --version     output version information and exit\n",
      "length": 56,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\n",
      "length": 215,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "\nThe TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\nFORMAT is interpreted like in date(1).  If FORMAT is FORMAT1<newline>FORMAT2,\nthen FORMAT1 applies to non-recent files and FORMAT2 to recent files.\nTIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX locale.\nAlso the TIME_STYLE environment variable ",
      "length": 344,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "\nThe WHEN argument defaults to 'always' and can also be 'auto' or 'never'.\n",
      "length": 75,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "\nUsing color to distinguish file types is disabled both by default and\nwith --color=never.  With --color=auto, ls emits color codes only when\nst",
      "length": 144,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "\nExit status:\n 0  if OK,\n 1  if minor problems (e.g., cannot access subdirectory),\n 2  if serious trouble (e.g., cannot access command-line argument).\n",
      "length": 151,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "Report any translation bugs to <https://translationproject.org/team/>\n",
      "length": 70,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "or available locally via: info '(coreutils) %s%s'\n",
      "length": 50,
      "refs": 1,
      "functions": [
        "0x4090e0"
      ]
    },
    {
      "value": "cannot determine device and inode of %s",
      "length": 39,
      "refs": 1,
      "functions": [
        "0x410fc0"
      ]
    },
    {
      "value": "%s: not listing already-listed directory",
      "length": 40,
      "refs": 1,
      "functions": [
        "0x410fc0"
      ]
    },
    {
      "value": "invalid suffix in %s%s argument '%s'",
      "length": 36,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "A NULL argv[0] was passed through an exec system call.\n",
      "length": 55,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "ignoring invalid width in environment variable COLUMNS: %s",
      "length": 58,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "ignoring invalid tab size in environment variable TABSIZE: %s",
      "length": 61,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "ignoring invalid value of environment variable QUOTING_STYLE: %s",
      "length": 64,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "--dired and --zero are incompatible",
      "length": 35,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n",
      "length": 53,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "unparsable value for LS_COLORS environment variable",
      "length": 51,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "dev_ino_size <= __extension__ ({ struct obstack const *__o = (&dev_ino_obstack); (size_t) (__o->next_free - __o->object_base); })",
      "length": 129,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "//DIRED-OPTIONS// --quoting-style=%s\n",
      "length": 37,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "hash_get_n_entries (active_dir_set) == 0",
      "length": 40,
      "refs": 1,
      "functions": [
        "0x404da0"
      ]
    },
    {
      "value": "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n",
      "length": 59,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Written by %s, %s, %s,\nand %s.\n",
      "length": 31,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Written by %s, %s, %s,\n%s, and %s.\n",
      "length": 35,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Written by %s, %s, %s,\n%s, %s, and %s.\n",
      "length": 39,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n",
      "length": 43,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n",
      "length": 47,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n",
      "length": 51,
      "refs": 1,
      "functions": [
        "0x411790"
      ]
    },
    {
      "value": "@8\r@",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "/lib64/ld-linux-x86-64.so.2",
      "length": 27,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__libc_start_main",
      "length": 17,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__cxa_finalize",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__cxa_atexit",
      "length": 12,
      "refs": 0,
      "functions": []
    },
    {
      "value": "strcmp",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "obstack_alloc_failed_handler",
      "length": 28,
      "refs": 0,
      "functions": []
    },
    {
      "value": "stdout",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__overflow",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fwrite_unlocked",
      "length": 15,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fputs_unlocked",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__printf_chk",
      "length": 12,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__mempcpy_chk",
      "length": 13,
      "refs": 0,
      "functions": []
    },
    {
      "value": "nl_langinfo",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "strchr",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__ctype_b_loc",
      "length": 13,
      "refs": 0,
      "functions": []
    },
    {
      "value": "strlen",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__ctype_get_mb_cur_max",
      "length": 22,
      "refs": 0,
      "functions": []
    },
    {
      "value": "mbstowcs",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "malloc",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__mbstowcs_chk",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "iswprint",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "wcswidth",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "wcwidth",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "wcstombs",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__snprintf_chk",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "snprintf",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__stack_chk_fail",
      "length": 16,
      "refs": 0,
      "functions": []
    },
    {
      "value": "sigismember",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "signal",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "sigemptyset",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "sigaction",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "sigaddset",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "dcgettext",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "memcpy",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__memcpy_chk",
      "length": 12,
      "refs": 0,
      "functions": []
    },
    {
      "value": "stderr",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__fprintf_chk",
      "length": 13,
      "refs": 0,
      "functions": []
    },
    {
      "value": "setlocale",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "strncmp",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "abort",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "strrchr",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "isatty",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__errno_location",
      "length": 16,
      "refs": 0,
      "functions": []
    },
    {
      "value": "strcoll",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "calloc",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fileno",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__freading",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fflush",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fclose",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "lseek",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fseeko",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__fpending",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "error",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_exit",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "statx",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "tcgetpgrp",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fflush_unlocked",
      "length": 15,
      "refs": 0,
      "functions": []
    },
    {
      "value": "sigprocmask",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "raise",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "realloc",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "localeconv",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__sprintf_chk",
      "length": 13,
      "refs": 0,
      "functions": []
    },
    {
      "value": "memmove",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_obstack_begin",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_obstack_begin_1",
      "length": 16,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_obstack_newchunk",
      "length": 17,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_obstack_allocated_p",
      "length": 20,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_obstack_free",
      "length": 13,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_obstack_memory_used",
      "length": 20,
      "refs": 0,
      "functions": []
    },
    {
      "value": "getenv",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "unsetenv",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "tzset",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "localtime_r",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "gmtime_r",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "reallocarray",
      "length": 12,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_setjmp",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__assert_fail",
      "length": 13,
      "refs": 0,
      "functions": []
    },
    {
      "value": "getpwuid",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__strcpy_chk",
      "length": 12,
      "refs": 0,
      "functions": []
    },
    {
      "value": "getgrgid",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "clock_gettime",
      "length": 13,
      "refs": 0,
      "functions": []
    },
    {
      "value": "mempcpy",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "opendir",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "dirfd",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "closedir",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "readdir",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fnmatch",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "program_invocation_name",
      "length": 23,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__progname_full",
      "length": 15,
      "refs": 0,
      "functions": []
    },
    {
      "value": "bindtextdomain",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "getopt_long",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "program_invocation_short_name",
      "length": 29,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__progname",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "optarg",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "optind",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "gethostname",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "memcmp",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ioctl",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fwrite",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "mbrtoc32",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "fputc_unlocked",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__isoc23_strtoumax",
      "length": 18,
      "refs": 0,
      "functions": []
    },
    {
      "value": "mbsinit",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "memset",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "iswcntrl",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "mbrtowc",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__ctype_toupper_loc",
      "length": 19,
      "refs": 0,
      "functions": []
    },
    {
      "value": "strftime",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "mktime",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__ctype_tolower_loc",
      "length": 19,
      "refs": 0,
      "functions": []
    },
    {
      "value": "timegm",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "getcwd",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "readlink",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "rawmemchr",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "stat",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__readlink_chk",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "listxattr",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "getxattr",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_ITM_deregisterTMCloneTable",
      "length": 27,
      "refs": 0,
      "functions": []
    },
    {
      "value": "__gmon_start__",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "_ITM_registerTMCloneTable",
      "length": 25,
      "refs": 0,
      "functions": []
    },
    {
      "value": "freecon",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "lgetfilecon",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "libselinux.so.1",
      "length": 15,
      "refs": 0,
      "functions": []
    },
    {
      "value": "libc.so.6",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "LIBSELINUX_1.0",
      "length": 14,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.28",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.38",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.14",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.33",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.16",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.17",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.26",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.4",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.34",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.3.4",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.2.5",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GLIBC_2.3",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AWAVAUATSH",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "/%11",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "$vKH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "d$(M",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "G(H;G0",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "PTE1",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u+UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AWAVA",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": ":u^I",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "$[A\\A]A^A_]",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Fp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GxH9Fx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Gp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FxH9Gx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Bp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AxH9Bx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Ap",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "BxH9Ax",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9F`",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GhH9Fh",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9G`",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FhH9Gh",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9B`",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AhH9Bh",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9A`",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "BhH9Ah",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Fp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GxH9Fx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Gp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FxH9Gx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Bp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AxH9Bx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Ap",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "BxH9Ax",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GHH9FH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FHH9GH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FHH9BH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "BHH9AH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AUATSH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "sAL9",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AWAVAUATSH",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "G(H;G0s#H",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AWAVL",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AUATSH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AWAVAUL",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AWAVAUATSH",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\L)",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H[A\\A]A^A_]",
      "length": 11,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AVAUATSH",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^]",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^]",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AWAVAUATA",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "U0I;E",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "tXL9",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AWAVI",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "&L;f",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "VHfH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]A^A_]",
      "length": 10,
      "refs": 0,
      "functions": []
    },
    {
      "value": ">A\\A]A^]",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AUATSH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "tTE1",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u.UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u.UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Gp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FxH9Gx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u*UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Fp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GxH9Fx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u*UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9G`",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FhH9Gh",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u*UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9F`",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GhH9Fh",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u*UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Gp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FxH9Gx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u*UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "H9Fp",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GxH9Fx",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u*UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "FHH9GH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u,UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "GHH9FH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "u,UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AHH9BH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "BHH9FH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSL",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSL",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "t'UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "t'UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSL",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AVAUATI",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "A]A^]",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AVAUATI",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "A]A^]",
      "length": 5,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "t/UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "t/UH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "G(H;G0s",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\H",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "ATSH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "t\nL9",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AVAUATSH",
      "length": 8,
      "refs": 0,
      "functions": []
    },
    {
      "value": "k(dH",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "oK01",
      "length": 4,
      "refs": 0,
      "functions": []
    },
    {
      "value": "`[A\\A]A^]",
      "length": 9,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AUATSH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "C H9C(u",
      "length": 7,
      "refs": 0,
      "functions": []
    },
    {
      "value": "AUATSH",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\A]]",
      "length": 6,
      "refs": 0,
      "functions": []
    },
    {
      "value": "[A\\]",
      "length": 4,
      "refs": 0,
      "functions": []
    }
  ],
  "functions": [
    {
      "addr": "0x404000",
      "original_name": "_init",
      "final_name": "ai_gmon_init",
      "score": 13.4,
      "bb_count": 3,
      "insn_est": 8,
      "callers": 0,
      "callees": [
        {
          "addr": "0x422fc8"
        }
      ],
      "import_refs": [
        "__gmon_start__"
      ],
      "string_refs": [],
      "constants": [
        "0x422fc8"
      ],
      "snippets": {
        "asm": "  0x404000  endbr64 \n  0x404004  sub     rsp, 0x8\n  0x404008  mov     rax, qword [rel __gmon_start__]\n  0x40400f  test    rax, rax\n  0x404012  je      0x404016\n  0x404016  add     rsp, 0x8\n  0x40401a  retn     {__return_addr}\n  0x404014  call    rax",
        "hlil": "if (__gmon_start__ == 0)\nreturn __gmon_start__\nreturn __gmon_start__()",
        "pseudoc": "{\n    if (!__gmon_start__)\n        return __gmon_start__;\n    \n    return __gmon_start__();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_gmon_init",
          "confidence": 0.96,
          "rationale": "Function checks for the presence of __gmon_start__ and calls it, acting as a wrapper for the GNU profiling initialization routine.",
          "evidence_refs": [
            "imports:__gmon_start__",
            "call:0x422fc8"
          ],
          "tags": [],
          "alt_names": [
            "ai_gmon_start_wrapper",
            "ai_profiler_init"
          ]
        },
        "explain": {
          "summary": "The _init function checks if the imported __gmon_start__ symbol is present; if it is null it returns that null pointer, otherwise it calls __gmon_start__ and returns its result.",
          "details": [
            "Performs a null check on the __gmon_start__ function pointer.",
            "Invokes __gmon_start__ when it is defined, acting as a stub for GNU profiling initialization."
          ],
          "evidence_refs": [
            "imports:__gmon_start__",
            "call:0x422fc8"
          ],
          "unknowns": [
            "Exact side effects and return value semantics of __gmon_start__"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404020",
      "original_name": "sub_404020",
      "final_name": "ai_config_lookup",
      "score": 27.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 104,
      "callees": [
        {
          "addr": "0x0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x422c40",
        "0x422c48"
      ],
      "snippets": {
        "asm": "  0x404020  push    qword [rel data_422c40] {var_8}  {0x0}\n  0x404026  jmp     qword [rel data_422c48]  {0x0}",
        "hlil": "int64_t var_8 = 0\njump(nullptr)",
        "pseudoc": "{\n    int64_t var_8 = 0;\n    /* jump -> nullptr */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_config_lookup",
          "confidence": 0.62,
          "rationale": "The function appears to be a generic handler that returns a value based on an index set by its callers (sub_404030, sub_404040, sub_404050) which set var_8 to 0,1,2. The presence of constant addresses suggests a lookup table, indicating a configuration or data retrieval routine.",
          "evidence_refs": [
            "constants:0x422c40",
            "constants:0x422c48",
            "call:0x404030",
            "call:0x404040",
            "call:0x404050"
          ],
          "tags": [
            "config",
            "lookup",
            "data"
          ],
          "alt_names": [
            "ai_get_option",
            "ai_get_config_value"
          ]
        },
        "explain": {
          "summary": "sub_404020 appears to be a dispatcher that jumps to a target based on a value set by its callers, using a jump table or indirect branch. Neighbor functions set a local var_8 to 0, 1, or 2 before tailcalling this routine, suggesting the value selects different code paths.",
          "details": [
            "The function defines a local var_8 = 0 and then performs an unresolved jump (likely an indirect jump via a table).",
            "Neighbor functions sub_404030, sub_404040, and sub_404050 set var_8 to 0, 1, and 2 respectively before tailcalling sub_404020, indicating var_8 is used as a selector."
          ],
          "evidence_refs": [
            "call:0x404030",
            "call:0x404040",
            "call:0x404050"
          ],
          "unknowns": [
            "Exact jump target(s) and the contents of the jump table at addresses 0x422c40/0x422c48",
            "What operation is performed after the jump"
          ],
          "confidence": 0.63
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "lookup",
        "data"
      ]
    },
    {
      "addr": "0x404030",
      "original_name": "sub_404030",
      "final_name": "ai_forward_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404030  endbr64 \n  0x404034  push    0x0 {var_8}\n  0x404039  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_forward_stub",
          "confidence": 0.68,
          "rationale": "The function simply tail-calls another function (sub_404020) without any processing, acting as a forwarding stub or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_function_forwarder"
          ]
        },
        "explain": {
          "summary": "sub_404030 is a thin wrapper that immediately tail-calls sub_404020 and returns its result, performing no additional logic.",
          "details": [
            "The function allocates a local variable but does not use it before making a tail call to sub_404020.",
            "sub_404020 appears to contain a jump to a null pointer, suggesting it may be a placeholder or cause a termination."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "Exact behavior and return value of sub_404020 due to the jump to nullptr",
            "Purpose of the allocated local variable"
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404040",
      "original_name": "sub_404040",
      "final_name": "ai_forward_to_sub_404020",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404040  endbr64 \n  0x404044  push    0x1 {var_8}\n  0x404049  jmp     sub_404020",
        "hlil": "int64_t var_8 = 1\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 1;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_forward_to_sub_404020",
          "confidence": 0.22,
          "rationale": "Function simply forwards execution to sub_404020 after setting a local variable, acting as a thin wrapper with no visible side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_wrapper_sub_404020",
            "ai_stub_call"
          ]
        },
        "explain": {
          "summary": "sub_404040 is a thin wrapper that initializes a local variable to 1 and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function sets a stack variable var_8 to 1 but does not use it before the tail call.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and whether it influences sub_404020 via side effects.",
            "The actual behavior of sub_404020, which appears to jump to a nullptr placeholder."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404050",
      "original_name": "sub_404050",
      "final_name": "ai_tailcall_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404050  endbr64 \n  0x404054  push    0x2 {var_8}\n  0x404059  jmp     sub_404020",
        "hlil": "int64_t var_8 = 2\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 2;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_tailcall_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and then tail-calls sub_404020, acting as a simple wrapper or forwarder with no visible side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_forward_init",
            "ai_stub"
          ]
        },
        "explain": {
          "summary": "sub_404050 is a thin wrapper that sets a local variable and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function initializes a local variable var_8 to 2, but the variable is not used elsewhere.",
            "It performs a tail call to sub_404020, effectively delegating its behavior to that routine."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and its value of 2.",
            "The actual functionality of sub_404020, which appears to jump to a null pointer or be a stub."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404060",
      "original_name": "sub_404060",
      "final_name": "ai_tailcall_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404060  endbr64 \n  0x404064  push    0x3 {var_8}\n  0x404069  jmp     sub_404020",
        "hlil": "int64_t var_8 = 3\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 3;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_tailcall_wrapper",
          "confidence": 0.32,
          "rationale": "The function simply sets a local variable and tail-calls another function (sub_404020) without any visible side effects, indicating a wrapper or stub behavior.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_noop_caller"
          ]
        },
        "explain": {
          "summary": "sub_404060 is a thin wrapper that initializes a local variable to 3 and then tailcalls sub_404020, returning whatever that function returns. sub_404020 sets a local variable to 0 and then jumps to a null address, effectively acting as a stub or termination point.",
          "details": [
            "sub_404060 sets var_8 = 3 but does not use it before tailcalling sub_404020.",
            "sub_404020 sets var_8 = 0 and then performs a jump to a nullptr, suggesting no meaningful work is done."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The exact effect of the jump to nullptr in sub_404020",
            "The intended return value or sideeffects of sub_404020"
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404070",
      "original_name": "sub_404070",
      "final_name": "ai_tailcall_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404070  endbr64 \n  0x404074  push    0x4 {var_8}\n  0x404079  jmp     sub_404020",
        "hlil": "int64_t var_8 = 4\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 4;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_tailcall_stub",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and then tail-calls another function (sub_404020), indicating a simple wrapper or stub with no visible side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_wrapper_stub",
            "ai_forwarder"
          ]
        },
        "explain": {
          "summary": "sub_404070 is a thin wrapper that sets a local variable to 4 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function initializes a stack variable (var_8) to 4 but does not use it before the tail call.",
            "It performs a tail call to sub_404020 at address 0x404020 and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and why it is set to 4.",
            "The exact behavior of sub_404020, which appears to jump to a nullptr or perform no meaningful work."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404080",
      "original_name": "sub_404080",
      "final_name": "ai_stub_function",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404080  endbr64 \n  0x404084  push    0x5 {var_8}\n  0x404089  jmp     sub_404020",
        "hlil": "int64_t var_8 = 5\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 5;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_function",
          "confidence": 0.62,
          "rationale": "The function performs no meaningful work and simply tail-calls another empty function, indicating a placeholder or no-op stub.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404080 is a thin wrapper that initializes a local variable to 5 and then tailcalls sub_404020, which appears to be a stub that sets a local variable to 0 and jumps to a null address, effectively performing no meaningful work.",
          "details": [
            "The function defines a local int64_t var_8 = 5 but never uses it before tailcalling sub_404020.",
            "sub_404020, the callee, sets its own local var_8 = 0 and then jumps to a nullptr, suggesting a noop or placeholder implementation."
          ],
          "evidence_refs": [
            "call:0x404020",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "The exact purpose of the jump to nullptr in sub_404020 and whether it returns a value or triggers an exception."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404090",
      "original_name": "sub_404090",
      "final_name": "ai_dummy_function",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404090  endbr64 \n  0x404094  push    0x6 {var_8}\n  0x404099  jmp     sub_404020",
        "hlil": "int64_t var_8 = 6\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 6;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_function",
          "confidence": 0.32,
          "rationale": "The function simply forwards to another stub that does nothing, indicating a no-op or placeholder behavior.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_stub"
          ]
        },
        "explain": {
          "summary": "sub_404090 is a thin wrapper that initializes a local variable to 6 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "A stack variable var_8 is set to 6 but never used before the tail call.",
            "The function performs a tail call to sub_404020 at address 0x404020."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of the var_8 assignment (if any sideeffects exist).",
            "The behavior of sub_404020, which appears to jump to a nullptr and may not return meaningful data."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4040a0",
      "original_name": "sub_4040a0",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4040a0  endbr64 \n  0x4040a4  push    0x7 {var_8}\n  0x4040a9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 7\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 7;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.62,
          "rationale": "The function only sets a local variable and tail-calls another function without performing any logic, indicating a no-op or wrapper stub.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4040a0 is a thin wrapper that sets a local variable to 7 and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function defines a local int64 variable initialized to 7, but the variable is never used.",
            "It performs a tail call to sub_404020 at address 0x404020 and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The functional purpose of sub_404020, which appears to jump to a nullptr.",
            "Whether the local variable influences any external state or is a placeholder."
          ],
          "confidence": 0.88
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4040b0",
      "original_name": "sub_4040b0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4040b0  endbr64 \n  0x4040b4  push    0x8 {var_8}\n  0x4040b9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 8\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 8;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.42,
          "rationale": "The function simply tail-calls sub_404020, which appears to be a stub that jumps to nullptr, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4040b0 is a thin wrapper that prepares a stack variable and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function allocates an 8byte local variable (var_8) set to 8 before making a tail call to sub_404020.",
            "sub_404020 appears to be a stub that sets a local variable to 0 and then jumps to a null address, suggesting it may simply return or be a placeholder."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual effect and return value of sub_404020, since it jumps to a nullptr.",
            "The purpose of the local variable var_8 in both functions."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4040c0",
      "original_name": "sub_4040c0",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4040c0  endbr64 \n  0x4040c4  push    0x9 {var_8}\n  0x4040c9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 9\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 9;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "Function simply forwards to another subroutine without performing any visible work; likely a placeholder or stub wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub",
            "ai_noop"
          ]
        },
        "explain": {
          "summary": "sub_4040c0 is a thin wrapper that sets a local variable and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function initializes a local 64bit variable to 9, but the variable is never used before the tail call.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 set to 9 (and similarly var_8 set to 0 in sub_404020).",
            "The exact effect of sub_404020, which appears to jump to a nullptr or placeholder."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4040d0",
      "original_name": "sub_4040d0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4040d0  endbr64 \n  0x4040d4  push    0xa {var_8}\n  0x4040d9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0xa\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0xa;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function simply forwards execution to sub_404020 without performing any visible work, acting as a stub or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4040d0 is a thin wrapper that initializes a local variable to 10 and then tail-calls sub_404020, which appears to be a stub that sets a local variable to zero and jumps to a null address, effectively doing nothing useful.",
          "details": [
            "The function sets var_8 = 0xa (10) but does not use it before calling sub_404020.",
            "sub_404020 sets its own var_8 = 0 and then jumps to a nullptr, indicating a placeholder or no-op implementation."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0xa"
          ],
          "unknowns": [
            "The actual effect of the jump to nullptr in sub_404020",
            "Whether var_8 influences any external state"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4040e0",
      "original_name": "sub_4040e0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4040e0  endbr64 \n  0x4040e4  push    0xb {var_8}\n  0x4040e9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0xb\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0xb;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.62,
          "rationale": "Function simply forwards to another stub function without performing any operations, acting as a placeholder or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_forward",
            "ai_placeholder_call"
          ]
        },
        "explain": {
          "summary": "sub_4040e0 is a thin wrapper that initializes a local variable to 0xb and then tailcalls sub_404020, returning its result.",
          "details": [
            "A stack variable var_8 is set to the constant 0xb but never used before the call.",
            "The function performs a tail call to sub_404020, effectively delegating its behavior."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0xb"
          ],
          "unknowns": [
            "The actual effect of sub_404020, which appears to jump to a nullptr placeholder.",
            "The purpose of the local variable var_8."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4040f0",
      "original_name": "sub_4040f0",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4040f0  endbr64 \n  0x4040f4  push    0xc {var_8}\n  0x4040f9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0xc\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0xc;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.32,
          "rationale": "The function simply forwards execution to sub_404020 without performing any operations, acting as a stub or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub",
            "ai_forward_stub"
          ]
        },
        "explain": {
          "summary": "sub_4040f0 is a thin wrapper that initializes a local variable and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function sets a stack variable var_8 to 0xc but does not use it further.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0xc"
          ],
          "unknowns": [
            "The actual behavior and purpose of sub_404020, which appears to jump to a nullptr.",
            "The significance of the local variable var_8."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404100",
      "original_name": "sub_404100",
      "final_name": "ai_stub_function",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404100  endbr64 \n  0x404104  push    0xd {var_8}\n  0x404109  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0xd\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0xd;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_function",
          "confidence": 0.32,
          "rationale": "The function simply forwards to another empty function, acting as a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_no_op",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404100 is a thin wrapper that initializes a local variable to 0xd and then tailcalls sub_404020, returning its result. The called function appears to be a stub that does nothing significant.",
          "details": [
            "Sets a local variable var_8 to the constant 0xd, which is not used elsewhere.",
            "Immediately tailcalls sub_404020 and returns its value."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020 since it jumps to a nullptr and its return value is unclear."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404110",
      "original_name": "sub_404110",
      "final_name": "ai_forward_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404110  endbr64 \n  0x404114  push    0xe {var_8}\n  0x404119  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0xe\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0xe;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_forward_stub",
          "confidence": 0.42,
          "rationale": "The function only sets a local variable and then tail-calls another function (sub_404020) without any imports or strings, indicating it acts as a simple wrapper or stub forwarding to the real implementation.",
          "evidence_refs": [
            "constants:0x404020",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_wrapper_stub",
            "ai_noop_forward"
          ]
        },
        "explain": {
          "summary": "sub_404110 is a thin wrapper that sets a local variable to 0xE and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a local variable var_8 with the constant 0xE but does not use it further.",
            "It performs a tail call to sub_404020, effectively delegating its behavior to that function."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0xe"
          ],
          "unknowns": [
            "The actual operations performed by sub_404020, as its body is not detailed."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404120",
      "original_name": "sub_404120",
      "final_name": "ai_no_op_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404120  endbr64 \n  0x404124  push    0xf {var_8}\n  0x404129  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0xf\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0xf;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_no_op_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and tail-calls another empty stub (sub_404020) with no imports or strings, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [
            "packer",
            "anti_debug",
            "file_io"
          ],
          "alt_names": [
            "ai_dummy_wrapper",
            "ai_stub_function"
          ]
        },
        "explain": {
          "summary": "sub_404120 is a thin wrapper that initializes a local variable to 0xf and then tailcalls sub_404020, which appears to be a stub that does nothing and returns immediately.",
          "details": [
            "The function sets var_8 = 0xf before delegating execution to sub_404020 via a tail call.",
            "sub_404020 sets a local variable to 0 and then jumps to a null pointer, indicating it likely performs no meaningful work and returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual effect or return value of sub_404020, since the jump to nullptr is ambiguous.",
            "The purpose of the local variable var_8 and whether it influences any external state."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer",
        "anti_debug",
        "file_io"
      ]
    },
    {
      "addr": "0x404130",
      "original_name": "sub_404130",
      "final_name": "ai_stub_call",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404130  endbr64 \n  0x404134  push    0x10 {var_8}\n  0x404139  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x10\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x10;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_call",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and tail-calls sub_404020, acting as a simple wrapper or stub without visible side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_wrapper_sub_404020",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404130 is a thin wrapper that initializes a local variable to 0x10 and then tailcalls sub_404020, which appears to be a stub that does nothing and returns.",
          "details": [
            "The function sets var_8 = 0x10 but never uses it before making a tail call to sub_404020.",
            "sub_404020 sets a local variable to 0 and then jumps to a null pointer, indicating it likely performs no meaningful work and simply returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and any side effects of sub_404020 beyond the apparent noop."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404140",
      "original_name": "sub_404140",
      "final_name": "ai_stub_forward",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404140  endbr64 \n  0x404144  push    0x11 {var_8}\n  0x404149  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x11\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x11;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_forward",
          "confidence": 0.35,
          "rationale": "The function only sets a constant and tail-calls another function, acting as a simple wrapper or stub without side effects.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x11"
          ],
          "tags": [
            "packer"
          ],
          "alt_names": [
            "ai_forward_stub",
            "ai_wrapper_noop"
          ]
        },
        "explain": {
          "summary": "sub_404140 is a thin wrapper that initializes a local variable to 0x11 and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function defines a stack variable var_8 and assigns it the constant 0x11, but the variable is never used elsewhere.",
            "It performs a tail call to sub_404020, effectively delegating all functionality to that routine."
          ],
          "evidence_refs": [
            "call:0x404020",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and whether it influences sub_404020 via sideeffects.",
            "The actual behavior of sub_404020, which appears to set var_8 to 0 and jump to a nullptr stub."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer"
      ]
    },
    {
      "addr": "0x404150",
      "original_name": "sub_404150",
      "final_name": "ai_wrapper_init",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404150  endbr64 \n  0x404154  push    0x12 {var_8}\n  0x404159  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x12\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x12;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_init",
          "confidence": 0.42,
          "rationale": "The function sets a constant (0x12) then tail-calls another stub function, suggesting a simple wrapper or initialization routine with no external side effects.",
          "evidence_refs": [
            "constants:0x12",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_init_stub"
          ]
        },
        "explain": {
          "summary": "sub_404150 initializes a local variable with the constant 0x12 and then tail-calls sub_404020, returning its result. The called function appears to perform no meaningful work beyond resetting a local variable.",
          "details": [
            "A local variable var_8 is set to 0x12 but never used before the tail call.",
            "The function performs a tail call to sub_404020 and returns its outcome."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020 beyond resetting a local variable",
            "The purpose of the var_8 assignment in both functions"
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x404160",
      "original_name": "sub_404160",
      "final_name": "ai_stub_function",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404160  endbr64 \n  0x404164  push    0x13 {var_8}\n  0x404169  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x13\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x13;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_function",
          "confidence": 0.62,
          "rationale": "The function only sets a constant and tail-calls another empty stub, indicating a placeholder or no-op routine.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404160 is a thin wrapper that sets a local variable to 0x13 and then tail-calls sub_404020, effectively delegating its behavior to that function.",
          "details": [
            "The function defines a stack variable var_8 = 0x13 but does not use it before the tail call.",
            "It performs a tail call to sub_404020, indicating that any further logic resides in the callee."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the var_8 assignment, as it appears unused.",
            "The actual behavior of sub_404020, which jumps to a nullptr placeholder."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404170",
      "original_name": "sub_404170",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404170  endbr64 \n  0x404174  push    0x14 {var_8}\n  0x404179  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x14\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x14;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and tail-calls another empty function, indicating a stub or no-op wrapper.",
          "evidence_refs": [
            "constants:0x14",
            "call:0x404020"
          ],
          "tags": [
            "anti_debug",
            "packer"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404170 is a thin wrapper that allocates a small stack frame (0x14 bytes) and then tail-calls sub_404020, effectively forwarding control without additional logic.",
          "details": [
            "The function sets a local variable var_8 to 0x14, likely reserving stack space.",
            "It performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The exact purpose of the allocated stack space (var_8) and any side effects of sub_404020."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "anti_debug",
        "packer"
      ]
    },
    {
      "addr": "0x404180",
      "original_name": "sub_404180",
      "final_name": "ai_stub_return",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404180  endbr64 \n  0x404184  push    0x15 {var_8}\n  0x404189  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x15\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x15;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_return",
          "confidence": 0.32,
          "rationale": "The function simply sets a local variable and tail-calls another empty stub (sub_404020) that does nothing, indicating a placeholder or no-op routine.",
          "evidence_refs": [
            "constants:0x15",
            "call:0x404020"
          ],
          "tags": [
            "anti_debug",
            "packer"
          ],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404180 is a thin wrapper that sets a local variable to 0x15 and then tail-calls sub_404020, effectively delegating its functionality.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x15, which is not used elsewhere.",
            "It performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x15"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, which appears to jump to a nullptr or be a stub.",
            "The purpose of the local variable var_8."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "anti_debug",
        "packer"
      ]
    },
    {
      "addr": "0x404190",
      "original_name": "sub_404190",
      "final_name": "ai_call_sub_404020",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404190  endbr64 \n  0x404194  push    0x16 {var_8}\n  0x404199  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x16\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x16;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_call_sub_404020",
          "confidence": 0.32,
          "rationale": "The function simply sets a constant (0x16) then tail-calls sub_404020, acting as a thin wrapper around that call.",
          "evidence_refs": [
            "constants:0x16",
            "call:0x404020"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_wrapper_sub_404020",
            "ai_stub_call"
          ]
        },
        "explain": {
          "summary": "sub_404190 is a thin wrapper that initializes a local variable to 0x16 and then tailcalls sub_404020, which itself appears to be a stub that does nothing and returns.",
          "details": [
            "The function sets var_8 = 0x16 but does not use it before transferring control to sub_404020.",
            "sub_404020 contains only a local variable initialization and a jump to a null pointer, indicating no meaningful operation."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the var_8 assignment and its effect on program state",
            "The actual return value or sideeffects of sub_404020 due to the placeholder jump"
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x4041a0",
      "original_name": "sub_4041a0",
      "final_name": "ai_wrapper_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4041a0  endbr64 \n  0x4041a4  push    0x17 {var_8}\n  0x4041a9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x17\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x17;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_stub",
          "confidence": 0.32,
          "rationale": "Function only sets a local variable then tail-calls another stub function, indicating a simple wrapper or placeholder with no side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [
            "anti_debug",
            "packer"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_stub_call"
          ]
        },
        "explain": {
          "summary": "sub_4041a0 is a thin wrapper that initializes a local variable to 0x17 and then tailcalls sub_404020, effectively delegating its functionality to that function.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x17, which is not used elsewhere in the snippet.",
            "It performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and whether it influences sub_404020 via sideeffects.",
            "The actual behavior of sub_404020, which appears to set var_8 to 0 and jump to a null pointer."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "anti_debug",
        "packer"
      ]
    },
    {
      "addr": "0x4041b0",
      "original_name": "sub_4041b0",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4041b0  endbr64 \n  0x4041b4  push    0x18 {var_8}\n  0x4041b9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x18\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x18;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.32,
          "rationale": "The function simply tail-calls sub_404020, which appears to be a stub/no-op. It likely serves as a placeholder or wrapper with no side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_noop"
          ]
        },
        "explain": {
          "summary": "sub_4041b0 is a thin wrapper that initializes a local variable and then tail-calls sub_404020, returning whatever that function returns.",
          "details": [
            "Sets a local stack variable var_8 to the constant 0x18, but the value is not used before the call.",
            "Performs a tail call to sub_404020, effectively delegating its functionality."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual purpose of the var_8 assignment.",
            "The behavior of sub_404020 beyond the observed jump to nullptr."
          ],
          "confidence": 0.9
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4041c0",
      "original_name": "sub_4041c0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4041c0  endbr64 \n  0x4041c4  push    0x19 {var_8}\n  0x4041c9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x19\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x19;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.35,
          "rationale": "The function only sets a constant and tail-calls another empty stub, indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_no_op",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4041c0 is a thin wrapper that sets a local variable to 0x19 (unused) and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function defines a local int64 variable var_8 = 0x19 but never uses it.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, which appears to jump to a nullptr or be a stub.",
            "The purpose of the var_8 assignment."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4041d0",
      "original_name": "sub_4041d0",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4041d0  endbr64 \n  0x4041d4  push    0x1a {var_8}\n  0x4041d9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x1a\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x1a;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and tail-calls another function that appears to be a stub/no-op, indicating a wrapper around a placeholder operation.",
          "evidence_refs": [
            "constants:0x1a",
            "call:0x404020"
          ],
          "tags": [
            "file_io",
            "process"
          ],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4041d0 initializes a local variable with the constant 0x1a and then performs a tail call to sub_404020, returning whatever that function returns.",
          "details": [
            "The function sets var_8 = 0x1a before delegating execution to sub_404020 via a tail call.",
            "sub_404020 appears to reset var_8 to 0 and then jumps to a null address, suggesting it may be a stub or placeholder with no meaningful operation."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "The actual effect of the jump to nullptr in sub_404020.",
            "The purpose and usage of the local variable var_8 across the two functions."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": [
        "file_io",
        "process"
      ]
    },
    {
      "addr": "0x4041e0",
      "original_name": "sub_4041e0",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4041e0  endbr64 \n  0x4041e4  push    0x1b {var_8}\n  0x4041e9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x1b\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x1b;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a local variable and tail-calls another empty stub, indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub",
            "ai_noop"
          ]
        },
        "explain": {
          "summary": "sub_4041e0 is a thin wrapper that initializes a local variable to 0x1b and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x1b, but the value is never used before the tail call.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "The actual effect of sub_404020, which appears to jump to a nullptr or perform no operation.",
            "The purpose of the local variable var_8 assignment."
          ],
          "confidence": 0.82
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4041f0",
      "original_name": "sub_4041f0",
      "final_name": "ai_stub_forwarder",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4041f0  endbr64 \n  0x4041f4  push    0x1c {var_8}\n  0x4041f9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x1c\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x1c;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_forwarder",
          "confidence": 0.32,
          "rationale": "Function simply forwards execution to sub_404020 with a constant setup, indicating a wrapper or stub behavior.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x1c"
          ],
          "tags": [
            "packer"
          ],
          "alt_names": [
            "ai_wrapper",
            "ai_forward_to_sub_404020"
          ]
        },
        "explain": {
          "summary": "sub_4041f0 is a thin wrapper that sets a local variable to 0x1c and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x1c but does not use it further.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and why it is set to 0x1c.",
            "The behavior of sub_404020, which appears to jump to a nullptr."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer"
      ]
    },
    {
      "addr": "0x404200",
      "original_name": "sub_404200",
      "final_name": "ai_wrapper_call_sub_404020",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404200  endbr64 \n  0x404204  push    0x1d {var_8}\n  0x404209  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x1d\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x1d;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_call_sub_404020",
          "confidence": 0.32,
          "rationale": "The function simply sets a constant and tail-calls sub_404020, acting as a thin wrapper or stub without visible side effects.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x1d"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_call_initializer"
          ]
        },
        "explain": {
          "summary": "sub_404200 is a thin wrapper that initializes a local variable to 0x1d and then tailcalls sub_404020, performing no other observable work.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x1d but never uses it before the tail call.",
            "It immediately transfers execution to sub_404020 via a tail call (call:0x404020)."
          ],
          "evidence_refs": [
            "constants:0x404020",
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and whether sub_404020 uses it.",
            "The actual behavior of sub_404020, which appears to jump to a nullptr placeholder."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404210",
      "original_name": "sub_404210",
      "final_name": "ai_stub_function",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404210  endbr64 \n  0x404214  push    0x1e {var_8}\n  0x404219  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x1e\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x1e;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_function",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and immediately tail-calls another function without any imports or strings, indicating a placeholder or stub wrapper.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x1e"
          ],
          "tags": [
            "packer"
          ],
          "alt_names": [
            "ai_dummy_wrapper",
            "ai_no_op"
          ]
        },
        "explain": {
          "summary": "sub_404210 is a thin wrapper that sets a local variable to 0x1e and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function defines a local variable var_8 = 0x1e but does not use it before the tail call.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and the actual behavior of sub_404020",
            "Any side effects or parameters passed to sub_404020"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer"
      ]
    },
    {
      "addr": "0x404220",
      "original_name": "sub_404220",
      "final_name": "ai_wrapper_set_constant_and_call",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404220  endbr64 \n  0x404224  push    0x1f {var_8}\n  0x404229  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x1f\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x1f;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_set_constant_and_call",
          "confidence": 0.32,
          "rationale": "The function stores a constant (0x1f) in a local variable then tail-calls another function, suggesting a simple wrapper or stub that sets a flag/value before delegating work.",
          "evidence_refs": [
            "constants:0x1f",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_set_constant_wrapper",
            "ai_stub_call"
          ]
        },
        "explain": {
          "summary": "sub_404220 is a thin wrapper that initializes a local variable to 0x1f and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x1f but does not use it before the tail call.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, which appears to jump to a nullptr or be a stub.",
            "Any side effects or return value semantics of sub_404020."
          ],
          "confidence": 0.68
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x404230",
      "original_name": "sub_404230",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404230  endbr64 \n  0x404234  push    0x20 {var_8}\n  0x404239  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x20\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x20;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.68,
          "rationale": "The function only sets a local variable and tail-calls another stub function that does nothing, indicating a no-op or wrapper behavior.",
          "evidence_refs": [
            "constants:0x20",
            "call:0x404020"
          ],
          "tags": [
            "packer"
          ],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_dummy_function"
          ]
        },
        "explain": {
          "summary": "sub_404230 is a thin wrapper that initializes a local variable to 0x20 and then tailcalls sub_404020, returning whatever that function returns. The called function appears to be a stub that does nothing meaningful.",
          "details": [
            "Sets a local variable var_8 to the constant 0x20 but does not use it before the tail call.",
            "Immediately tailcalls sub_404020 and returns its result, acting as a simple forwarder."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the var_8 assignment and whether it influences sub_404020 via registers or stack.",
            "The actual behavior of sub_404020, which shows a jump to nullptr and may be a placeholder."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": true,
      "tags": [
        "packer"
      ]
    },
    {
      "addr": "0x404240",
      "original_name": "sub_404240",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404240  endbr64 \n  0x404244  push    0x21 {var_8}\n  0x404249  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x21\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x21;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and tail-calls another function, acting as a thin wrapper or stub without visible side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_tailcall_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404240 is a thin wrapper that sets a local variable to 0x21 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function defines a local variable var_8 = 0x21 but never uses it before the tail call.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020 since its body appears to jump to nullptr, and the purpose of the var_8 assignment."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404250",
      "original_name": "sub_404250",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404250  endbr64 \n  0x404254  push    0x22 {var_8}\n  0x404259  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x22\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x22;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a local constant and tail-calls another empty stub, indicating a no-op wrapper or placeholder behavior.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x22"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404250 initializes a local variable with the constant 0x22 and then tail-calls sub_404020, returning whatever that function returns. No other operations are performed.",
          "details": [
            "A 64-bit local variable var_8 is set to 0x22 but never used.",
            "The function performs a tail call to sub_404020 and returns its result."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect and return value of sub_404020",
            "The purpose of setting var_8 to 0x22"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404260",
      "original_name": "sub_404260",
      "final_name": "ai_noop",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404260  endbr64 \n  0x404264  push    0x23 {var_8}\n  0x404269  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x23\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x23;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop",
          "confidence": 0.78,
          "rationale": "The function only sets a local variable and tail-calls another empty stub, effectively performing no meaningful operation.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404260 initializes a local variable to 0x23 then immediately tailcalls sub_404020, acting as a thin wrapper that delegates its work to the callee.",
          "details": [
            "The function sets var_8 = 0x23 but never uses it before the tailcall.",
            "It performs a tailcall to sub_404020, which appears to be a stub that sets var_8 = 0 and jumps to a null address."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x23"
          ],
          "unknowns": [
            "The actual effect of sub_404020's jump to nullptr and any sideeffects of the var_8 assignments."
          ],
          "confidence": 0.82
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404270",
      "original_name": "sub_404270",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404270  endbr64 \n  0x404274  push    0x24 {var_8}\n  0x404279  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x24\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x24;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and tail-calls another empty stub (sub_404020), indicating it acts as a simple wrapper or placeholder with no real behavior.",
          "evidence_refs": [
            "constants:0x24",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "anti_debug"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404270 is a thin wrapper that initializes a local variable with the constant 0x24 and then tail-calls sub_404020, which appears to be a stub that does nothing and returns.",
          "details": [
            "The function sets var_8 to 0x24 before performing a tail call to sub_404020.",
            "sub_404020 sets its own var_8 to 0 and then jumps to a null pointer, indicating no further action."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of the local variable var_8 on program state.",
            "The return value and side effects of sub_404020 due to the jump to nullptr."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "anti_debug"
      ]
    },
    {
      "addr": "0x404280",
      "original_name": "sub_404280",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404280  endbr64 \n  0x404284  push    0x25 {var_8}\n  0x404289  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x25\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x25;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and tail-calls another empty stub, indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "constants:0x25",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_dummy_function"
          ]
        },
        "explain": {
          "summary": "sub_404280 is a thin wrapper that sets a local variable to 0x25 and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a local variable var_8 with the constant 0x25 but does not use it further.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x25"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, which appears to jump to a nullptr or be a stub.",
            "The purpose of the local variable var_8."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404290",
      "original_name": "sub_404290",
      "final_name": "ai_tailcall_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404290  endbr64 \n  0x404294  push    0x26 {var_8}\n  0x404299  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x26\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x26;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_tailcall_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and then tail-calls another function (sub_404020), acting as a simple wrapper or dispatcher.",
          "evidence_refs": [
            "constants:0x26",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_forward",
            "ai_wrapper_call"
          ]
        },
        "explain": {
          "summary": "sub_404290 is a thin wrapper that initializes a local variable and then tail-calls sub_404020, effectively delegating its functionality to that routine.",
          "details": [
            "The function sets a local variable var_8 to the constant 0x26, which appears unused before the tail call.",
            "It performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, since its implementation is not provided.",
            "Whether the local variable assignment has any side effects or is optimized away."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4042a0",
      "original_name": "sub_4042a0",
      "final_name": "ai_tailcall_wrapper_27",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4042a0  endbr64 \n  0x4042a4  push    0x27 {var_8}\n  0x4042a9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x27\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x27;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_tailcall_wrapper_27",
          "confidence": 0.32,
          "rationale": "The function sets a constant and immediately tail-calls sub_404020, acting as a simple wrapper or dispatcher with no external imports or strings.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x27"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_call_sub_404020",
            "ai_wrapper_27"
          ]
        },
        "explain": {
          "summary": "sub_4042a0 is a thin wrapper that initializes a local variable to 0x27 and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function defines a local int64_t variable set to the constant 0x27, but the variable is not used elsewhere.",
            "It performs a tail call to sub_404020, effectively delegating its functionality to that routine."
          ],
          "evidence_refs": [
            "constants:0x27",
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, since its implementation is not provided."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x4042b0",
      "original_name": "sub_4042b0",
      "final_name": "ai_tailcall_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4042b0  endbr64 \n  0x4042b4  push    0x28 {var_8}\n  0x4042b9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x28\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x28;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_tailcall_wrapper",
          "confidence": 0.35,
          "rationale": "The function simply forwards execution to sub_404020 via a tail call, acting as a thin wrapper or stub without visible side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_forward_call"
          ]
        },
        "explain": {
          "summary": "sub_4042b0 is a thin wrapper that prepares a stack variable and then tail-calls sub_404020, returning its result unchanged.",
          "details": [
            "The function sets a local variable (var_8) to 0x28, likely allocating stack space.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, since its implementation is not provided."
          ],
          "confidence": 0.88
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4042c0",
      "original_name": "sub_4042c0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4042c0  endbr64 \n  0x4042c4  push    0x29 {var_8}\n  0x4042c9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x29\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x29;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and then tail-calls another function (sub_404020) without performing any visible work, suggesting it is a thin wrapper or stub.",
          "evidence_refs": [
            "constants:0x29",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder_call"
          ]
        },
        "explain": {
          "summary": "sub_4042c0 is a thin wrapper that initializes a local variable to 0x29 and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x29 but never uses it.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, since its implementation appears to jump to a nullptr or is otherwise undefined."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x4042d0",
      "original_name": "sub_4042d0",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4042d0  endbr64 \n  0x4042d4  push    0x2a {var_8}\n  0x4042d9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x2a\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x2a;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a constant and tail-calls another empty stub, indicating a placeholder or wrapper with no observable behavior.",
          "evidence_refs": [
            "call:0x404020",
            "constant:0x2a"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_call",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4042d0 initializes a local variable with the constant 0x2a and then tail-calls sub_404020, effectively delegating its functionality to that routine.",
          "details": [
            "The function sets var_8 to 0x2a, but the variable is not used before the tail call.",
            "It performs a tail call to sub_404020, which appears to be a stub that does nothing meaningful (sets var_8 to 0 and jumps to nullptr)."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020 beyond the placeholder code.",
            "Whether the constant 0x2a influences any external state or is used by the callee."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4042e0",
      "original_name": "sub_4042e0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4042e0  endbr64 \n  0x4042e4  push    0x2b {var_8}\n  0x4042e9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x2b\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x2b;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a local constant and tail-calls another stub function, indicating a placeholder or wrapper with no observable side effects.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x2b"
          ],
          "tags": [],
          "alt_names": [
            "ai_dummy_forward",
            "ai_noop_wrapper"
          ]
        },
        "explain": {
          "summary": "sub_4042e0 is a thin wrapper that initializes a local variable to 0x2b and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function defines a local int64_t variable set to the constant 0x2b, but the variable is not used elsewhere.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and whether its value influences sub_404020.",
            "The actual behavior of sub_404020, which appears to set a variable to zero and jump to a null pointer."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4042f0",
      "original_name": "sub_4042f0",
      "final_name": "ai_forward_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4042f0  endbr64 \n  0x4042f4  push    0x2c {var_8}\n  0x4042f9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x2c\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x2c;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_forward_stub",
          "confidence": 0.62,
          "rationale": "The function simply sets a local variable and tail-calls another function without any other logic, acting as a thin wrapper or stub forwarding to sub_404020.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x2c"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_stub_forward"
          ]
        },
        "explain": {
          "summary": "sub_4042f0 is a thin wrapper that sets a local variable to 0x2c and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x2c, which appears unused.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x2c"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, which jumps to a nullptr placeholder, is not determined."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404300",
      "original_name": "sub_404300",
      "final_name": "ai_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404300  endbr64 \n  0x404304  push    0x2d {var_8}\n  0x404309  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x2d\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x2d;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub",
          "confidence": 0.62,
          "rationale": "Function sets a local constant then tail-calls another empty function, indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_placeholder",
            "ai_dummy"
          ]
        },
        "explain": {
          "summary": "sub_404300 initializes a local variable with the constant 0x2d and then performs a tail call to sub_404020, returning its result.",
          "details": [
            "The function sets var_8 = 0x2d but does not use it before calling sub_404020.",
            "It directly tail-calls sub_404020, effectively acting as a wrapper or forwarder."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020 since it jumps to a nullptr placeholder.",
            "Whether the constant 0x2d is intended for side effects or later use."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404310",
      "original_name": "sub_404310",
      "final_name": "ai_wrapper_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404310  endbr64 \n  0x404314  push    0x2e {var_8}\n  0x404319  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x2e\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x2e;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_stub",
          "confidence": 0.32,
          "rationale": "The function only sets a local constant (0x2e) and immediately tail-calls another function that appears to be a no-op placeholder, suggesting it acts as a thin wrapper or stub without side effects.",
          "evidence_refs": [
            "constants:0x2e",
            "call:0x404020"
          ],
          "tags": [
            "anti_debug",
            "packer"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder_call"
          ]
        },
        "explain": {
          "summary": "sub_404310 initializes a local variable with the constant 0x2e and then immediately tail-calls sub_404020, returning its result.",
          "details": [
            "The function sets var_8 = 0x2e but does not use it before the tail call.",
            "It performs a tail call to sub_404020, effectively acting as a thin wrapper."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x2e"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, which appears to jump to a nullptr or be a stub."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "anti_debug",
        "packer"
      ]
    },
    {
      "addr": "0x404320",
      "original_name": "sub_404320",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404320  endbr64 \n  0x404324  push    0x2f {var_8}\n  0x404329  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x2f\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x2f;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.62,
          "rationale": "The function only sets a local variable and tail-calls another empty stub, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_function",
            "ai_dummy_call"
          ]
        },
        "explain": {
          "summary": "sub_404320 is a thin wrapper that initializes a local variable to 0x2f and then tailcalls sub_404020, which appears to be a stub that does nothing and returns.",
          "details": [
            "The function sets var_8 = 0x2f but does not use it before transferring control.",
            "It performs a tail call to sub_404020, which only sets var_8 = 0 and jumps to a null pointer, indicating no meaningful operation."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The intended purpose of the var_8 assignment in both functions.",
            "Any side effects or external interactions of sub_404020 beyond the observed stub."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404330",
      "original_name": "sub_404330",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404330  endbr64 \n  0x404334  push    0x30 {var_8}\n  0x404339  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x30\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x30;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.62,
          "rationale": "Function simply forwards execution to another stub function without performing any operations, acting as a no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_stub"
          ]
        },
        "explain": {
          "summary": "sub_404330 is a thin wrapper that initializes a local variable to 0x30 and then tail-calls sub_404020, returning whatever that function returns. sub_404020 appears to be a stub that jumps to a null pointer, likely performing no meaningful work.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x30 but does not use it before the tail call.",
            "It performs a tail call to sub_404020 and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020",
            "Callees:0x404020"
          ],
          "unknowns": [
            "The actual runtime effect of sub_404020 since it jumps to a nullptr.",
            "The purpose of the var_8 initialization to 0x30."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404340",
      "original_name": "sub_404340",
      "final_name": "ai_dummy_function",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404340  endbr64 \n  0x404344  push    0x31 {var_8}\n  0x404349  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x31\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x31;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_function",
          "confidence": 0.35,
          "rationale": "The function only assigns a constant to a local variable and tail-calls another stub-like function, indicating it performs no meaningful work and likely serves as a placeholder or no-op.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_stub"
          ]
        },
        "explain": {
          "summary": "sub_404340 initializes a local variable with the constant 0x31 and then tail-calls sub_404020, returning whatever that function returns. The called function appears to be a stub that does nothing meaningful.",
          "details": [
            "The function sets var_8 to 0x31, but the variable is never used before the tail call.",
            "It performs a tail call to sub_404020, effectively delegating its behavior.",
            "sub_404020 sets its own var_8 to 0 and then jumps to a null pointer, indicating it likely does nothing or is a placeholder."
          ],
          "evidence_refs": [
            "constants:0x31",
            "call:0x404020",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "The actual effect of sub_404020's jump to nullptr",
            "Whether var_8 influences any external state or is optimized away"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404350",
      "original_name": "sub_404350",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404350  endbr64 \n  0x404354  push    0x32 {var_8}\n  0x404359  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x32\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x32;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.62,
          "rationale": "The function only sets a constant and tail-calls another minimal function that does nothing, indicating a stub or no-op wrapper.",
          "evidence_refs": [
            "constants:0x32",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_no_op",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404350 initializes a local variable to 0x32 then immediately tail-calls sub_404020, returning its result without further processing.",
          "details": [
            "The function sets var_8 = 0x32, but this value is never used before the tail call.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020, which appears to jump to a nullptr or be a stub.",
            "The purpose of the unused var_8 assignment."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404360",
      "original_name": "sub_404360",
      "final_name": "ai_set_default_config_33",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404360  endbr64 \n  0x404364  push    0x33 {var_8}\n  0x404369  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x33\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x33;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_default_config_33",
          "confidence": 0.32,
          "rationale": "The function assigns a constant value (0x33) to a local variable and then tail-calls another internal function, suggesting it prepares a default configuration or flag before delegating work.",
          "evidence_refs": [
            "constants:0x33",
            "call:0x404020"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_init_wrapper",
            "ai_set_flag_33"
          ]
        },
        "explain": {
          "summary": "sub_404360 initializes a local variable to 0x33 and then immediately tail-calls sub_404020, returning its result without further processing.",
          "details": [
            "A local 64-bit variable (var_8) is set to the constant 0x33 but never used.",
            "The function performs a tail call to sub_404020, effectively delegating its behavior to that routine."
          ],
          "evidence_refs": [
            "constants:0x33",
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the unused var_8 assignment.",
            "The actual functionality performed by sub_404020, which appears to jump to a nullptr."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404370",
      "original_name": "sub_404370",
      "final_name": "ai_stub_forwarder",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404370  endbr64 \n  0x404374  push    0x34 {var_8}\n  0x404379  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x34\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x34;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_forwarder",
          "confidence": 0.32,
          "rationale": "The function simply sets a constant and tail-calls another function without any visible side effects, indicating a wrapper or stub behavior.",
          "evidence_refs": [
            "constants:0x34",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_wrapper_call",
            "ai_no_op_forward"
          ]
        },
        "explain": {
          "summary": "sub_404370 is a thin wrapper that initializes a local variable to 0x34 and then tail-calls sub_404020, which appears to be a stub that does nothing and returns.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x34 before performing a tail call to sub_404020.",
            "sub_404020 sets its own var_8 to 0 and then jumps to a null pointer, indicating no further action."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x34"
          ],
          "unknowns": [
            "The actual effect of the var_8 assignments (if any) on program state.",
            "The purpose of the jump to nullptr in sub_404020."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404380",
      "original_name": "sub_404380",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404380  endbr64 \n  0x404384  push    0x35 {var_8}\n  0x404389  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x35\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x35;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local constant (0x35) and tail-calls another empty stub function, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "constants:0x35",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub",
            "ai_noop"
          ]
        },
        "explain": {
          "summary": "sub_404380 is a thin wrapper that initializes a local variable to 0x35 and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function defines a local int64_t variable var_8 and assigns it the constant 0x35, but the variable is never used elsewhere.",
            "It performs a tail call to sub_404020, effectively delegating all further execution to that function."
          ],
          "evidence_refs": [
            "constants:0x35",
            "call:0x404020",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and whether it influences sub_404020 via a calling convention or sideeffect.",
            "The actual behavior of sub_404020, which appears to set var_8 to 0 and jump to a null pointer, but its effect is unclear."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404390",
      "original_name": "sub_404390",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404390  endbr64 \n  0x404394  push    0x36 {var_8}\n  0x404399  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x36\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x36;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "Function simply forwards to sub_404020 after setting a constant, indicating a stub or wrapper with no visible side effects.",
          "evidence_refs": [
            "constants:0x36",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_no_op_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404390 is a thin wrapper that sets a local variable to 0x36 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x36, but the variable is not used elsewhere.",
            "It performs a tail call to sub_404020 (call:0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x36"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, which appears to jump to a nullptr or be a stub."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4043a0",
      "original_name": "sub_4043a0",
      "final_name": "ai_stub_noop",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4043a0  endbr64 \n  0x4043a4  push    0x37 {var_8}\n  0x4043a9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x37\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x37;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_noop",
          "confidence": 0.68,
          "rationale": "The function only sets a constant (0x37) and tail-calls another empty stub function, indicating a placeholder or no-op behavior.",
          "evidence_refs": [
            "constants:0x37",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_dummy",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4043a0 initializes a local variable with the constant 0x37 and then tail-calls sub_404020, effectively acting as a thin wrapper that forwards execution.",
          "details": [
            "Sets a stack variable var_8 to the value 0x37.",
            "Performs a tail-call to sub_404020 and returns its result."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8.",
            "The actual behavior of sub_404020 beyond its stub appearance.",
            "Any side effects or return value semantics."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4043b0",
      "original_name": "sub_4043b0",
      "final_name": "ai_tailcall_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4043b0  endbr64 \n  0x4043b4  push    0x38 {var_8}\n  0x4043b9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x38\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x38;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_tailcall_wrapper",
          "confidence": 0.32,
          "rationale": "The function does nothing but set a local variable and tail-call another function (sub_404020), acting as a simple wrapper or stub.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x38"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_wrapper_init"
          ]
        },
        "explain": {
          "summary": "sub_4043b0 is a thin wrapper that sets a local variable and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x38, which is not used elsewhere.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual behavior and side effects of sub_404020",
            "Purpose of the unused var_8 assignment"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4043c0",
      "original_name": "sub_4043c0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4043c0  endbr64 \n  0x4043c4  push    0x39 {var_8}\n  0x4043c9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x39\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x39;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and tail-calls another function without any imports or strings, indicating a simple wrapper or stub behavior.",
          "evidence_refs": [
            "constants:0x39",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_forward_to_404020",
            "ai_no_op_wrapper"
          ]
        },
        "explain": {
          "summary": "sub_4043c0 initializes a local variable with the constant 0x39 and then tail-calls sub_404020, returning its result without further processing.",
          "details": [
            "A local variable var_8 is set to 0x39 (57) but is not used elsewhere in the function.",
            "The function performs a tail call to sub_404020 at address 0x404020 and returns its value directly."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and whether its value influences sub_404020 via registers or stack.",
            "The actual behavior of sub_404020, which appears to jump to a nullptr placeholder."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4043d0",
      "original_name": "sub_4043d0",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4043d0  endbr64 \n  0x4043d4  push    0x3a {var_8}\n  0x4043d9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x3a\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x3a;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "Function sets a constant (0x3a) then tail-calls another empty stub, indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "constants:0x3a",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_noop_call"
          ]
        },
        "explain": {
          "summary": "sub_4043d0 initializes a local variable with the constant 0x3a and then tail-calls sub_404020, returning its result without further processing.",
          "details": [
            "A local variable var_8 is set to 0x3a but never used before the tail call.",
            "The function performs a tail call to sub_404020 at address 0x404020 and returns its value."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x3a"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, which appears to jump to a nullptr.",
            "Whether var_8 influences any hidden state or is optimized away."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4043e0",
      "original_name": "sub_4043e0",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4043e0  endbr64 \n  0x4043e4  push    0x3b {var_8}\n  0x4043e9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x3b\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x3b;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "The function only assigns a constant (0x3b) to a local variable and then tail-calls an empty stub (sub_404020), indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "constants:0x3b",
            "call:0x404020"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_set_constant_59"
          ]
        },
        "explain": {
          "summary": "sub_4043e0 is a thin wrapper that initializes a local variable to 0x3b and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x3b, which is not used elsewhere.",
            "It performs a tail call to sub_404020 at address 0x404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020 (it appears to jump to nullptr).",
            "Whether var_8 influences any later code via sideeffects."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x4043f0",
      "original_name": "sub_4043f0",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4043f0  endbr64 \n  0x4043f4  push    0x3c {var_8}\n  0x4043f9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x3c\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x3c;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and tail-calls another empty stub, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "constants:0x3c",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_stub_caller"
          ]
        },
        "explain": {
          "summary": "sub_4043f0 is a thin wrapper that sets a local variable to 0x3c and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x3c, which appears unused.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x3c"
          ],
          "unknowns": [
            "The actual behavior of sub_404020 (it appears to jump to a nullptr or be a stub).",
            "The purpose of the var_8 assignment."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404400",
      "original_name": "sub_404400",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404400  endbr64 \n  0x404404  push    0x3d {var_8}\n  0x404409  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x3d\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x3d;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant (0x3d) and tail-calls another empty stub, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "constants:0x3d",
            "call:0x404020"
          ],
          "tags": [
            "packer",
            "anti_debug",
            "config"
          ],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404400 is a thin wrapper that sets a local constant (0x3d) and then tailcalls sub_404020, effectively delegating its behavior to that function.",
          "details": [
            "The function defines a local variable var_8 = 0x3d but does not use it before returning.",
            "It performs a tail call to sub_404020, passing control directly without additional processing."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x3d"
          ],
          "unknowns": [
            "The actual functionality and side effects of sub_404020, since its body appears empty or a jump to nullptr.",
            "Whether var_8 is intended for future use or debugging."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": [
        "packer",
        "anti_debug",
        "config"
      ]
    },
    {
      "addr": "0x404410",
      "original_name": "sub_404410",
      "final_name": "ai_noop_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404410  endbr64 \n  0x404414  push    0x3e {var_8}\n  0x404419  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x3e\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x3e;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_stub",
          "confidence": 0.32,
          "rationale": "The function only sets a local constant and tail-calls another empty stub, indicating a no-op or placeholder routine with no observable side effects.",
          "evidence_refs": [
            "constants:0x3e",
            "call:0x404020"
          ],
          "tags": [
            "packer",
            "anti_debug"
          ],
          "alt_names": [
            "ai_placeholder",
            "ai_dummy"
          ]
        },
        "explain": {
          "summary": "sub_404410 initializes a local variable with the constant 0x3e and then tail-calls sub_404020, effectively delegating its behavior to that function.",
          "details": [
            "A local variable var_8 is set to 0x3e but never used before the tail call.",
            "The function performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x3e"
          ],
          "unknowns": [
            "The purpose of the var_8 assignment, as it appears unused.",
            "The actual effect of sub_404020, which shows a jump to nullptr and may be a stub."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer",
        "anti_debug"
      ]
    },
    {
      "addr": "0x404420",
      "original_name": "sub_404420",
      "final_name": "ai_flag_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404420  endbr64 \n  0x404424  push    0x3f {var_8}\n  0x404429  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x3f\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x3f;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_flag_wrapper",
          "confidence": 0.32,
          "rationale": "The function sets a constant value (0x3f) then tail-calls another function, acting as a simple wrapper or initializer with a flag.",
          "evidence_refs": [
            "constants:0x3f",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_init_wrapper",
            "ai_set_flag_and_call"
          ]
        },
        "explain": {
          "summary": "sub_404420 is a thin wrapper that initializes a local variable to 0x3f and then tailcalls sub_404020, which appears to be a stub that sets a local variable to zero and jumps to a null address, effectively doing nothing useful.",
          "details": [
            "The function sets var_8 = 0x3f but never uses it before transferring control.",
            "It performs a tail call to sub_404020, delegating any further behavior.",
            "sub_404020 sets its own var_8 = 0 and then jumps to a nullptr, indicating a placeholder or noop implementation."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x3f"
          ],
          "unknowns": [
            "The exact effect of the jump to nullptr in sub_404020 (e.g., crash, return, or no operation).",
            "Return value semantics of sub_404020."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x404430",
      "original_name": "sub_404430",
      "final_name": "ai_wrapper_call_0x40",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404430  endbr64 \n  0x404434  push    0x40 {var_8}\n  0x404439  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x40\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x40;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_call_0x40",
          "confidence": 0.32,
          "rationale": "The function sets a constant value (0x40) and then tail-calls another function, acting as a thin wrapper. No imports or strings indicate a simple delegating behavior.",
          "evidence_refs": [
            "constants:0x40",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_0x40",
            "ai_delegate_call"
          ]
        },
        "explain": {
          "summary": "sub_404430 is a thin wrapper that sets a local variable to 0x40 and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function defines a local variable var_8 = 0x40 but does not use it before the tail call.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The role of the local variable var_8",
            "The actual behavior of sub_404020 since it jumps to nullptr"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404440",
      "original_name": "sub_404440",
      "final_name": "ai_placeholder_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404440  endbr64 \n  0x404444  push    0x41 {var_8}\n  0x404449  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x41\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x41;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_placeholder_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant (0x41) and immediately tail-calls another minimal stub (sub_404020) that does nothing, indicating a placeholder or wrapper with no real logic.",
          "evidence_refs": [
            "constants:0x41",
            "call:0x404020"
          ],
          "tags": [
            "packer",
            "anti_debug",
            "process"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_stub_function"
          ]
        },
        "explain": {
          "summary": "sub_404440 initializes a local variable with the constant 0x41 and then tail-calls sub_404020, effectively acting as a thin wrapper that forwards execution to sub_404020.",
          "details": [
            "The function sets var_8 to 0x41, but the variable is not used elsewhere before the tail call.",
            "It performs a tail call to sub_404020 and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x41"
          ],
          "unknowns": [
            "The actual functionality of sub_404020, which appears to jump to a nullptr or be a placeholder.",
            "Whether var_8 influences any side effects outside the shown code."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer",
        "anti_debug",
        "process"
      ]
    },
    {
      "addr": "0x404450",
      "original_name": "sub_404450",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404450  endbr64 \n  0x404454  push    0x42 {var_8}\n  0x404459  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x42\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x42;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.45,
          "rationale": "Function only sets a local constant (0x42) and immediately tail-calls another stub function, indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_constant_stub"
          ]
        },
        "explain": {
          "summary": "sub_404450 initializes a local variable with the constant 0x42 and then tail-calls sub_404020, effectively delegating its execution without using the variable.",
          "details": [
            "The function sets var_8 to 0x42 but does not use it before the tail call.",
            "It performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "constants:0x404020",
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, which appears to jump to a nullptr stub.",
            "Whether var_8 has any side effects in a broader context."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404460",
      "original_name": "sub_404460",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404460  endbr64 \n  0x404464  push    0x43 {var_8}\n  0x404469  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x43\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x43;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and immediately tail-calls another empty stub, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x43"
          ],
          "tags": [
            "packer"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_stub_function"
          ]
        },
        "explain": {
          "summary": "sub_404460 initializes a local variable with the constant 0x43 and then tail-calls sub_404020, which appears to be a stub that does nothing and returns.",
          "details": [
            "The function sets var_8 = 0x43 but never uses it before calling sub_404020.",
            "sub_404020 sets a local variable to 0 and jumps to a null pointer, indicating no meaningful operation."
          ],
          "evidence_refs": [
            "constants:0x404020",
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and why sub_404020 exists as a no-op."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer"
      ]
    },
    {
      "addr": "0x404470",
      "original_name": "sub_404470",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404470  endbr64 \n  0x404474  push    0x44 {var_8}\n  0x404479  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x44\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x44;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local constant and tail-calls another empty stub (sub_404020), indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x44"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_dummy"
          ]
        },
        "explain": {
          "summary": "sub_404470 is a thin wrapper that initializes a local variable to 0x44 and then tail-calls sub_404020, which appears to be a stub that does nothing and returns.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x44 but does not use it before calling sub_404020.",
            "sub_404020 sets its own var_8 to 0 and then jumps to a null pointer, effectively performing no operation before returning."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x44"
          ],
          "unknowns": [
            "The intended purpose of the var_8 assignments and whether they affect caller state.",
            "The exact behavior of the jump to nullptr in sub_404020."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404480",
      "original_name": "sub_404480",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404480  endbr64 \n  0x404484  push    0x45 {var_8}\n  0x404489  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x45\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x45;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.62,
          "rationale": "The function only sets a constant and tail-calls another empty stub, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x45"
          ],
          "tags": [],
          "alt_names": [
            "ai_no_op",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404480 is a thin wrapper that sets a local variable to 0x45 and then tail-calls sub_404020, which appears to perform no meaningful work and jumps to a null address.",
          "details": [
            "The function initializes a local variable var_8 with the constant 0x45 but does not use it.",
            "It immediately tail-calls sub_404020, effectively delegating its behavior."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020 since it jumps to a nullptr placeholder.",
            "The purpose of the var_8 assignment in both functions."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404490",
      "original_name": "sub_404490",
      "final_name": "ai_set_flag_0x46_and_call_handler",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404490  endbr64 \n  0x404494  push    0x46 {var_8}\n  0x404499  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x46\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x46;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_flag_0x46_and_call_handler",
          "confidence": 0.32,
          "rationale": "The function assigns a constant 0x46 to a local variable then tail-calls sub_404020, suggesting it sets a flag or mode before delegating to a generic handler.",
          "evidence_refs": [
            "constants:0x46",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "misc"
          ],
          "alt_names": [
            "ai_flag_0x46_wrapper",
            "ai_initialize_and_delegate"
          ]
        },
        "explain": {
          "summary": "sub_404490 is a thin wrapper that initializes a local variable to 0x46 and then tailcalls sub_404020, returning its result.",
          "details": [
            "A local variable var_8 is set to the constant 0x46 but never used elsewhere.",
            "The function performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x46"
          ],
          "unknowns": [
            "The actual effect of sub_404020, which appears to jump to a nullptr or be a stub.",
            "The purpose of the unused var_8 assignment."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "misc"
      ]
    },
    {
      "addr": "0x4044a0",
      "original_name": "sub_4044a0",
      "final_name": "ai_stub_init_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4044a0  endbr64 \n  0x4044a4  push    0x47 {var_8}\n  0x4044a9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x47\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x47;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_init_wrapper",
          "confidence": 0.32,
          "rationale": "Function simply forwards to sub_404020 after setting a constant, indicating a wrapper or stub for initialization/configuration.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x47"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_init_stub",
            "ai_wrapper_call"
          ]
        },
        "explain": {
          "summary": "sub_4044a0 is a thin wrapper that initializes a local variable with the constant 0x47 and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x47, but the value is never used elsewhere.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns whatever that function returns."
          ],
          "evidence_refs": [
            "constants:0x47",
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, which appears to jump to a nullptr or perform no operation."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x4044b0",
      "original_name": "sub_4044b0",
      "final_name": "ai_wrapper_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4044b0  endbr64 \n  0x4044b4  push    0x48 {var_8}\n  0x4044b9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x48\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x48;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_stub",
          "confidence": 0.32,
          "rationale": "Function simply forwards execution to sub_404020 with a constant setup, acting as a thin wrapper or stub without visible side effects.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x48"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_call",
            "ai_forwarder"
          ]
        },
        "explain": {
          "summary": "sub_4044b0 is a thin wrapper that simply tail-calls sub_404020 and returns its result, with a local variable initialized to 0x48 that is not otherwise used.",
          "details": [
            "The function sets a local variable var_8 to the constant 0x48, then performs a tail call to sub_404020.",
            "No imports, strings, or additional logic are present, indicating it likely forwards control to sub_404020 without modification."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x48"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and any side effects of sub_404020."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4044c0",
      "original_name": "sub_4044c0",
      "final_name": "ai_stub_return",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4044c0  endbr64 \n  0x4044c4  push    0x49 {var_8}\n  0x4044c9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x49\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x49;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_return",
          "confidence": 0.32,
          "rationale": "The function only sets a local constant and tail-calls another function that appears to be a no-op placeholder, indicating a stub or pass-through behavior.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_no_op",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4044c0 is a thin wrapper that initializes a local variable to the constant 0x49 and then tail-calls sub_404020, returning whatever that function returns.",
          "details": [
            "The function sets var_8 = 0x49, which appears unused before the tail call.",
            "It performs a tail call to sub_404020 at address 0x404020 and returns its result."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x49"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, which seems to jump to a nullptr or be a placeholder."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4044d0",
      "original_name": "sub_4044d0",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4044d0  endbr64 \n  0x4044d4  push    0x4a {var_8}\n  0x4044d9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x4a\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x4a;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.35,
          "rationale": "Function assigns a constant then tail-calls another function without visible side effects; likely a placeholder or simple wrapper stub.",
          "evidence_refs": [
            "constants:0x4a",
            "call:0x404020"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_noop_caller"
          ]
        },
        "explain": {
          "summary": "sub_4044d0 is a thin wrapper that initializes a local variable to 0x4a and then tailcalls sub_404020, returning its result.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x4a, which is never used elsewhere.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, since its implementation is not provided beyond a placeholder jump."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x4044e0",
      "original_name": "sub_4044e0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4044e0  endbr64 \n  0x4044e4  push    0x4b {var_8}\n  0x4044e9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x4b\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x4b;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local constant and tail-calls another function without any imports or strings, indicating a simple wrapper or placeholder stub.",
          "evidence_refs": [
            "constants:0x4b",
            "call:0x404020"
          ],
          "tags": [
            "packer"
          ],
          "alt_names": [
            "ai_no_op_wrapper",
            "ai_placeholder_call"
          ]
        },
        "explain": {
          "summary": "sub_4044e0 is a thin wrapper that initializes a local variable to 0x4b and then tail-calls sub_404020, returning its result. The called function appears to be a stub that sets a local variable to zero and jumps to a null pointer, indicating no meaningful operation.",
          "details": [
            "The function defines a local variable var_8 = 0x4b but does not use it before making a tail call to sub_404020.",
            "sub_404020 sets its own var_8 to zero and then jumps to a nullptr, suggesting it performs no action and likely returns a default value."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual effect or return value of sub_404020 due to the jump to nullptr.",
            "The purpose of the local variable var_8 in both functions."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer"
      ]
    },
    {
      "addr": "0x4044f0",
      "original_name": "sub_4044f0",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4044f0  endbr64 \n  0x4044f4  push    0x4c {var_8}\n  0x4044f9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x4c\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x4c;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.32,
          "rationale": "The function simply forwards execution to sub_404020, which appears to be a stub that does nothing. This pattern suggests a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4044f0 is a thin wrapper that sets a local variable to 0x4c and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a local variable var_8 with the constant 0x4c but does not use it further.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual behavior and side effects of sub_404020, since its implementation is not provided.",
            "The purpose of the unused local variable var_8."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404500",
      "original_name": "sub_404500",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404500  endbr64 \n  0x404504  push    0x4d {var_8}\n  0x404509  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x4d\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x4d;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and tail-calls another stub function that does nothing, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404500 is a thin wrapper that initializes a local variable to 0x4d and then tailcalls sub_404020, effectively delegating its work to that function.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x4d, which appears unused.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "constants:0x404020",
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect or return value of sub_404020, since its implementation shows a jump to nullptr.",
            "The purpose of the local variable assignment (var_8) if any side effects exist."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404510",
      "original_name": "sub_404510",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404510  endbr64 \n  0x404514  push    0x4e {var_8}\n  0x404519  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x4e\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x4e;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.35,
          "rationale": "The function only sets a constant and tail-calls another empty stub (sub_404020), indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x4e"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404510 initializes a local variable with the constant 0x4e and then tail-calls sub_404020, which appears to be a stub that does nothing and returns.",
          "details": [
            "The function sets var_8 = 0x4e but does not use it before transferring control.",
            "It performs a tail call to sub_404020, which only sets var_8 = 0 and jumps to a null pointer, indicating no functional work."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and why it is set to 0x4e.",
            "The actual behavior of sub_404020 beyond the placeholder jump."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404520",
      "original_name": "sub_404520",
      "final_name": "ai_no_op_stub",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404520  endbr64 \n  0x404524  push    0x4f {var_8}\n  0x404529  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x4f\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x4f;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_no_op_stub",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and tail-calls another empty function, indicating a placeholder or no-op behavior.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x4f"
          ],
          "tags": [],
          "alt_names": [
            "ai_placeholder",
            "ai_stub_function"
          ]
        },
        "explain": {
          "summary": "sub_404520 is a thin wrapper that sets a local variable to 0x4F and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function defines a local int64_t variable var_8 and assigns it the constant 0x4F, but the variable is never used.",
            "It performs a tail call to sub_404020 (call:0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x4f"
          ],
          "unknowns": [
            "The actual effect of sub_404020, which appears to jump to a nullptr or perform no operation.",
            "The purpose of the unused local variable var_8."
          ],
          "confidence": 0.92
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404530",
      "original_name": "sub_404530",
      "final_name": "ai_tailcall_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404530  endbr64 \n  0x404534  push    0x50 {var_8}\n  0x404539  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x50\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x50;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_tailcall_wrapper",
          "confidence": 0.32,
          "rationale": "The function does nothing but set a local variable and tail-call another function (sub_404020), indicating a simple wrapper or stub behavior.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [
            "misc"
          ],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_noop_caller"
          ]
        },
        "explain": {
          "summary": "sub_404530 is a thin wrapper that sets a local variable to 0x50 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function defines a local variable var_8 = 0x50 but does not use it before the tail call.",
            "It performs a tail call to sub_404020 and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior and side effects of sub_404020, since its implementation is not provided."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "misc"
      ]
    },
    {
      "addr": "0x404540",
      "original_name": "sub_404540",
      "final_name": "ai_wrapper_call_sub_404020",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404540  endbr64 \n  0x404544  push    0x51 {var_8}\n  0x404549  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x51\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x51;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_call_sub_404020",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and then tail-calls another function (sub_404020), acting as a simple wrapper or forwarder.",
          "evidence_refs": [
            "constants:0x51",
            "call:0x404020"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_forwarder"
          ]
        },
        "explain": {
          "summary": "sub_404540 initializes a local variable with the constant 0x51 and then immediately tail-calls sub_404020, effectively delegating its functionality. The called function appears to set a local variable to zero and then returns without further action, suggesting sub_404540 serves as a thin wrapper or placeholder.",
          "details": [
            "Sets a local 64-bit variable to the value 0x51, but the variable is not used elsewhere.",
            "Performs a tail call to sub_404020, passing control without additional processing.",
            "sub_404020 initializes its own local variable to zero and returns, indicating minimal or no side effects."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The intended purpose of the local variable var_8 in both functions.",
            "Whether sub_404020 performs hidden side effects not visible in the provided snippet."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404550",
      "original_name": "sub_404550",
      "final_name": "ai_placeholder_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404550  endbr64 \n  0x404554  push    0x52 {var_8}\n  0x404559  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x52\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x52;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_placeholder_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant (0x52) and immediately tail-calls another empty stub (sub_404020), indicating a no-op or placeholder wrapper without side effects.",
          "evidence_refs": [
            "constants:0x52",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "anti_debug",
            "packer"
          ],
          "alt_names": [
            "ai_no_op_wrapper",
            "ai_stub_initializer"
          ]
        },
        "explain": {
          "summary": "sub_404550 is a thin wrapper that initializes a local variable to 0x52 and then tailcalls sub_404020, effectively delegating its behavior to that function.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x52, which is never used elsewhere.",
            "It performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "constants:0x52",
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and the actual effect of sub_404020 (it jumps to nullptr)."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "anti_debug",
        "packer"
      ]
    },
    {
      "addr": "0x404560",
      "original_name": "sub_404560",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404560  endbr64 \n  0x404564  push    0x53 {var_8}\n  0x404569  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x53\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x53;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a local variable and tail-calls another function that appears to be a no-op, indicating a stub or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_stub"
          ]
        },
        "explain": {
          "summary": "sub_404560 initializes a local variable with the constant 0x53 and then tail-calls sub_404020, returning its result without further processing.",
          "details": [
            "A local variable var_8 is set to 0x53 but never used, indicating a placeholder or alignment.",
            "The function performs a tail call to sub_404020, effectively delegating its behavior."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x53"
          ],
          "unknowns": [
            "The actual functionality of sub_404020 and the purpose of the unused var_8 variable."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404570",
      "original_name": "sub_404570",
      "final_name": "ai_initialize",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404570  endbr64 \n  0x404574  push    0x54 {var_8}\n  0x404579  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x54\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x54;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_initialize",
          "confidence": 0.62,
          "rationale": "Function is a thin wrapper that sets a constant and tail-calls sub_404020, which appears to be an initialization stub; likely part of program setup or config initialization.",
          "evidence_refs": [
            "constants:0x404020",
            "call:0x404020"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_init_wrapper",
            "ai_setup"
          ]
        },
        "explain": {
          "summary": "sub_404570 is a thin wrapper that sets a local variable to 0x54 and then tail-calls sub_404020, returning its result without further processing.",
          "details": [
            "A local variable var_8 is initialized to the constant 0x54 but never used.",
            "The function performs a tail call to sub_404020 and returns its value directly."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "Purpose of the var_8 assignment",
            "Actual behavior of sub_404020 beyond the placeholder jump"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404580",
      "original_name": "sub_404580",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404580  endbr64 \n  0x404584  push    0x55 {var_8}\n  0x404589  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x55\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x55;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a constant (0x55) and tail-calls sub_404020, acting as a simple wrapper or stub with no visible side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_stub_forwarder",
            "ai_wrapper_sub_404020"
          ]
        },
        "explain": {
          "summary": "sub_404580 is a thin wrapper that initializes a local variable to 0x55 and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x55, which appears unused before the tail call.",
            "It performs a tail call to sub_404020, effectively delegating its behavior to that function."
          ],
          "evidence_refs": [
            "constants:0x55",
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020, which appears to jump to a nullptr or be a stub.",
            "The purpose of the local variable var_8."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404590",
      "original_name": "sub_404590",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404590  endbr64 \n  0x404594  push    0x56 {var_8}\n  0x404599  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x56\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x56;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local constant and tail-calls another empty stub, indicating it acts as a placeholder or simple wrapper with no observable side effects.",
          "evidence_refs": [
            "constants:0x56",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404590 initializes a local variable with the constant 0x56 and then immediately tail-calls sub_404020, returning its result.",
          "details": [
            "A local variable var_8 is set to 0x56 but never used before the tail call.",
            "The function performs a tail call to sub_404020, effectively delegating its behavior."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual functionality and return value of sub_404020",
            "Purpose of the unused var_8 assignment"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4045a0",
      "original_name": "sub_4045a0",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4045a0  endbr64 \n  0x4045a4  push    0x57 {var_8}\n  0x4045a9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x57\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x57;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a constant and tail-calls another empty stub, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_stub",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4045a0 is a thin wrapper that initializes a local variable to 0x57 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x57, but this value is never used before the tail call.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the unused var_8 assignment.",
            "The actual behavior of sub_404020, which appears to jump to a nullptr placeholder."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4045b0",
      "original_name": "sub_4045b0",
      "final_name": "ai_stub_forward",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4045b0  endbr64 \n  0x4045b4  push    0x58 {var_8}\n  0x4045b9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x58\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x58;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_forward",
          "confidence": 0.32,
          "rationale": "The function does nothing but set a local variable and tail-call sub_404020, acting as a simple wrapper or stub without visible side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_wrapper",
            "ai_noop"
          ]
        },
        "explain": {
          "summary": "sub_4045b0 is a thin wrapper that sets a local variable and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "A stack variable var_8 is initialized to 0x58 but never used before the call.",
            "The function performs a tail call to sub_404020 (address 0x404020) and returns its result."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x404020"
          ],
          "unknowns": [
            "The actual functionality of sub_404020, which appears to jump to a nullptr or be a stub.",
            "The purpose of the var_8 assignment."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4045c0",
      "original_name": "sub_4045c0",
      "final_name": "ai_stub_function",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4045c0  endbr64 \n  0x4045c4  push    0x59 {var_8}\n  0x4045c9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x59\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x59;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_function",
          "confidence": 0.62,
          "rationale": "The function only sets a local variable and tail-calls another empty stub, indicating a no-op or placeholder behavior.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4045c0 is a thin wrapper that sets a local variable to 0x59 and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x59, but this value is never used before the tail call.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "The purpose of the var_8 assignment (0x59) and whether it influences sub_404020 via side effects.",
            "The actual behavior of sub_404020, which appears to jump to a null pointer or be a stub."
          ],
          "confidence": 0.85
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4045d0",
      "original_name": "sub_4045d0",
      "final_name": "ai_placeholder",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4045d0  endbr64 \n  0x4045d4  push    0x5a {var_8}\n  0x4045d9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x5a\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x5a;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_placeholder",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and tail-calls another empty stub, indicating a no-op or placeholder behavior.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5a"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_stub"
          ]
        },
        "explain": {
          "summary": "sub_4045d0 initializes a local variable to the constant 0x5a and then tail-calls sub_404020, which appears to be a minimal stub that sets its own local variable to zero and jumps to a null target, performing no meaningful work.",
          "details": [
            "A local variable var_8 is set to 0x5a in sub_4045d0.",
            "The function immediately tail-calls sub_404020 without further processing.",
            "sub_404020 sets its own var_8 to 0 and then jumps to a nullptr, effectively acting as a no-op.",
            "No external imports, strings, or complex logic are present."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5a"
          ],
          "unknowns": [
            "The intended purpose of the var_8 assignments.",
            "Why the jump to nullptr is used in sub_404020."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4045e0",
      "original_name": "sub_4045e0",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4045e0  endbr64 \n  0x4045e4  push    0x5b {var_8}\n  0x4045e9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x5b\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x5b;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a constant and tail-calls another empty function, indicating a stub or placeholder wrapper with no observable behavior.",
          "evidence_refs": [
            "constants:0x5b",
            "call:0x404020"
          ],
          "tags": [
            "anti_debug",
            "packer"
          ],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4045e0 is a thin wrapper that sets a local variable to 0x5b and then tail-calls sub_404020, effectively delegating its functionality.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x5b, which appears unused.",
            "It then performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5b"
          ],
          "unknowns": [
            "The actual effect of sub_404020 since its body is unclear (jump to nullptr).",
            "Whether the var_8 assignment influences any external state."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "anti_debug",
        "packer"
      ]
    },
    {
      "addr": "0x4045f0",
      "original_name": "sub_4045f0",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4045f0  endbr64 \n  0x4045f4  push    0x5c {var_8}\n  0x4045f9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x5c\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x5c;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.62,
          "rationale": "The function only sets a local variable and tail-calls another empty stub, indicating it performs no real work and acts as a simple wrapper/no-op.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5c"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_stub",
            "ai_wrapper"
          ]
        },
        "explain": {
          "summary": "sub_4045f0 is a thin wrapper that sets a local variable to 0x5c and then tail-calls sub_404020, effectively delegating its functionality to that function.",
          "details": [
            "The function initializes a local variable var_8 with the constant 0x5c, which is not used elsewhere.",
            "It performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5c"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, which appears to jump to a nullptr or perform no operation."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404600",
      "original_name": "sub_404600",
      "final_name": "ai_wrapper_call_404020",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404600  endbr64 \n  0x404604  push    0x5d {var_8}\n  0x404609  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x5d\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x5d;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wrapper_call_404020",
          "confidence": 0.32,
          "rationale": "The function only sets a constant and then tail-calls sub_404020, acting as a simple wrapper or dispatcher without visible side effects.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5d"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_404600",
            "ai_forward_to_404020"
          ]
        },
        "explain": {
          "summary": "sub_404600 is a thin wrapper that sets a local variable to 0x5d and then tail-calls sub_404020, returning its result.",
          "details": [
            "The function initializes a stack variable var_8 with the constant 0x5d, which appears unused.",
            "It performs a tail call to sub_404020 and returns whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5d"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, which appears to jump to a nullptr or perform no operation."
          ],
          "confidence": 0.82
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404610",
      "original_name": "sub_404610",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404610  endbr64 \n  0x404614  push    0x5e {var_8}\n  0x404619  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x5e\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x5e;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local variable and tail-calls another function (sub_404020) without any visible side effects, indicating a simple wrapper or stub.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404610 is a thin wrapper that initializes a local variable to 0x5e and then tailcalls sub_404020, effectively delegating its behavior to that function.",
          "details": [
            "The function sets a local 64bit variable to the constant 0x5e, which is not used elsewhere.",
            "It performs a tail call to sub_404020, passing control without further processing."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5e"
          ],
          "unknowns": [
            "The actual effect or return value of sub_404020, which appears to be a stub or placeholder.",
            "Whether the local variable influences any later code via sideeffects."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404620",
      "original_name": "sub_404620",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404620  endbr64 \n  0x404624  push    0x5f {var_8}\n  0x404629  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x5f\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x5f;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.62,
          "rationale": "The function only sets a constant and tail-calls another empty stub, indicating a placeholder or no-op wrapper.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x5f"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404620 initializes a local variable with the constant 0x5f and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function defines a 64bit local variable var_8 and assigns it the value 0x5f, but the variable is never used.",
            "It performs a tail call to sub_404020, effectively delegating all further execution to that routine."
          ],
          "evidence_refs": [
            "constants:0x5f",
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior and return value of sub_404020, since its implementation appears to be a stub or jump to nullptr.",
            "Any side effects that might be caused by sub_404020."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404630",
      "original_name": "sub_404630",
      "final_name": "ai_call_initializer",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404630  endbr64 \n  0x404634  push    0x60 {var_8}\n  0x404639  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x60\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x60;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_call_initializer",
          "confidence": 0.32,
          "rationale": "The function simply sets a constant (0x60) and tail-calls sub_404020, acting as a thin wrapper likely used for initialization or delegating to a core routine.",
          "evidence_refs": [
            "constants:0x60",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "init",
            "process"
          ],
          "alt_names": [
            "ai_wrapper_sub_404020",
            "ai_delegate_initializer"
          ]
        },
        "explain": {
          "summary": "sub_404630 is a thin wrapper that initializes a local variable to 0x60 and then tailcalls sub_404020, effectively delegating its functionality to that routine.",
          "details": [
            "The function sets var_8 = 0x60 but never uses it before the tail call.",
            "It performs a tail call to sub_404020, passing control without further processing."
          ],
          "evidence_refs": [
            "constants:0x404020",
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, which appears to jump to a nullptr or be a stub.",
            "The purpose of the local variable var_8 in both functions."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "init",
        "process"
      ]
    },
    {
      "addr": "0x404640",
      "original_name": "sub_404640",
      "final_name": "ai_set_constant_and_delegate",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404640  endbr64 \n  0x404644  push    0x61 {var_8}\n  0x404649  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x61\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x61;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_constant_and_delegate",
          "confidence": 0.32,
          "rationale": "The function stores the constant 0x61 (ASCII 'a') in a local variable then tailcalls sub_404020, acting as a simple wrapper/initializer with a fixed value.",
          "evidence_refs": [
            "constants:0x61",
            "call:0x404020"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_set_a_and_call",
            "ai_wrapper_init"
          ]
        },
        "explain": {
          "summary": "The function sub_404640 initializes a local variable with the constant 0x61 and then immediately tail-calls sub_404020, effectively delegating its behavior to that routine.",
          "details": [
            "A local 64-bit variable var_8 is set to 0x61 but never used before the tail call.",
            "The function performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the constant 0x61 and any side effects of sub_404020, which appears to be a stub with no visible operations."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404650",
      "original_name": "sub_404650",
      "final_name": "ai_stub_return",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404650  endbr64 \n  0x404654  push    0x62 {var_8}\n  0x404659  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x62\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x62;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_return",
          "confidence": 0.35,
          "rationale": "Function only sets a local constant and tail-calls another empty function, acting as a placeholder or stub with no side effects.",
          "evidence_refs": [
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_dummy_function",
            "ai_noop"
          ]
        },
        "explain": {
          "summary": "sub_404650 is a thin wrapper that sets a local variable to 0x62 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "A local variable var_8 is initialized to the constant 0x62 but never used.",
            "The function performs a tail call to sub_404020 and returns its result directly."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual behavior and side effects of sub_404020, which appears to jump to a nullptr placeholder.",
            "The purpose of the var_8 assignment, as it does not affect the control flow."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404660",
      "original_name": "sub_404660",
      "final_name": "ai_dummy_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404660  endbr64 \n  0x404664  push    0x63 {var_8}\n  0x404669  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x63\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x63;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a local constant (0x63) and then tail-calls another internal function without any external imports or strings, indicating a simple wrapper or placeholder behavior.",
          "evidence_refs": [
            "constants:0x63",
            "call:0x404020"
          ],
          "tags": [
            "packer",
            "anti_debug"
          ],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_noop_call"
          ]
        },
        "explain": {
          "summary": "sub_404660 initializes a local variable with the constant 0x63 and then immediately tailcalls sub_404020, returning its result without further processing.",
          "details": [
            "The function defines a 64bit local variable var_8 and assigns it the value 0x63.",
            "It performs a tail call to sub_404020, effectively delegating any further logic to that routine."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x63"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 (it is never used before the tail call).",
            "The actual behavior of sub_404020, which appears to jump to a nullptr placeholder."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "packer",
        "anti_debug"
      ]
    },
    {
      "addr": "0x404670",
      "original_name": "sub_404670",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404670  endbr64 \n  0x404674  push    0x64 {var_8}\n  0x404679  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x64\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x64;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function simply sets a constant (0x64) and tail-calls another function without any imports or strings, indicating a thin wrapper or placeholder stub.",
          "evidence_refs": [
            "constants:0x64",
            "call:0x404020"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_dummy_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404670 is a thin wrapper that sets a local variable to 0x64 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function initializes a local variable var_8 with the constant 0x64 but does not use it.",
            "It performs a tail call to sub_404020 (address 0x404020) and returns its result."
          ],
          "evidence_refs": [
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020, which appears to jump to a nullptr or perform no operation.",
            "The purpose of the local variable var_8 set to 0x64."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x404680",
      "original_name": "sub_404680",
      "final_name": "ai_stub_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404680  endbr64 \n  0x404684  push    0x65 {var_8}\n  0x404689  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x65\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x65;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stub_wrapper",
          "confidence": 0.32,
          "rationale": "The function only sets a constant value and immediately tail-calls another minimal function, indicating a stub or wrapper with no real logic.",
          "evidence_refs": [
            "call:0x404020",
            "constants:0x65"
          ],
          "tags": [],
          "alt_names": [
            "ai_dummy",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404680 initializes a local variable with the constant 0x65 and then tailcalls sub_404020, effectively acting as a thin wrapper that forwards execution to the next function.",
          "details": [
            "The function defines a local 64bit variable var_8 and assigns it the value 0x65, which is never used elsewhere.",
            "It performs a tail call to sub_404020, returning whatever that function returns."
          ],
          "evidence_refs": [
            "constants:0x65",
            "call:0x404020"
          ],
          "unknowns": [
            "The purpose of the local variable var_8 and whether its value influences any external state.",
            "The actual behavior of sub_404020 beyond the placeholder jump to nullptr."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404690",
      "original_name": "sub_404690",
      "final_name": "ai_dummy",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x404690  endbr64 \n  0x404694  push    0x66 {var_8}\n  0x404699  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x66\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x66;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dummy",
          "confidence": 0.62,
          "rationale": "Function only sets a constant and tail-calls another empty stub, indicating a placeholder or no-op behavior.",
          "evidence_refs": [
            "constants:0x66",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_404690 initializes a local variable with the constant 0x66 and then immediately tail-calls sub_404020, returning its result without further processing.",
          "details": [
            "A local variable var_8 is set to 0x66 but never used.",
            "The function performs a tail call to sub_404020 and returns its value."
          ],
          "evidence_refs": [
            "call:0x404020",
            "constants:0x66"
          ],
          "unknowns": [
            "The actual behavior of sub_404020, which appears to jump to a nullptr or perform no operation."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4046a0",
      "original_name": "sub_4046a0",
      "final_name": "ai_noop_wrapper",
      "score": 5.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404020",
          "name": "ai_config_lookup",
          "original_name": "sub_404020"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x404020"
      ],
      "snippets": {
        "asm": "  0x4046a0  endbr64 \n  0x4046a4  push    0x67 {var_8}\n  0x4046a9  jmp     sub_404020",
        "hlil": "int64_t var_8 = 0x67\nreturn sub_404020() __tailcall",
        "pseudoc": "{\n    int64_t var_8 = 0x67;\n    /* tailcall */\n    return sub_404020();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_noop_wrapper",
          "confidence": 0.32,
          "rationale": "Function only sets a constant and tail-calls another empty stub, indicating a no-op or placeholder wrapper.",
          "evidence_refs": [
            "constants:0x67",
            "call:0x404020"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_wrapper",
            "ai_placeholder"
          ]
        },
        "explain": {
          "summary": "sub_4046a0 is a thin wrapper that initializes a local variable to 0x67 and then tailcalls sub_404020, returning whatever that function returns.",
          "details": [
            "The function sets a stack variable var_8 to the constant 0x67, which is not used elsewhere.",
            "It performs a tailcall to sub_404020 (address 0x404020) and returns its result directly."
          ],
          "evidence_refs": [
            "constants:0x404020",
            "call:0x404020"
          ],
          "unknowns": [
            "The actual effect of sub_404020, which appears to set var_8 to 0 and jump to a nullptr placeholder.",
            "The purpose of the local variable var_8 in both functions."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4046b0",
      "original_name": "free",
      "final_name": "ai_free_memory",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 57,
      "callees": [
        {
          "addr": "0x422f90"
        }
      ],
      "import_refs": [
        "free"
      ],
      "string_refs": [],
      "constants": [
        "0x422f90"
      ],
      "snippets": {
        "asm": "  0x4046b0  endbr64 \n  0x4046b4  jmp     qword [rel free]",
        "hlil": "return free(ptr) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return free(ptr);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_free_memory",
          "confidence": 0.98,
          "rationale": "The function is a thin wrapper that directly calls the standard free() to deallocate heap memory.",
          "evidence_refs": [
            "imports:free",
            "call:0x4046b0"
          ],
          "tags": [],
          "alt_names": [
            "ai_deallocate",
            "ai_release_memory"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards its argument to the standard library free function and returns its result, performing no additional processing.",
          "details": [
            "It receives a pointer (ptr) and immediately tail-calls the imported free routine at address 0x422f90.",
            "The function is called by many other parts of the program (57 callers) and contains no other logic or string usage."
          ],
          "evidence_refs": [
            "imports:free",
            "call:0x422f90"
          ],
          "unknowns": [
            "The reason for providing a wrapper around free instead of calling free directly."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4046c0",
      "original_name": "strcmp",
      "final_name": "ai_strcmp_wrapper",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 38,
      "callees": [
        {
          "addr": "0x422fb8"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x422fb8"
      ],
      "snippets": {
        "asm": "  0x4046c0  endbr64 \n  0x4046c4  jmp     qword [rel strcmp]",
        "hlil": "return strcmp(arg1, arg2) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strcmp(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_strcmp_wrapper",
          "confidence": 0.96,
          "rationale": "The function directly forwards its arguments to the standard library strcmp, acting as a thin wrapper for string comparison.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_string_compare",
            "ai_strcmp"
          ]
        },
        "explain": {
          "summary": "The function at 0x4046c0 is a thin wrapper that directly forwards its two arguments to the standard library strcmp and returns the comparison result.",
          "details": [
            "It imports strcmp and performs a tailcall to it with arg1 and arg2.",
            "No additional logic, string literals, or side effects are present; it simply returns the integer result of strcmp."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x422fb8"
          ],
          "unknowns": [
            "Why the wrapper exists (e.g., for indirection or linking purposes)"
          ],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4046d0",
      "original_name": "malloc",
      "final_name": "ai_allocate_memory",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 29,
      "callees": [
        {
          "addr": "0x422fd8"
        }
      ],
      "import_refs": [
        "malloc"
      ],
      "string_refs": [],
      "constants": [
        "0x422fd8"
      ],
      "snippets": {
        "asm": "  0x4046d0  endbr64 \n  0x4046d4  jmp     qword [rel malloc]",
        "hlil": "return malloc(n) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return malloc(n);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_allocate_memory",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly forwards its argument to the standard malloc call, indicating its purpose is to allocate memory.",
          "evidence_refs": [
            "imports:malloc"
          ],
          "tags": [],
          "alt_names": [
            "ai_malloc_wrapper",
            "ai_mem_alloc"
          ]
        },
        "explain": {
          "summary": "The function at 0x4046d0 is a thin wrapper that directly forwards its size argument to the standard malloc routine and returns the allocated pointer. It performs no additional processing, acting as a simple alias for malloc.",
          "details": [
            "The function consists of a single tailcall: return malloc(n);",
            "It imports the malloc symbol and calls the address 0x422fd8, which corresponds to the actual malloc implementation."
          ],
          "evidence_refs": [
            "imports:malloc",
            "call:0x422fd8"
          ],
          "unknowns": [
            "The reason for providing this wrapper (e.g., abstraction, instrumentation) is not evident from the code."
          ],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4046e0",
      "original_name": "__cxa_finalize",
      "final_name": "ai_runtime_cleanup_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422ff0"
        }
      ],
      "import_refs": [
        "__cxa_finalize"
      ],
      "string_refs": [],
      "constants": [
        "0x422ff0"
      ],
      "snippets": {
        "asm": "  0x4046e0  endbr64 \n  0x4046e4  jmp     qword [rel __cxa_finalize]",
        "hlil": "return __cxa_finalize(d) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __cxa_finalize(d);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_runtime_cleanup_wrapper",
          "confidence": 0.96,
          "rationale": "The function simply forwards its argument to __cxa_finalize, acting as a wrapper for C++ runtime cleanup of global destructors.",
          "evidence_refs": [
            "imports:__cxa_finalize",
            "call:0x422ff0"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_cxa_finalize_wrapper",
            "ai_at_exit_cleanup"
          ]
        },
        "explain": {
          "summary": "The function at 0x4046e0 is a thin wrapper that directly forwards its argument to the imported __cxa_finalize routine and returns its result.",
          "details": [
            "It performs a tail call to __cxa_finalize with the parameter d, acting as a simple passthrough.",
            "No additional logic or side effects are present; it merely returns the outcome of __cxa_finalize."
          ],
          "evidence_refs": [
            "imports:__cxa_finalize",
            "call:0x422ff0"
          ],
          "unknowns": [
            "The exact source or meaning of the argument 'd' passed to __cxa_finalize",
            "Whether this wrapper is used in a specific cleanup context beyond the generic finalization"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x4046f0",
      "original_name": "__ctype_toupper_loc",
      "final_name": "ai_get_toupper_locale",
      "score": 13.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 5,
      "callees": [
        {
          "addr": "0x422c50"
        }
      ],
      "import_refs": [
        "__ctype_toupper_loc"
      ],
      "string_refs": [],
      "constants": [
        "0x422c50"
      ],
      "snippets": {
        "asm": "  0x4046f0  endbr64 \n  0x4046f4  jmp     qword [rel __ctype_toupper_loc]",
        "hlil": "return __ctype_toupper_loc() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __ctype_toupper_loc();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_toupper_locale",
          "confidence": 0.86,
          "rationale": "The function simply tail-calls __ctype_toupper_loc, returning a pointer to the locale-specific uppercase character mapping table.",
          "evidence_refs": [
            "imports:__ctype_toupper_loc"
          ],
          "tags": [],
          "alt_names": [
            "ai_ctype_toupper_loc",
            "ai_get_uppercase_table"
          ]
        },
        "explain": {
          "summary": "The function at 0x4046f0 is a thin wrapper that simply forwards the call to the imported __ctype_toupper_loc function and returns its result. It performs a tail call with no additional processing, effectively exposing the locale-specific toupper table pointer.",
          "details": [
            "Calls __ctype_toupper_loc via a tail call and returns its value.",
            "No other logic, strings, or data manipulation is performed."
          ],
          "evidence_refs": [
            "imports:__ctype_toupper_loc",
            "call:0x422c50",
            "strings:none"
          ],
          "unknowns": [],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404700",
      "original_name": "getenv",
      "final_name": "ai_getenv_wrapper",
      "score": 23.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 15,
      "callees": [
        {
          "addr": "0x422c58"
        }
      ],
      "import_refs": [
        "getenv"
      ],
      "string_refs": [],
      "constants": [
        "0x422c58"
      ],
      "snippets": {
        "asm": "  0x404700  endbr64 \n  0x404704  jmp     qword [rel getenv]",
        "hlil": "return getenv(name) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return getenv(name);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_getenv_wrapper",
          "confidence": 0.97,
          "rationale": "The function is a thin wrapper that directly calls the standard getenv API to retrieve an environment variable value.",
          "evidence_refs": [
            "imports:getenv"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_env_lookup",
            "ai_get_environment_variable"
          ]
        },
        "explain": {
          "summary": "The function at 0x404700 is a thin wrapper that forwards its argument to the standard library getenv and returns the result.",
          "details": [
            "It imports the getenv function from the C runtime.",
            "The implementation consists of a tail call to getenv(name) and returns its pointer."
          ],
          "evidence_refs": [
            "imports:getenv",
            "call:0x422c58"
          ],
          "unknowns": [],
          "confidence": 1.0
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404710",
      "original_name": "sigprocmask",
      "final_name": "ai_signal_mask_control",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422c60"
        }
      ],
      "import_refs": [
        "sigprocmask"
      ],
      "string_refs": [],
      "constants": [
        "0x422c60"
      ],
      "snippets": {
        "asm": "  0x404710  endbr64 \n  0x404714  jmp     qword [rel sigprocmask]",
        "hlil": "return sigprocmask(how, set, oset) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sigprocmask(how, set, oset);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_signal_mask_control",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly forwards arguments to the sigprocmask system call, indicating it manipulates the process signal mask.",
          "evidence_refs": [
            "imports:sigprocmask",
            "call:0x404710"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_sigprocmask_wrapper",
            "ai_set_signal_mask"
          ]
        },
        "explain": {
          "summary": "The function at 0x404710 is a thin wrapper that directly forwards its arguments to the imported sigprocmask system call and returns its result.",
          "details": [
            "The implementation consists of a single tailcall: return sigprocmask(how, set, oset);",
            "No additional logic, string handling, or side effects are present; it simply proxies the call."
          ],
          "evidence_refs": [
            "imports:sigprocmask",
            "call:0x404710"
          ],
          "unknowns": [
            "The reason for providing this wrapper (e.g., abstraction, instrumentation) is not evident from the code."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404720",
      "original_name": "__snprintf_chk",
      "final_name": "ai_safe_snprintf_wrapper",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422c68"
        }
      ],
      "import_refs": [
        "__snprintf_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422c68"
      ],
      "snippets": {
        "asm": "  0x404720  endbr64 \n  0x404724  jmp     qword [rel __snprintf_chk]",
        "hlil": "return __snprintf_chk(s, maxlen, flag, slen, format) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __snprintf_chk(s, maxlen, flag, slen, format);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_safe_snprintf_wrapper",
          "confidence": 0.85,
          "rationale": "The function is a thin wrapper that directly forwards arguments to __snprintf_chk, indicating its role is safe formatted string output.",
          "evidence_refs": [
            "imports:__snprintf_chk",
            "call:0x404720"
          ],
          "tags": [],
          "alt_names": [
            "ai_snprintf_wrapper",
            "ai_format_string"
          ]
        },
        "explain": {
          "summary": "The function at 0x404720 is a thin wrapper that directly forwards its arguments to the libc __snprintf_chk function and returns its result without any additional processing.",
          "details": [
            "It imports __snprintf_chk and performs a tail call to it with the same parameters (s, maxlen, flag, slen, format).",
            "No other logic, string handling, or side effects are present; it serves as a simple passthrough or compatibility shim."
          ],
          "evidence_refs": [
            "imports:__snprintf_chk",
            "call:0x422c68"
          ],
          "unknowns": [
            "The reason for providing this wrapper (e.g., ABI compatibility or instrumentation) is not evident from the code."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404730",
      "original_name": "raise",
      "final_name": "ai_raise_signal",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422c70"
        }
      ],
      "import_refs": [
        "raise"
      ],
      "string_refs": [],
      "constants": [
        "0x422c70"
      ],
      "snippets": {
        "asm": "  0x404730  endbr64 \n  0x404734  jmp     qword [rel raise]",
        "hlil": "return raise(sig) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return raise(sig);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_raise_signal",
          "confidence": 0.93,
          "rationale": "The function is a thin wrapper that directly calls the imported raise() to deliver a signal, indicating its purpose is to raise a signal.",
          "evidence_refs": [
            "imports:raise",
            "call:0x40bf40"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_signal_raise",
            "ai_raise_sig"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards its argument to the raise() system call, causing the current process to deliver the specified signal.",
          "details": [
            "It receives a signal number (sig) and immediately tail-calls the imported raise function with that argument.",
            "The function returns the result of raise, which is typically 0 on success or -1 on error."
          ],
          "evidence_refs": [
            "imports:raise",
            "call:0x422c70"
          ],
          "unknowns": [
            "The exact calling convention or any additional side effects beyond raising the signal are not shown."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404740",
      "original_name": "__mempcpy_chk",
      "final_name": "ai_safe_memcpy",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422c78"
        }
      ],
      "import_refs": [
        "__mempcpy_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422c78"
      ],
      "snippets": {
        "asm": "  0x404740  endbr64 \n  0x404744  jmp     qword [rel __mempcpy_chk]",
        "hlil": "return __mempcpy_chk(arg1, arg2, arg3, arg4) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __mempcpy_chk(arg1, arg2, arg3, arg4);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_safe_memcpy",
          "confidence": 0.86,
          "rationale": "The function is a thin wrapper that directly tail-calls the imported __mempcpy_chk, indicating its role is to perform a bounds-checked memory copy.",
          "evidence_refs": [
            "imports:__mempcpy_chk"
          ],
          "tags": [],
          "alt_names": [
            "ai_memcpy_chk_wrapper",
            "ai_memcpy_checked"
          ]
        },
        "explain": {
          "summary": "The function at 0x404740 is a thin wrapper that directly forwards its arguments to the imported __mempcpy_chk routine, returning its result without additional processing.",
          "details": [
            "It performs a tail call to __mempcpy_chk with the same four arguments it receives.",
            "No other logic, checks, or side effects are present in this wrapper."
          ],
          "evidence_refs": [
            "imports:__mempcpy_chk",
            "call:0x422c78"
          ],
          "unknowns": [
            "Exact purpose of the wrapper within the larger program context"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404750",
      "original_name": "abort",
      "final_name": "ai_fatal_abort",
      "score": 19.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 11,
      "callees": [
        {
          "addr": "0x422c80"
        }
      ],
      "import_refs": [
        "abort"
      ],
      "string_refs": [],
      "constants": [
        "0x422c80"
      ],
      "snippets": {
        "asm": "  0x404750  endbr64 \n  0x404754  jmp     qword [rel abort]\n  0x404754  { Does not return }",
        "hlil": "noreturn abort() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return abort();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_fatal_abort",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the abort import, indicating a fatal termination behavior used for error handling.",
          "evidence_refs": [
            "imports:abort",
            "call:0x404750"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_terminate_program",
            "ai_fatal_error"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that immediately invokes the abort routine to terminate the process.",
          "details": [
            "It performs a tail-call to the imported abort function and returns its result (which never returns).",
            "No additional logic, strings, or data processing is present; it serves solely as an error/termination entry point."
          ],
          "evidence_refs": [
            "imports:abort",
            "call:0x422c80"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404760",
      "original_name": "__errno_location",
      "final_name": "ai_get_errno_location",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 57,
      "callees": [
        {
          "addr": "0x422c88"
        }
      ],
      "import_refs": [
        "__errno_location"
      ],
      "string_refs": [],
      "constants": [
        "0x422c88"
      ],
      "snippets": {
        "asm": "  0x404760  endbr64 \n  0x404764  jmp     qword [rel __errno_location]",
        "hlil": "return __errno_location() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __errno_location();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_errno_location",
          "confidence": 0.96,
          "rationale": "The function simply returns the result of the imported __errno_location, acting as a wrapper to retrieve the thread-local errno pointer.",
          "evidence_refs": [
            "imports:__errno_location",
            "call:0x422c88"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_errno_ptr",
            "ai_errno_location_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that simply forwards to the imported __errno_location, returning a pointer to the thread-local errno variable.",
          "details": [
            "It contains no additional logic beyond a tail call to __errno_location.",
            "Used by other functions to reset or access errno before performing operations like string comparison."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "call:0x422c88"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404770",
      "original_name": "strncmp",
      "final_name": "ai_strncmp_wrapper",
      "score": 16.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 8,
      "callees": [
        {
          "addr": "0x422c90"
        }
      ],
      "import_refs": [
        "strncmp"
      ],
      "string_refs": [],
      "constants": [
        "0x422c90"
      ],
      "snippets": {
        "asm": "  0x404770  endbr64 \n  0x404774  jmp     qword [rel strncmp]",
        "hlil": "return strncmp(arg1, arg2, arg3) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strncmp(arg1, arg2, arg3);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_strncmp_wrapper",
          "confidence": 0.96,
          "rationale": "The function directly tail-calls the standard library strncmp, acting as a simple wrapper for string comparison used in path prefix checks.",
          "evidence_refs": [
            "imports:strncmp"
          ],
          "tags": [],
          "alt_names": [
            "ai_string_compare",
            "ai_strncmp_proxy"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its three arguments to the imported strncmp function and returns its result.",
          "details": [
            "Accepts three parameters (two strings and a length) and performs a tail call to the standard library strncmp.",
            "No additional processing or logic is performed before or after the call."
          ],
          "evidence_refs": [
            "imports:strncmp",
            "call:0x422c90"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404780",
      "original_name": "localtime_r",
      "final_name": "ai_localtime_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422c98"
        }
      ],
      "import_refs": [
        "localtime_r"
      ],
      "string_refs": [],
      "constants": [
        "0x422c98"
      ],
      "snippets": {
        "asm": "  0x404780  endbr64 \n  0x404784  jmp     qword [rel localtime_r]",
        "hlil": "return localtime_r(t, tp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return localtime_r(t, tp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_localtime_wrapper",
          "confidence": 0.96,
          "rationale": "The function simply forwards its arguments to the standard library call localtime_r, acting as a thin wrapper for converting a timestamp to a local time struct.",
          "evidence_refs": [
            "imports:localtime_r",
            "call:0x404780"
          ],
          "tags": [],
          "alt_names": [
            "ai_time_conversion",
            "ai_localtime_r_proxy"
          ]
        },
        "explain": {
          "summary": "The function at 0x404780 is a thin wrapper that directly forwards its arguments to the standard library function localtime_r and returns its result.",
          "details": [
            "It imports the localtime_r symbol and performs a tail call to it with the provided parameters (t, tp).",
            "No additional logic, string handling, or data manipulation is performed within this wrapper."
          ],
          "evidence_refs": [
            "imports:localtime_r",
            "call:0x404780"
          ],
          "unknowns": [
            "The reason for providing this wrapper (e.g., abstraction, compatibility) is not evident from the code."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404790",
      "original_name": "_exit",
      "final_name": "ai_process_exit",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422ca0"
        }
      ],
      "import_refs": [
        "_exit"
      ],
      "string_refs": [],
      "constants": [
        "0x422ca0"
      ],
      "snippets": {
        "asm": "  0x404790  endbr64 \n  0x404794  jmp     qword [rel _exit]\n  0x404794  { Does not return }",
        "hlil": "noreturn _exit(status) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return _exit(status);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_process_exit",
          "confidence": 0.98,
          "rationale": "The function is a thin wrapper that directly calls the imported _exit function to terminate the process with a status code.",
          "evidence_refs": [
            "imports:_exit",
            "call:0x422ca0"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_terminate_process",
            "ai_exit_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly invokes the system _exit call with the provided status, causing immediate process termination.",
          "details": [
            "It imports the _exit function and performs a tail call to it, returning its result (which never returns).",
            "No additional logic, strings, or side effects are present; it simply forwards the status argument to _exit."
          ],
          "evidence_refs": [
            "imports:_exit",
            "call:0x404790"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x4047a0",
      "original_name": "__mbstowcs_chk",
      "final_name": "ai_mbstowcs_convert_chk",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422ca8"
        }
      ],
      "import_refs": [
        "__mbstowcs_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422ca8"
      ],
      "snippets": {
        "asm": "  0x4047a0  endbr64 \n  0x4047a4  jmp     qword [rel __mbstowcs_chk]",
        "hlil": "return __mbstowcs_chk(dst, src, len, dstlen) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __mbstowcs_chk(dst, src, len, dstlen);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_mbstowcs_convert_chk",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that tail-calls __mbstowcs_chk, which performs a bounded conversion from multibyte to wide-character strings.",
          "evidence_refs": [
            "imports:__mbstowcs_chk"
          ],
          "tags": [],
          "alt_names": [
            "ai_mbstowcs_wrapper",
            "ai_string_conversion_chk"
          ]
        },
        "explain": {
          "summary": "The function __mbstowcs_chk at 0x4047a0 is a thin wrapper that directly forwards its arguments to the library routine __mbstowcs_chk, returning its result.",
          "details": [
            "It receives parameters (dst, src, len, dstlen) and performs a tail call to the imported __mbstowcs_chk function.",
            "No additional logic or processing is performed; it simply returns the conversion result."
          ],
          "evidence_refs": [
            "imports:__mbstowcs_chk",
            "call:0x422ca8"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4047b0",
      "original_name": "__fpending",
      "final_name": "ai_check_file_pending",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422cb0"
        }
      ],
      "import_refs": [
        "__fpending"
      ],
      "string_refs": [],
      "constants": [
        "0x422cb0"
      ],
      "snippets": {
        "asm": "  0x4047b0  endbr64 \n  0x4047b4  jmp     qword [rel __fpending]",
        "hlil": "return __fpending(fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __fpending(fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_check_file_pending",
          "confidence": 0.85,
          "rationale": "The function is a thin wrapper that directly returns the result of the __fpending call, indicating it checks the number of pending bytes in a FILE stream.",
          "evidence_refs": [
            "imports:__fpending"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_get_pending_input",
            "ai_fpending_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its argument to the imported __fpending routine and returns the result unchanged.",
          "details": [
            "Implements a tail call to __fpending(fp), acting as a passthrough.",
            "No additional processing, error handling, or side effects are performed."
          ],
          "evidence_refs": [
            "imports:__fpending",
            "call:0x422cb0"
          ],
          "unknowns": [
            "Exact behavior of __fpending in the target runtime (e.g., pending input count semantics)."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x4047c0",
      "original_name": "isatty",
      "final_name": "ai_check_isatty",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422cb8"
        }
      ],
      "import_refs": [
        "isatty"
      ],
      "string_refs": [],
      "constants": [
        "0x422cb8"
      ],
      "snippets": {
        "asm": "  0x4047c0  endbr64 \n  0x4047c4  jmp     qword [rel isatty]",
        "hlil": "return isatty(fd) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return isatty(fd);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_check_isatty",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the standard library isatty() to determine if a file descriptor refers to a terminal, often used for environment checks.",
          "evidence_refs": [
            "imports:isatty",
            "call:0x422cb8"
          ],
          "tags": [
            "anti_debug",
            "process"
          ],
          "alt_names": [
            "ai_isatty_wrapper",
            "ai_terminal_check"
          ]
        },
        "explain": {
          "summary": "The function at 0x4047c0 is a thin wrapper that directly forwards its file descriptor argument to the imported isatty function and returns the result.",
          "details": [
            "It performs a tail call to the system isatty function with the provided fd.",
            "No additional processing or logic is applied; the return value of isatty is passed back unchanged."
          ],
          "evidence_refs": [
            "imports:isatty",
            "call:0x422cb8"
          ],
          "unknowns": [
            "The broader context or reason for wrapping isatty is not determined."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "anti_debug",
        "process"
      ]
    },
    {
      "addr": "0x4047d0",
      "original_name": "sigaction",
      "final_name": "ai_set_signal_handler",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422cc0"
        }
      ],
      "import_refs": [
        "sigaction"
      ],
      "string_refs": [],
      "constants": [
        "0x422cc0"
      ],
      "snippets": {
        "asm": "  0x4047d0  endbr64 \n  0x4047d4  jmp     qword [rel sigaction]",
        "hlil": "return sigaction(sig, act, oact) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sigaction(sig, act, oact);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_signal_handler",
          "confidence": 0.95,
          "rationale": "The function is a thin wrapper that directly forwards its arguments to the imported sigaction call, indicating it sets or modifies a signal handler.",
          "evidence_refs": [
            "imports:sigaction"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_sigaction_wrapper",
            "ai_signal_handler_set"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its three arguments to the imported sigaction system call and returns its result.",
          "details": [
            "It receives a signal number, a pointer to a new sigaction struct, and a pointer for the old sigaction struct.",
            "The implementation performs a tail call to the imported sigaction function without any additional processing."
          ],
          "evidence_refs": [
            "imports:sigaction",
            "call:0x422cc0"
          ],
          "unknowns": [
            "Why the wrapper exists (e.g., abstraction or future extension)",
            "Any error handling or logging performed elsewhere"
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x4047e0",
      "original_name": "iswcntrl",
      "final_name": "ai_is_wide_control_char",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422cc8"
        }
      ],
      "import_refs": [
        "iswcntrl"
      ],
      "string_refs": [],
      "constants": [
        "0x422cc8"
      ],
      "snippets": {
        "asm": "  0x4047e0  endbr64 \n  0x4047e4  jmp     qword [rel iswcntrl]",
        "hlil": "return iswcntrl(wc) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return iswcntrl(wc);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_is_wide_control_char",
          "confidence": 0.93,
          "rationale": "The function is a thin wrapper that directly calls the standard library iswcntrl to test if a wide character is a control character.",
          "evidence_refs": [
            "imports:iswcntrl"
          ],
          "tags": [],
          "alt_names": [
            "ai_check_wchar_control",
            "ai_wchar_is_control"
          ]
        },
        "explain": {
          "summary": "The function at 0x4047e0 is a thin wrapper that directly forwards its argument to the standard library function iswcntrl and returns the result. It performs no additional processing, acting as a simple passthrough to determine if a wide character is a control character.",
          "details": [
            "The function consists of a single tail call: return iswcntrl(wc);",
            "It imports the iswcntrl symbol and calls it at address 0x422cc8."
          ],
          "evidence_refs": [
            "imports:iswcntrl",
            "call:0x422cc8"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4047f0",
      "original_name": "reallocarray",
      "final_name": "ai_reallocarray_wrapper",
      "score": 15.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 7,
      "callees": [
        {
          "addr": "0x422cd0"
        }
      ],
      "import_refs": [
        "reallocarray"
      ],
      "string_refs": [],
      "constants": [
        "0x422cd0"
      ],
      "snippets": {
        "asm": "  0x4047f0  endbr64 \n  0x4047f4  jmp     qword [rel reallocarray]",
        "hlil": "return reallocarray(optr, nmemb, elem_size) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return reallocarray(optr, nmemb, elem_size);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_reallocarray_wrapper",
          "confidence": 0.95,
          "rationale": "The function simply forwards its arguments to the system reallocarray call, acting as a thin wrapper for array memory allocation.",
          "evidence_refs": [
            "imports:reallocarray",
            "call:0x422cd0"
          ],
          "tags": [],
          "alt_names": [
            "ai_allocate_array",
            "ai_memory_realloc"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the system reallocarray function and returns its result, performing no additional processing.",
          "details": [
            "It receives parameters optr, nmemb, and elem_size and immediately tail-calls reallocarray with those same arguments.",
            "The wrapper exists likely for abstraction or compatibility, delegating all allocation logic to the imported reallocarray."
          ],
          "evidence_refs": [
            "imports:reallocarray",
            "call:0x422cd0"
          ],
          "unknowns": [
            "Why the wrapper is defined separately instead of calling reallocarray directly throughout the code."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404800",
      "original_name": "wcswidth",
      "final_name": "ai_wcswidth_wrapper",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422cd8"
        }
      ],
      "import_refs": [
        "wcswidth"
      ],
      "string_refs": [],
      "constants": [
        "0x422cd8"
      ],
      "snippets": {
        "asm": "  0x404800  endbr64 \n  0x404804  jmp     qword [rel wcswidth]",
        "hlil": "return wcswidth(s) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return wcswidth(s);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wcswidth_wrapper",
          "confidence": 0.97,
          "rationale": "The function simply forwards its argument to the imported wcswidth function, acting as a thin wrapper for computing the display width of a wide-character string.",
          "evidence_refs": [
            "imports:wcswidth",
            "call:0x422cd8"
          ],
          "tags": [],
          "alt_names": [
            "ai_compute_wcs_width",
            "ai_wcs_width_proxy"
          ]
        },
        "explain": {
          "summary": "The function at 0x404800 is a thin wrapper that directly forwards its argument to the imported wcswidth function and returns its result.",
          "details": [
            "It performs a tail call to the standard library wcswidth, passing the same parameter unchanged.",
            "No additional logic, string handling, or computation is performed within this wrapper."
          ],
          "evidence_refs": [
            "imports:wcswidth",
            "call:0x422cd8"
          ],
          "unknowns": [
            "The reason for providing this wrapper (e.g., API compatibility or indirection) is not evident from the code."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404810",
      "original_name": "localeconv",
      "final_name": "ai_localeconv_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422ce0"
        }
      ],
      "import_refs": [
        "localeconv"
      ],
      "string_refs": [],
      "constants": [
        "0x422ce0"
      ],
      "snippets": {
        "asm": "  0x404810  endbr64 \n  0x404814  jmp     qword [rel localeconv]",
        "hlil": "return localeconv() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return localeconv();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_localeconv_wrapper",
          "confidence": 0.92,
          "rationale": "The function simply tail-calls the standard C library function localeconv to retrieve locale-specific numeric formatting information, acting as a wrapper.",
          "evidence_refs": [
            "imports:localeconv"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_get_locale_info",
            "ai_locale_info_accessor"
          ]
        },
        "explain": {
          "summary": "The function at 0x404810 is a thin wrapper that directly calls the C library localeconv function and returns its result without any additional processing.",
          "details": [
            "It imports the localeconv symbol from the C runtime.",
            "The implementation consists solely of a tailcall to localeconv, returning the struct lconv pointer.",
            "No other logic, string handling, or data manipulation is performed."
          ],
          "evidence_refs": [
            "imports:localeconv",
            "call:0x422ce0"
          ],
          "unknowns": [
            "The reason for providing this wrapper instead of calling localeconv directly elsewhere."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404820",
      "original_name": "mbstowcs",
      "final_name": "ai_mbstowcs_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422ce8"
        }
      ],
      "import_refs": [
        "mbstowcs"
      ],
      "string_refs": [],
      "constants": [
        "0x422ce8"
      ],
      "snippets": {
        "asm": "  0x404820  endbr64 \n  0x404824  jmp     qword [rel mbstowcs]",
        "hlil": "return mbstowcs(pwcs, s, n) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return mbstowcs(pwcs, s, n);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_mbstowcs_wrapper",
          "confidence": 0.93,
          "rationale": "The function directly forwards its arguments to the standard library mbstowcs, acting as a thin wrapper for multibyte-to-wide character conversion.",
          "evidence_refs": [
            "imports:mbstowcs",
            "call:0x422ce8"
          ],
          "tags": [],
          "alt_names": [
            "ai_convert_multibyte_to_wide",
            "ai_string_conversion"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the standard library mbstowcs function, returning its result.",
          "details": [
            "It imports mbstowcs and performs a tail call to it with the same parameters (pwcs, s, n).",
            "No additional processing, checks, or transformations are performed before the call."
          ],
          "evidence_refs": [
            "imports:mbstowcs",
            "call:0x422ce8"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404830",
      "original_name": "readlink",
      "final_name": "ai_readlink_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422cf0"
        }
      ],
      "import_refs": [
        "readlink"
      ],
      "string_refs": [],
      "constants": [
        "0x422cf0"
      ],
      "snippets": {
        "asm": "  0x404830  endbr64 \n  0x404834  jmp     qword [rel readlink]",
        "hlil": "return readlink() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return readlink();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_readlink_wrapper",
          "confidence": 0.96,
          "rationale": "The function simply tail-calls the imported readlink API, indicating it resolves a symbolic link path.",
          "evidence_refs": [
            "imports:readlink"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_symlink_resolve",
            "ai_readlink_call"
          ]
        },
        "explain": {
          "summary": "The function at 0x404830 is a thin wrapper that directly tail-calls the imported readlink system call, returning its result unchanged.",
          "details": [
            "It imports the readlink function and performs a tail-call without any additional logic.",
            "No arguments are processed or modified within this wrapper; it simply forwards the call to readlink."
          ],
          "evidence_refs": [
            "imports:readlink",
            "call:0x422cf0"
          ],
          "unknowns": [
            "Exact argument handling and any caller-side context are not visible in this snippet."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404840",
      "original_name": "clock_gettime",
      "final_name": "ai_get_system_time",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422cf8"
        }
      ],
      "import_refs": [
        "clock_gettime"
      ],
      "string_refs": [],
      "constants": [
        "0x422cf8"
      ],
      "snippets": {
        "asm": "  0x404840  endbr64 \n  0x404844  jmp     qword [rel clock_gettime]",
        "hlil": "return clock_gettime(clock_id, tp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return clock_gettime(clock_id, tp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_system_time",
          "confidence": 0.88,
          "rationale": "The function is a thin wrapper that directly calls the imported clock_gettime API to retrieve the current time, indicating a timeretrieval behavior.",
          "evidence_refs": [
            "imports:clock_gettime"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_time_wrapper",
            "ai_clock_gettime_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the imported clock_gettime function and returns its result.",
          "details": [
            "Implements a tail call to the system's clock_gettime, passing through the clock_id and tp parameters unchanged.",
            "No additional processing or logic is performed beyond the call."
          ],
          "evidence_refs": [
            "imports:clock_gettime",
            "call:0x422cf8"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404850",
      "original_name": "setenv",
      "final_name": "ai_set_environment_variable",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422d00"
        }
      ],
      "import_refs": [
        "setenv"
      ],
      "string_refs": [],
      "constants": [
        "0x422d00"
      ],
      "snippets": {
        "asm": "  0x404850  endbr64 \n  0x404854  jmp     qword [rel setenv]",
        "hlil": "return setenv(name, value, replace) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return setenv(name, value, replace);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_environment_variable",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the setenv import to set an environment variable, indicating its purpose is to set environment variables.",
          "evidence_refs": [
            "imports:setenv",
            "call:0x422d00"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_set_env",
            "ai_set_env_var"
          ]
        },
        "explain": {
          "summary": "The function at 0x404850 is a thin wrapper that directly forwards its three arguments to the system setenv call and returns its result.",
          "details": [
            "It performs a tail call to the imported setenv function with parameters (name, value, replace).",
            "No additional logic or processing is performed; the return value of setenv is passed back to the caller."
          ],
          "evidence_refs": [
            "imports:setenv",
            "call:0x422d00"
          ],
          "unknowns": [
            "The source of the name, value, and replace arguments is not shown in this snippet."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404860",
      "original_name": "textdomain",
      "final_name": "ai_set_textdomain",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d08"
        }
      ],
      "import_refs": [
        "textdomain"
      ],
      "string_refs": [],
      "constants": [
        "0x422d08"
      ],
      "snippets": {
        "asm": "  0x404860  endbr64 \n  0x404864  jmp     qword [rel textdomain]",
        "hlil": "return textdomain(domainname) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return textdomain(domainname);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_textdomain",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the imported gettext `textdomain` function to set the program's message catalog domain.",
          "evidence_refs": [
            "imports:textdomain",
            "call:0x422d08"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_set_locale_domain",
            "ai_set_i18n_domain"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards its argument to the imported gettext textdomain function and returns its result.",
          "details": [
            "It receives a domain name pointer and immediately tail-calls the imported textdomain function with that argument.",
            "The function does not perform any additional processing, acting solely as a pass-through to set the current text domain for localization."
          ],
          "evidence_refs": [
            "imports:textdomain",
            "call:0x422d08"
          ],
          "unknowns": [
            "The origin or validation of the domain name argument before being passed."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404870",
      "original_name": "fclose",
      "final_name": "ai_close_file",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422d10"
        }
      ],
      "import_refs": [
        "fclose"
      ],
      "string_refs": [],
      "constants": [
        "0x422d10"
      ],
      "snippets": {
        "asm": "  0x404870  endbr64 \n  0x404874  jmp     qword [rel fclose]",
        "hlil": "return fclose(fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fclose(fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_close_file",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the C library fclose to close a FILE pointer, indicating file I/O cleanup behavior.",
          "evidence_refs": [
            "imports:fclose",
            "call:0x404870"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_fclose_wrapper",
            "ai_file_close"
          ]
        },
        "explain": {
          "summary": "This function is a thin wrapper that directly forwards its FILE pointer argument to the standard library fclose and returns the result.",
          "details": [
            "Performs a tailcall to the imported fclose function with the provided file pointer.",
            "No additional logic, checks, or side effects are present; it simply returns fclose's return value."
          ],
          "evidence_refs": [
            "imports:fclose",
            "call:0x422d10"
          ],
          "unknowns": [
            "Why this wrapper exists in the binary (e.g., for abstraction or compatibility)."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404880",
      "original_name": "opendir",
      "final_name": "ai_open_directory",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d18"
        }
      ],
      "import_refs": [
        "opendir"
      ],
      "string_refs": [],
      "constants": [
        "0x422d18"
      ],
      "snippets": {
        "asm": "  0x404880  endbr64 \n  0x404884  jmp     qword [rel opendir]",
        "hlil": "return opendir(name) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return opendir(name);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_open_directory",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the POSIX opendir() API to open a directory, indicating its primary behavior is opening directories.",
          "evidence_refs": [
            "imports:opendir",
            "call:0x404880"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_open_dir",
            "ai_dir_open"
          ]
        },
        "explain": {
          "summary": "The function at 0x404880 is a thin wrapper that directly forwards its argument to the standard library opendir call and returns the resulting DIR pointer.",
          "details": [
            "It performs a tail call to opendir(name) without any additional processing.",
            "The function imports opendir and has no internal strings or extra logic."
          ],
          "evidence_refs": [
            "imports:opendir",
            "call:0x422d18"
          ],
          "unknowns": [],
          "confidence": 1.0
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404890",
      "original_name": "getpwuid",
      "final_name": "ai_get_user_passwd_entry",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d20"
        }
      ],
      "import_refs": [
        "getpwuid"
      ],
      "string_refs": [],
      "constants": [
        "0x422d20"
      ],
      "snippets": {
        "asm": "  0x404890  endbr64 \n  0x404894  jmp     qword [rel getpwuid]",
        "hlil": "return getpwuid(uid) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return getpwuid(uid);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_user_passwd_entry",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the POSIX getpwuid() API to retrieve a passwd struct for a given UID, indicating user account lookup behavior.",
          "evidence_refs": [
            "imports:getpwuid",
            "call:0x404890"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_lookup_user",
            "ai_get_user_info"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards the provided UID to the system getpwuid call and returns its result unchanged.",
          "details": [
            "It imports the standard library function getpwuid.",
            "The implementation consists solely of a tail call: return getpwuid(uid);"
          ],
          "evidence_refs": [
            "imports:getpwuid",
            "call:0x422d20"
          ],
          "unknowns": [
            "Why this wrapper exists in the binary (e.g., for abstraction or future extension)."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x4048a0",
      "original_name": "bindtextdomain",
      "final_name": "ai_bind_textdomain_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d28"
        }
      ],
      "import_refs": [
        "bindtextdomain"
      ],
      "string_refs": [],
      "constants": [
        "0x422d28"
      ],
      "snippets": {
        "asm": "  0x4048a0  endbr64 \n  0x4048a4  jmp     qword [rel bindtextdomain]",
        "hlil": "return bindtextdomain(domainname, dirname) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return bindtextdomain(domainname, dirname);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_bind_textdomain_wrapper",
          "confidence": 0.96,
          "rationale": "Function is a thin wrapper that directly calls the bindtextdomain library function to set the gettext domain for localization.",
          "evidence_refs": [
            "imports:bindtextdomain",
            "call:0x4048a0"
          ],
          "tags": [],
          "alt_names": [
            "ai_set_translation_domain",
            "ai_localization_bind"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its two parameters to the imported bindtextdomain function and returns its result.",
          "details": [
            "Implements a tail-call to the system bindtextdomain with the provided domainname and dirname arguments.",
            "No additional processing or logic is performed; it simply returns the result of bindtextdomain."
          ],
          "evidence_refs": [
            "imports:bindtextdomain",
            "call:0x422d28"
          ],
          "unknowns": [],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4048b0",
      "original_name": "listxattr",
      "final_name": "ai_list_extended_attributes",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422d30"
        }
      ],
      "import_refs": [
        "listxattr"
      ],
      "string_refs": [],
      "constants": [
        "0x422d30"
      ],
      "snippets": {
        "asm": "  0x4048b0  endbr64 \n  0x4048b4  jmp     qword [rel listxattr]",
        "hlil": "return listxattr() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return listxattr();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_list_extended_attributes",
          "confidence": 0.96,
          "rationale": "Function is a thin wrapper that directly tail-calls the system import listxattr, which enumerates extended file attributes.",
          "evidence_refs": [
            "imports:listxattr"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_get_xattr_list",
            "ai_enumerate_xattrs"
          ]
        },
        "explain": {
          "summary": "The function at 0x4048b0 is a thin wrapper that directly forwards execution to the imported listxattr routine, effectively exposing the system call for listing extended file attributes.",
          "details": [
            "The function contains only a tail-call to the imported listxattr function and returns its result.",
            "No additional processing, argument manipulation, or error handling is performed within this wrapper."
          ],
          "evidence_refs": [
            "imports:listxattr",
            "call:0x422d30"
          ],
          "unknowns": [
            "Exact arguments passed to listxattr (they are likely passed unchanged from the caller).",
            "Any context-specific handling before or after the call, which is absent in this wrapper."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x4048c0",
      "original_name": "dcgettext",
      "final_name": "ai_gettext_wrapper",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 101,
      "callees": [
        {
          "addr": "0x422d38"
        }
      ],
      "import_refs": [
        "dcgettext"
      ],
      "string_refs": [],
      "constants": [
        "0x422d38"
      ],
      "snippets": {
        "asm": "  0x4048c0  endbr64 \n  0x4048c4  jmp     qword [rel dcgettext]",
        "hlil": "return dcgettext(domainname, msgid, category) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return dcgettext(domainname, msgid, category);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_gettext_wrapper",
          "confidence": 0.86,
          "rationale": "The function simply forwards its arguments to dcgettext and returns the result, acting as a wrapper for gettext localization calls.",
          "evidence_refs": [
            "imports:dcgettext",
            "call:0x4048c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_localize_message",
            "ai_translate_string"
          ]
        },
        "explain": {
          "summary": "The function at 0x4048c0 is a thin wrapper that directly forwards its three arguments (domainname, msgid, category) to the imported glibc dcgettext function and returns its result.",
          "details": [
            "It performs a tail call to dcgettext with the same parameters, without any additional processing.",
            "The wrapper is used throughout the binary (101 callers) to retrieve localized strings."
          ],
          "evidence_refs": [
            "imports:dcgettext",
            "call:0x4048c0"
          ],
          "unknowns": [
            "The reason for providing this wrapper instead of calling dcgettext directly (e.g., potential future extension) is not evident."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4048d0",
      "original_name": "__ctype_get_mb_cur_max",
      "final_name": "ai_get_mb_cur_max",
      "score": 13.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 5,
      "callees": [
        {
          "addr": "0x422d40"
        }
      ],
      "import_refs": [
        "__ctype_get_mb_cur_max"
      ],
      "string_refs": [],
      "constants": [
        "0x422d40"
      ],
      "snippets": {
        "asm": "  0x4048d0  endbr64 \n  0x4048d4  jmp     qword [rel __ctype_get_mb_cur_max]",
        "hlil": "return __ctype_get_mb_cur_max() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __ctype_get_mb_cur_max();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_mb_cur_max",
          "confidence": 0.92,
          "rationale": "The function is a thin wrapper that directly returns the result of the imported __ctype_get_mb_cur_max, which provides the maximum byte length of a multibyte character in the current locale.",
          "evidence_refs": [
            "imports:__ctype_get_mb_cur_max"
          ],
          "tags": [],
          "alt_names": [
            "ai_get_locale_mb_max",
            "ai_get_multibyte_char_len"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly returns the result of the imported __ctype_get_mb_cur_max, which reports the maximum number of bytes in a multibyte character for the current locale.",
          "details": [
            "It contains a single tail-call to __ctype_get_mb_cur_max and returns its value.",
            "No additional logic, data processing, or side effects are performed."
          ],
          "evidence_refs": [
            "imports:__ctype_get_mb_cur_max",
            "call:0x4048d0"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4048e0",
      "original_name": "strlen",
      "final_name": "ai_string_length",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 57,
      "callees": [
        {
          "addr": "0x422d48"
        }
      ],
      "import_refs": [
        "strlen"
      ],
      "string_refs": [],
      "constants": [
        "0x422d48"
      ],
      "snippets": {
        "asm": "  0x4048e0  endbr64 \n  0x4048e4  jmp     qword [rel strlen]",
        "hlil": "return strlen(arg1) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strlen(arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_string_length",
          "confidence": 0.98,
          "rationale": "The function is a thin wrapper that directly calls the imported strlen to compute the length of a string.",
          "evidence_refs": [
            "imports:strlen",
            "call:0x4048e0"
          ],
          "tags": [],
          "alt_names": [
            "ai_strlen_wrapper",
            "ai_get_string_length"
          ]
        },
        "explain": {
          "summary": "The function at 0x4048e0 is a thin wrapper that directly forwards its argument to the imported C library strlen and returns the resulting length. It performs a tail-call without any additional logic, serving as an indirect reference to the standard strlen implementation.",
          "details": [
            "Accepts a single pointer argument (arg1) representing a C-string.",
            "Calls the imported strlen function (callee at 0x422d48) and returns its result.",
            "No extra processing, string literals, or constants are used within the wrapper."
          ],
          "evidence_refs": [
            "imports:strlen",
            "call:0x422d48"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4048f0",
      "original_name": "__stack_chk_fail",
      "final_name": "ai_stack_canary_failure",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 31,
      "callees": [
        {
          "addr": "0x422d50"
        }
      ],
      "import_refs": [
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x422d50"
      ],
      "snippets": {
        "asm": "  0x4048f0  endbr64 \n  0x4048f4  jmp     qword [rel __stack_chk_fail]\n  0x4048f4  { Does not return }",
        "hlil": "noreturn __stack_chk_fail() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __stack_chk_fail();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stack_canary_failure",
          "confidence": 0.96,
          "rationale": "The function simply tail-calls __stack_chk_fail, indicating it handles stack canary violation detection.",
          "evidence_refs": [
            "imports:__stack_chk_fail"
          ],
          "tags": [
            "anti_debug"
          ],
          "alt_names": [
            "ai_stack_chk_fail_handler",
            "ai_canary_fail"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly invokes the imported __stack_chk_fail routine, causing program termination when a stack canary check fails.",
          "details": [
            "The function consists of a single tail-call to __stack_chk_fail.",
            "It imports __stack_chk_fail and calls it at address 0x422d50."
          ],
          "evidence_refs": [
            "imports:__stack_chk_fail",
            "call:0x422d50"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "anti_debug"
      ]
    },
    {
      "addr": "0x404900",
      "original_name": "getopt_long",
      "final_name": "ai_cli_option_parser",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d58"
        }
      ],
      "import_refs": [
        "getopt_long"
      ],
      "string_refs": [],
      "constants": [
        "0x422d58"
      ],
      "snippets": {
        "asm": "  0x404900  endbr64 \n  0x404904  jmp     qword [rel getopt_long]",
        "hlil": "return getopt_long(argc, argv, options, long_options, opt_index) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return getopt_long(argc, argv, options, long_options, opt_index);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_cli_option_parser",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly tail-calls the standard library function getopt_long, indicating its role is to parse command-line options.",
          "evidence_refs": [
            "imports:getopt_long"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_getopt_long_wrapper",
            "ai_argument_parser"
          ]
        },
        "explain": {
          "summary": "This function is a thin wrapper that directly forwards its parameters to the standard library getopt_long function and returns its result, performing no additional processing.",
          "details": [
            "The implementation consists solely of a tailcall to getopt_long with the same arguments (argc, argv, options, long_options, opt_index).",
            "No extra logic, string handling, or side effects are present; it serves as a simple passthrough for commandline option parsing."
          ],
          "evidence_refs": [
            "imports:getopt_long",
            "call:0x422d58"
          ],
          "unknowns": [
            "The broader context or reason for providing this wrapper within the binary."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404910",
      "original_name": "mbrtowc",
      "final_name": "ai_mbrtowc_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d60"
        }
      ],
      "import_refs": [
        "mbrtowc"
      ],
      "string_refs": [],
      "constants": [
        "0x422d60"
      ],
      "snippets": {
        "asm": "  0x404910  endbr64 \n  0x404914  jmp     qword [rel mbrtowc]",
        "hlil": "return mbrtowc(pwc, s, n, ps) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return mbrtowc(pwc, s, n, ps);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_mbrtowc_wrapper",
          "confidence": 0.96,
          "rationale": "Function simply forwards arguments to the standard library mbrtowc, acting as a wrapper for multibyte-to-wide-char conversion.",
          "evidence_refs": [
            "imports:mbrtowc"
          ],
          "tags": [],
          "alt_names": [
            "ai_multibyte_to_wchar",
            "ai_mbrtowc_proxy"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the standard library mbrtowc function and returns its result.",
          "details": [
            "Performs a tail-call to mbrtowc with parameters (pwc, s, n, ps).",
            "No additional processing or logic is performed beyond the call."
          ],
          "evidence_refs": [
            "imports:mbrtowc",
            "call:0x422d60"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404920",
      "original_name": "freecon",
      "final_name": "ai_free_security_context",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422d68"
        }
      ],
      "import_refs": [
        "freecon"
      ],
      "string_refs": [],
      "constants": [
        "0x422d68"
      ],
      "snippets": {
        "asm": "  0x404920  endbr64 \n  0x404924  jmp     qword [rel freecon]",
        "hlil": "return freecon() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return freecon();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_free_security_context",
          "confidence": 0.85,
          "rationale": "The function is a thin wrapper that directly calls the imported freecon routine, which frees a SELinux security context string.",
          "evidence_refs": [
            "imports:freecon",
            "call:0x422d68"
          ],
          "tags": [],
          "alt_names": [
            "ai_release_selinux_context",
            "ai_freecon_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that simply forwards to the imported freecon routine and returns its result, providing no additional logic.",
          "details": [
            "The body consists of a single tail-call: return freecon();",
            "Other functions (e.g., sub_409f10, sub_40e040) invoke freecon to release security context resources, indicating this wrapper is used for the same purpose."
          ],
          "evidence_refs": [
            "imports:freecon",
            "call:0x422d68"
          ],
          "unknowns": [
            "Exact semantics of the freecon function (e.g., parameters and side effects) are not determined from this snippet."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404930",
      "original_name": "strchr",
      "final_name": "ai_strchr_wrapper",
      "score": 14.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 6,
      "callees": [
        {
          "addr": "0x422d70"
        }
      ],
      "import_refs": [
        "strchr"
      ],
      "string_refs": [],
      "constants": [
        "0x422d70"
      ],
      "snippets": {
        "asm": "  0x404930  endbr64 \n  0x404934  jmp     qword [rel strchr]",
        "hlil": "return strchr(arg1, arg2) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strchr(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_strchr_wrapper",
          "confidence": 0.96,
          "rationale": "The function directly tail-calls the standard library strchr, acting as a thin wrapper for character search in strings.",
          "evidence_refs": [
            "imports:strchr",
            "call:0x404930"
          ],
          "tags": [],
          "alt_names": [
            "ai_find_char",
            "ai_search_char"
          ]
        },
        "explain": {
          "summary": "The function at 0x404930 is a thin wrapper that directly forwards its two arguments to the standard library strchr and returns the result.",
          "details": [
            "It imports the C library function strchr and makes a tail call to it with arg1 (string) and arg2 (character).",
            "No additional processing or logic is performed; it simply returns the pointer returned by strchr."
          ],
          "evidence_refs": [
            "imports:strchr",
            "call:0x422d70"
          ],
          "unknowns": [
            "The reason for providing a wrapper instead of calling strchr directly in callers."
          ],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404940",
      "original_name": "getgrgid",
      "final_name": "ai_get_group_by_gid",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d78"
        }
      ],
      "import_refs": [
        "getgrgid"
      ],
      "string_refs": [],
      "constants": [
        "0x422d78"
      ],
      "snippets": {
        "asm": "  0x404940  endbr64 \n  0x404944  jmp     qword [rel getgrgid]",
        "hlil": "return getgrgid(gid) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return getgrgid(gid);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_group_by_gid",
          "confidence": 0.95,
          "rationale": "The function is a thin wrapper that directly calls the system getgrgid API to retrieve group information for a given GID.",
          "evidence_refs": [
            "imports:getgrgid"
          ],
          "tags": [],
          "alt_names": [
            "ai_group_lookup",
            "ai_get_group"
          ]
        },
        "explain": {
          "summary": "The function at 0x404940 is a thin wrapper that forwards its gid argument to the imported getgrgid library call and returns the resulting struct group pointer.",
          "details": [
            "It receives a gid parameter and immediately performs a tail call to the system getgrgid function.",
            "No additional processing, error handling, or memory management is performed within this wrapper."
          ],
          "evidence_refs": [
            "imports:getgrgid",
            "call:0x404940"
          ],
          "unknowns": [
            "The broader context in which this wrapper is used within the program."
          ],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404950",
      "original_name": "snprintf",
      "final_name": "ai_snprintf_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d80"
        }
      ],
      "import_refs": [
        "snprintf"
      ],
      "string_refs": [],
      "constants": [
        "0x422d80"
      ],
      "snippets": {
        "asm": "  0x404950  endbr64 \n  0x404954  jmp     qword [rel snprintf]",
        "hlil": "return snprintf(s, maxlen, format) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return snprintf(s, maxlen, format);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_snprintf_wrapper",
          "confidence": 0.92,
          "rationale": "The function directly tail-calls snprintf with the same arguments, acting as a thin wrapper for string formatting.",
          "evidence_refs": [
            "imports:snprintf"
          ],
          "tags": [],
          "alt_names": [
            "ai_format_string",
            "ai_string_format"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the standard snprintf function and returns its result.",
          "details": [
            "It receives a buffer pointer (s), a maximum length (maxlen), and a format string (format) and immediately calls snprintf with those parameters.",
            "The function performs a tail call, returning the value from snprintf without additional processing."
          ],
          "evidence_refs": [
            "imports:snprintf",
            "call:0x422d80"
          ],
          "unknowns": [
            "The specific usage context of this wrapper within the larger program."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404960",
      "original_name": "__overflow",
      "final_name": "ai_file_stream_overflow",
      "score": 23.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 15,
      "callees": [
        {
          "addr": "0x422d88"
        }
      ],
      "import_refs": [
        "__overflow"
      ],
      "string_refs": [],
      "constants": [
        "0x422d88"
      ],
      "snippets": {
        "asm": "  0x404960  endbr64 \n  0x404964  jmp     qword [rel __overflow]",
        "hlil": "return __overflow(f, ch) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __overflow(f, ch);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_file_stream_overflow",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the libc __overflow routine to write a character to a FILE stream when the buffer is full, indicating file I/O overflow handling.",
          "evidence_refs": [
            "imports:__overflow",
            "call:0x404960"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_file_overflow_handler",
            "ai_stdout_char_write"
          ]
        },
        "explain": {
          "summary": "The function at 0x404960 is a thin wrapper that forwards its arguments to the imported __overflow routine, returning its result directly. It is used by other code to handle stdio buffer overflow conditions by delegating to the actual __overflow implementation.",
          "details": [
            "The function contains a single tail-call: return __overflow(f, ch);",
            "It imports the __overflow symbol and its only callee is at address 0x422d88, indicating it simply forwards to the real overflow handler."
          ],
          "evidence_refs": [
            "imports:__overflow",
            "call:0x422d88"
          ],
          "unknowns": [
            "Why a separate wrapper is needed instead of calling __overflow directly in all places"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404970",
      "original_name": "strrchr",
      "final_name": "ai_strrchr_wrapper",
      "score": 15.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 7,
      "callees": [
        {
          "addr": "0x422d90"
        }
      ],
      "import_refs": [
        "strrchr"
      ],
      "string_refs": [],
      "constants": [
        "0x422d90"
      ],
      "snippets": {
        "asm": "  0x404970  endbr64 \n  0x404974  jmp     qword [rel strrchr]",
        "hlil": "return strrchr(arg1, arg2) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strrchr(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_strrchr_wrapper",
          "confidence": 0.96,
          "rationale": "The function simply forwards its arguments to the standard library strrchr, acting as a thin wrapper for locating the last occurrence of a character in a string.",
          "evidence_refs": [
            "imports:strrchr",
            "call:0x422d90"
          ],
          "tags": [],
          "alt_names": [
            "ai_find_last_char",
            "ai_last_occurrence_search"
          ]
        },
        "explain": {
          "summary": "The function at 0x404970 is a thin wrapper that directly forwards its arguments to the standard library strrchr function and returns its result. It performs no additional processing, acting as a simple alias for the imported strrchr.",
          "details": [
            "Accepts a string pointer and a character value as arguments.",
            "Calls the imported strrchr implementation at address 0x422d90 and returns the pointer to the last occurrence of the character.",
            "Serves as a passthrough wrapper used by other code sections such as main and other helper functions."
          ],
          "evidence_refs": [
            "imports:strrchr",
            "call:0x422d90",
            "strings:none"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404980",
      "original_name": "gmtime_r",
      "final_name": "ai_gmtime_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422d98"
        }
      ],
      "import_refs": [
        "gmtime_r"
      ],
      "string_refs": [],
      "constants": [
        "0x422d98"
      ],
      "snippets": {
        "asm": "  0x404980  endbr64 \n  0x404984  jmp     qword [rel gmtime_r]",
        "hlil": "return gmtime_r(t, tp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return gmtime_r(t, tp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_gmtime_wrapper",
          "confidence": 0.92,
          "rationale": "The function directly tail-calls the standard library gmtime_r to convert a timestamp to a UTC broken-down time structure, acting as a thin wrapper.",
          "evidence_refs": [
            "imports:gmtime_r",
            "call:0x422d98"
          ],
          "tags": [],
          "alt_names": [
            "ai_utc_time_converter",
            "ai_time_struct_wrapper"
          ]
        },
        "explain": {
          "summary": "The function at 0x404980 is a thin wrapper that directly forwards its arguments to the standard library gmtime_r and returns its result.",
          "details": [
            "It receives a time_t pointer and a struct tm pointer, then performs a tail call to gmtime_r(t, tp).",
            "No additional processing or side effects are performed; it simply returns the pointer returned by gmtime_r."
          ],
          "evidence_refs": [
            "imports:gmtime_r",
            "call:0x422d98"
          ],
          "unknowns": [
            "The reason for providing this wrapper (e.g., abstraction layer or compatibility) is not evident from the code."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404990",
      "original_name": "lseek",
      "final_name": "ai_file_seek",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422da0"
        }
      ],
      "import_refs": [
        "lseek"
      ],
      "string_refs": [],
      "constants": [
        "0x422da0"
      ],
      "snippets": {
        "asm": "  0x404990  endbr64 \n  0x404994  jmp     qword [rel lseek]",
        "hlil": "return lseek(fd, __arg2, whence) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return lseek(fd, __arg2, whence);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_file_seek",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly forwards arguments to the lseek system call, indicating its role in file offset manipulation.",
          "evidence_refs": [
            "imports:lseek",
            "call:0x404990"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_lseek_wrapper",
            "ai_seek"
          ]
        },
        "explain": {
          "summary": "The function at 0x404990 is a thin wrapper that directly forwards its three arguments to the system lseek call and returns the result.",
          "details": [
            "It imports the lseek function and performs a tailcall to it with the same parameters (fd, __arg2, whence).",
            "No additional processing, checks, or side effects are performed; it simply returns the lseek return value."
          ],
          "evidence_refs": [
            "imports:lseek",
            "call:0x422da0"
          ],
          "unknowns": [
            "The exact purpose of the constant 0x422da0 referenced as a callee address."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x4049a0",
      "original_name": "__assert_fail",
      "final_name": "ai_assert_failure_handler",
      "score": 12.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 4,
      "callees": [
        {
          "addr": "0x422da8"
        }
      ],
      "import_refs": [
        "__assert_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x422da8"
      ],
      "snippets": {
        "asm": "  0x4049a0  endbr64 \n  0x4049a4  jmp     qword [rel __assert_fail]\n  0x4049a4  { Does not return }",
        "hlil": "noreturn __assert_fail(assertion, file, line, function) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __assert_fail(assertion, file, line, function);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_assert_failure_handler",
          "confidence": 0.96,
          "rationale": "The function simply forwards its arguments to the imported __assert_fail, acting as a wrapper for assertion failure handling.",
          "evidence_refs": [
            "imports:__assert_fail",
            "call:0x4049a0"
          ],
          "tags": [
            "anti_debug",
            "process"
          ],
          "alt_names": [
            "ai_assert_fail_wrapper",
            "ai_trigger_assert"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards its arguments to the standard __assert_fail routine, performing a tail call without additional logic.",
          "details": [
            "It imports the __assert_fail symbol and directly calls it with the provided assertion, file, line, and function parameters.",
            "The implementation consists of a single tailcall instruction, indicating no extra processing before delegating to the real assert handler."
          ],
          "evidence_refs": [
            "imports:__assert_fail",
            "call:0x422da8"
          ],
          "unknowns": [],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "anti_debug",
        "process"
      ]
    },
    {
      "addr": "0x4049b0",
      "original_name": "fnmatch",
      "final_name": "ai_fnmatch_wrapper",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422db0"
        }
      ],
      "import_refs": [
        "fnmatch"
      ],
      "string_refs": [],
      "constants": [
        "0x422db0"
      ],
      "snippets": {
        "asm": "  0x4049b0  endbr64 \n  0x4049b4  jmp     qword [rel fnmatch]",
        "hlil": "return fnmatch(pattern, string, flags) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fnmatch(pattern, string, flags);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_fnmatch_wrapper",
          "confidence": 0.96,
          "rationale": "Thin wrapper that directly forwards arguments to the POSIX fnmatch function for pattern matching.",
          "evidence_refs": [
            "imports:fnmatch",
            "call:0x422db0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_match_pattern",
            "ai_glob_match"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the standard library fnmatch and returns its result.",
          "details": [
            "It receives pattern, string, and flags parameters.",
            "It performs a tail-call to the imported fnmatch function and returns its return value without additional processing."
          ],
          "evidence_refs": [
            "imports:fnmatch",
            "call:0x422db0"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x4049c0",
      "original_name": "memset",
      "final_name": "ai_memset_wrapper",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 21,
      "callees": [
        {
          "addr": "0x422db8"
        }
      ],
      "import_refs": [
        "memset"
      ],
      "string_refs": [],
      "constants": [
        "0x422db8"
      ],
      "snippets": {
        "asm": "  0x4049c0  endbr64 \n  0x4049c4  jmp     qword [rel memset]",
        "hlil": "return memset(arg1, arg2, arg3) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return memset(arg1, arg2, arg3);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memset_wrapper",
          "confidence": 0.97,
          "rationale": "The function simply forwards its arguments to the standard memset import, acting as a thin wrapper for memory initialization.",
          "evidence_refs": [
            "imports:memset",
            "call:0x4049c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_fill_memory",
            "ai_memory_set"
          ]
        },
        "explain": {
          "summary": "The function at 0x4049c0 is a thin wrapper that directly forwards its arguments to the standard library memset function, returning the result. It performs no additional processing beyond invoking memset with the provided destination pointer, fill value, and length.",
          "details": [
            "Accepts three arguments: destination address, fill byte, and number of bytes to set.",
            "Calls the imported memset routine (callee at 0x422db8) and returns its result.",
            "Serves as an indirect entry point for memory initialization, used by multiple callers (21)."
          ],
          "evidence_refs": [
            "imports:memset",
            "call:0x422db8"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x4049d0",
      "original_name": "ioctl",
      "final_name": "ai_ioctl_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422dc0"
        }
      ],
      "import_refs": [
        "ioctl"
      ],
      "string_refs": [],
      "constants": [
        "0x422dc0"
      ],
      "snippets": {
        "asm": "  0x4049d0  endbr64 \n  0x4049d4  jmp     qword [rel ioctl]",
        "hlil": "return ioctl() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return ioctl();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_ioctl_wrapper",
          "confidence": 0.86,
          "rationale": "The function simply forwards to the imported ioctl system call, indicating a wrapper for device control operations.",
          "evidence_refs": [
            "imports:ioctl",
            "call:0x422dc0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_device_control",
            "ai_ioctl_call"
          ]
        },
        "explain": {
          "summary": "The function at 0x4049d0 is a thin wrapper that directly forwards execution to the imported ioctl system call and returns its result.",
          "details": [
            "The function contains only a tail call to ioctl, indicating no additional processing.",
            "It imports the ioctl symbol and calls it via the address 0x422dc0, acting as a simple passthrough."
          ],
          "evidence_refs": [
            "imports:ioctl",
            "call:0x422dc0"
          ],
          "unknowns": [
            "What arguments are passed to ioctl when this wrapper is invoked",
            "The specific context or purpose of this wrapper within the larger program"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x4049e0",
      "original_name": "getcwd",
      "final_name": "ai_get_current_working_directory",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422dc8"
        }
      ],
      "import_refs": [
        "getcwd"
      ],
      "string_refs": [],
      "constants": [
        "0x422dc8"
      ],
      "snippets": {
        "asm": "  0x4049e0  endbr64 \n  0x4049e4  jmp     qword [rel getcwd]",
        "hlil": "return getcwd(buf, size) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return getcwd(buf, size);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_current_working_directory",
          "confidence": 0.97,
          "rationale": "The function is a thin wrapper that directly calls the imported getcwd API to retrieve the current working directory.",
          "evidence_refs": [
            "imports:getcwd",
            "call:0x4049e0",
            "constants:0x422dc8"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_getcwd",
            "ai_get_current_dir"
          ]
        },
        "explain": {
          "summary": "The function at 0x4049e0 is a thin wrapper that directly forwards its arguments to the imported getcwd function and returns its result.",
          "details": [
            "It performs a tail call to getcwd(buf, size) without any additional processing.",
            "The only import referenced is getcwd, confirming its role as a simple delegator."
          ],
          "evidence_refs": [
            "imports:getcwd",
            "call:0x422dc8"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x4049f0",
      "original_name": "mbrtoc32",
      "final_name": "ai_mbrtoc32_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422dd0"
        }
      ],
      "import_refs": [
        "mbrtoc32"
      ],
      "string_refs": [],
      "constants": [
        "0x422dd0"
      ],
      "snippets": {
        "asm": "  0x4049f0  endbr64 \n  0x4049f4  jmp     qword [rel mbrtoc32]",
        "hlil": "return mbrtoc32(pc32, s, n, ps) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return mbrtoc32(pc32, s, n, ps);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_mbrtoc32_wrapper",
          "confidence": 0.97,
          "rationale": "Function simply forwards arguments to the standard library mbrtoc32, converting multibyte sequences to UTF-32 code points.",
          "evidence_refs": [
            "imports:mbrtoc32",
            "call:0x4049f0"
          ],
          "tags": [],
          "alt_names": [
            "ai_utf32_decode",
            "ai_convert_multibyte_to_utf32"
          ]
        },
        "explain": {
          "summary": "The function at 0x4049f0 is a thin wrapper that directly forwards its arguments to the imported mbrtoc32 routine and returns the result unchanged.",
          "details": [
            "It performs a tail-call to mbrtoc32 with parameters (pc32, s, n, ps).",
            "No additional processing, checks, or side effects are performed within this wrapper."
          ],
          "evidence_refs": [
            "imports:mbrtoc32",
            "call:0x4049f0"
          ],
          "unknowns": [
            "Exact runtime behavior of the underlying mbrtoc32 implementation (e.g., locale handling)."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404a00",
      "original_name": "closedir",
      "final_name": "ai_close_directory",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422dd8"
        }
      ],
      "import_refs": [
        "closedir"
      ],
      "string_refs": [],
      "constants": [
        "0x422dd8"
      ],
      "snippets": {
        "asm": "  0x404a00  endbr64 \n  0x404a04  jmp     qword [rel closedir]",
        "hlil": "return closedir(dirp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return closedir(dirp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_close_directory",
          "confidence": 0.98,
          "rationale": "The function is a thin wrapper that directly calls the POSIX closedir() API to close a directory handle and returns its result.",
          "evidence_refs": [
            "imports:closedir",
            "call:0x404a00"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_dir_close",
            "ai_close_dir"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its argument to the system closedir call and returns the result, performing no additional processing.",
          "details": [
            "It imports the closedir function and tail-calls it with the provided DIR pointer (dirp).",
            "The function consists of a single return statement invoking closedir(dirp), indicating it solely handles directory closure."
          ],
          "evidence_refs": [
            "imports:closedir",
            "call:0x422dd8"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404a10",
      "original_name": "memcmp",
      "final_name": "ai_memcmp_wrapper",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422de0"
        }
      ],
      "import_refs": [
        "memcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x422de0"
      ],
      "snippets": {
        "asm": "  0x404a10  endbr64 \n  0x404a14  jmp     qword [rel memcmp]",
        "hlil": "return memcmp(arg1, arg2, arg3) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return memcmp(arg1, arg2, arg3);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memcmp_wrapper",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly forwards its arguments to the standard memcmp library call, indicating its purpose is to compare memory buffers.",
          "evidence_refs": [
            "imports:memcmp"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_memory",
            "ai_memcmp_proxy"
          ]
        },
        "explain": {
          "summary": "The function at 0x404a10 is a thin wrapper that directly forwards its three arguments to the standard library memcmp and returns the result.",
          "details": [
            "It imports the memcmp function and makes a tail call to it with arg1, arg2, and arg3 unchanged.",
            "No additional logic, string handling, or side effects are present; it simply returns the comparison outcome."
          ],
          "evidence_refs": [
            "imports:memcmp",
            "call:0x422de0"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404a20",
      "original_name": "_setjmp",
      "final_name": "ai_setjmp_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422de8"
        }
      ],
      "import_refs": [
        "_setjmp"
      ],
      "string_refs": [],
      "constants": [
        "0x422de8"
      ],
      "snippets": {
        "asm": "  0x404a20  endbr64 \n  0x404a24  jmp     qword [rel _setjmp]",
        "hlil": "return _setjmp() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return _setjmp();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_setjmp_wrapper",
          "confidence": 0.86,
          "rationale": "The function simply tail-calls the imported _setjmp, acting as a wrapper to save execution context for later longjmp usage.",
          "evidence_refs": [
            "imports:_setjmp",
            "call:0x404a20"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_context_save",
            "ai_longjmp_setup"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly invokes the imported _setjmp function and returns its result, performing no additional processing.",
          "details": [
            "Implements a tail call to _setjmp, effectively forwarding the call.",
            "No other logic, strings, or data manipulation is present in this function."
          ],
          "evidence_refs": [
            "imports:_setjmp",
            "call:0x422de8"
          ],
          "unknowns": [
            "Purpose of wrapping _setjmp in this context",
            "Any surrounding code that relies on this wrapper"
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404a30",
      "original_name": "fputs_unlocked",
      "final_name": "ai_print_string_to_stream",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 51,
      "callees": [
        {
          "addr": "0x422df0"
        }
      ],
      "import_refs": [
        "fputs_unlocked"
      ],
      "string_refs": [],
      "constants": [
        "0x422df0"
      ],
      "snippets": {
        "asm": "  0x404a30  endbr64 \n  0x404a34  jmp     qword [rel fputs_unlocked]",
        "hlil": "return fputs_unlocked(str, fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fputs_unlocked(str, fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_string_to_stream",
          "confidence": 0.86,
          "rationale": "The function is a thin wrapper that directly calls fputs_unlocked to write a string to a FILE* stream, indicating output/printing behavior.",
          "evidence_refs": [
            "imports:fputs_unlocked",
            "call:0x422df0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_fputs_wrapper",
            "ai_write_string"
          ]
        },
        "explain": {
          "summary": "The function at 0x404a30 is a thin wrapper that directly forwards its arguments to the standard library function fputs_unlocked and returns its result. It performs no additional processing, serving only as an indirect call site used by many callers.",
          "details": [
            "The implementation consists solely of a tail-call: return fputs_unlocked(str, fp);",
            "No string literals or extra logic are present, indicating its role is purely to delegate output to fputs_unlocked."
          ],
          "evidence_refs": [
            "imports:fputs_unlocked",
            "call:0x422df0"
          ],
          "unknowns": [
            "The rationale for providing this wrapper (e.g., compatibility, indirection) is not evident from the code alone."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404a40",
      "original_name": "rawmemchr",
      "final_name": "ai_memory_byte_search",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422df8"
        }
      ],
      "import_refs": [
        "rawmemchr"
      ],
      "string_refs": [],
      "constants": [
        "0x422df8"
      ],
      "snippets": {
        "asm": "  0x404a40  endbr64 \n  0x404a44  jmp     qword [rel rawmemchr]",
        "hlil": "return rawmemchr(arg1, arg2) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return rawmemchr(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memory_byte_search",
          "confidence": 0.93,
          "rationale": "The function is a thin wrapper that directly tail-calls the standard library rawmemchr, which searches a memory block for a specific byte value.",
          "evidence_refs": [
            "imports:rawmemchr",
            "call:0x422df8"
          ],
          "tags": [],
          "alt_names": [
            "ai_memchr_wrapper",
            "ai_find_byte_in_memory"
          ]
        },
        "explain": {
          "summary": "The function at 0x404a40 is a thin wrapper that directly forwards its two arguments to the imported rawmemchr library function and returns its result.",
          "details": [
            "The implementation consists solely of a tailcall: return rawmemchr(arg1, arg2);",
            "The import table lists rawmemchr, and the callee address (0x422df8) corresponds to that imported function."
          ],
          "evidence_refs": [
            "imports:rawmemchr",
            "call:0x422df8"
          ],
          "unknowns": [
            "The broader context or reason for providing this wrapper within the binary."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404a50",
      "original_name": "calloc",
      "final_name": "ai_calloc_wrapper",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422e00"
        }
      ],
      "import_refs": [
        "calloc"
      ],
      "string_refs": [],
      "constants": [
        "0x422e00"
      ],
      "snippets": {
        "asm": "  0x404a50  endbr64 \n  0x404a54  jmp     qword [rel calloc]",
        "hlil": "return calloc(nmemb, size) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return calloc(nmemb, size);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_calloc_wrapper",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly forwards its arguments to the standard calloc function, indicating its role is memory allocation.",
          "evidence_refs": [
            "imports:calloc"
          ],
          "tags": [],
          "alt_names": [
            "ai_allocate_memory",
            "ai_memory_alloc"
          ]
        },
        "explain": {
          "summary": "This function is a thin wrapper that directly forwards its two arguments to the C library calloc and returns the allocated zeroinitialized memory.",
          "details": [
            "It performs a tail call to the imported calloc with the provided nmemb and size parameters.",
            "No additional processing or error handling is performed; the result of calloc is returned unchanged."
          ],
          "evidence_refs": [
            "imports:calloc",
            "call:0x404a50"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404a60",
      "original_name": "__readlink_chk",
      "final_name": "ai_readlink_check",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e08"
        }
      ],
      "import_refs": [
        "__readlink_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422e08"
      ],
      "snippets": {
        "asm": "  0x404a60  endbr64 \n  0x404a64  jmp     qword [rel __readlink_chk]",
        "hlil": "return __readlink_chk(path, buf, len, buflen) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __readlink_chk(path, buf, len, buflen);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_readlink_check",
          "confidence": 0.96,
          "rationale": "Function is a thin wrapper that tail-calls the imported __readlink_chk, which validates and reads a symbolic link into a buffer, indicating file system I/O behavior.",
          "evidence_refs": [
            "imports:__readlink_chk",
            "call:0x404a60"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_symlink_read_check",
            "ai_readlink_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the imported __readlink_chk routine and returns its result.",
          "details": [
            "Implements a tail-call to __readlink_chk with the same parameters (path, buf, len, buflen).",
            "Contains no additional logic or processing beyond the call."
          ],
          "evidence_refs": [
            "imports:__readlink_chk",
            "call:0x422e08"
          ],
          "unknowns": [
            "Exact behavior of the underlying __readlink_chk implementation"
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404a70",
      "original_name": "signal",
      "final_name": "ai_set_signal_handler",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422e10"
        }
      ],
      "import_refs": [
        "signal"
      ],
      "string_refs": [],
      "constants": [
        "0x422e10"
      ],
      "snippets": {
        "asm": "  0x404a70  endbr64 \n  0x404a74  jmp     qword [rel signal]",
        "hlil": "return signal(sig, handler) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return signal(sig, handler);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_signal_handler",
          "confidence": 0.95,
          "rationale": "Thin wrapper that directly calls the POSIX signal() function to register a handler for a given signal.",
          "evidence_refs": [
            "imports:signal",
            "call:0x422e10"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_register_signal_handler",
            "ai_signal_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the C library signal() function and returns its result.",
          "details": [
            "It receives a signal number and a handler pointer, then tail-calls signal(sig, handler).",
            "No additional logic, data manipulation, or side effects are performed within this function."
          ],
          "evidence_refs": [
            "imports:signal",
            "call:0x422e10"
          ],
          "unknowns": [
            "The broader context in which this wrapper is used within the program."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404a80",
      "original_name": "dirfd",
      "final_name": "ai_get_dir_fd",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e18"
        }
      ],
      "import_refs": [
        "dirfd"
      ],
      "string_refs": [],
      "constants": [
        "0x422e18"
      ],
      "snippets": {
        "asm": "  0x404a80  endbr64 \n  0x404a84  jmp     qword [rel dirfd]",
        "hlil": "return dirfd(dirp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return dirfd(dirp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_dir_fd",
          "confidence": 0.97,
          "rationale": "Function is a thin wrapper that returns the file descriptor of a DIR* by calling the dirfd import.",
          "evidence_refs": [
            "imports:dirfd"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_dirfd_wrapper",
            "ai_get_directory_fd"
          ]
        },
        "explain": {
          "summary": "The function at 0x404a80 is a thin wrapper that forwards its argument to the imported dirfd function and returns the resulting file descriptor. It performs no additional processing, acting as a direct tail call to the system's dirfd implementation.",
          "details": [
            "The function consists of a single instruction: return dirfd(dirp);",
            "It imports the dirfd symbol and calls it with the provided DIR* pointer."
          ],
          "evidence_refs": [
            "imports:dirfd",
            "call:0x422e18"
          ],
          "unknowns": [
            "The context in which this wrapper is used within the larger program."
          ],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404a90",
      "original_name": "fputc_unlocked",
      "final_name": "ai_write_char_to_stream",
      "score": 12.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 4,
      "callees": [
        {
          "addr": "0x422e20"
        }
      ],
      "import_refs": [
        "fputc_unlocked"
      ],
      "string_refs": [],
      "constants": [
        "0x422e20"
      ],
      "snippets": {
        "asm": "  0x404a90  endbr64 \n  0x404a94  jmp     qword [rel fputc_unlocked]",
        "hlil": "return fputc_unlocked(c, fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fputc_unlocked(c, fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_write_char_to_stream",
          "confidence": 0.96,
          "rationale": "Function is a thin wrapper that directly tail-calls fputc_unlocked, indicating it writes a single character to a FILE stream.",
          "evidence_refs": [
            "imports:fputc_unlocked",
            "call:0x404a90"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_fputc_wrapper",
            "ai_putc_to_file"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards its arguments to the standard library fputc_unlocked function and returns its result.",
          "details": [
            "It receives a character and a FILE pointer, then directly tail-calls the imported fputc_unlocked with those parameters.",
            "No additional logic or processing is performed; it simply returns the result of fputc_unlocked."
          ],
          "evidence_refs": [
            "imports:fputc_unlocked",
            "call:0x422e20"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404aa0",
      "original_name": "__memcpy_chk",
      "final_name": "ai_safe_memory_copy",
      "score": 15.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 7,
      "callees": [
        {
          "addr": "0x422e28"
        }
      ],
      "import_refs": [
        "__memcpy_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422e28"
      ],
      "snippets": {
        "asm": "  0x404aa0  endbr64 \n  0x404aa4  jmp     qword [rel __memcpy_chk]",
        "hlil": "return __memcpy_chk(arg1, arg2, arg3, arg4) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __memcpy_chk(arg1, arg2, arg3, arg4);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_safe_memory_copy",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly tail-calls the imported __memcpy_chk, indicating its purpose is to perform a bounds-checked memory copy.",
          "evidence_refs": [
            "imports:__memcpy_chk",
            "call:0x404aa0"
          ],
          "tags": [],
          "alt_names": [
            "ai_memcpy_checked",
            "ai_safe_copy"
          ]
        },
        "explain": {
          "summary": "The function at 0x404aa0 is a thin wrapper that directly tailcalls the imported __memcpy_chk routine, passing through all four arguments and returning its result. It performs no additional logic beyond delegating to the library implementation of the boundschecked memcpy.",
          "details": [
            "The body consists solely of a tailcall to __memcpy_chk with the same arguments (arg1, arg2, arg3, arg4).",
            "It is referenced by other functions (e.g., sub_408fc0 and sub_40c5e0) that rely on safe memory copying."
          ],
          "evidence_refs": [
            "imports:__memcpy_chk",
            "call:0x422e28"
          ],
          "unknowns": [
            "Exact runtime bounds checking behavior performed by the imported __memcpy_chk implementation."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404ab0",
      "original_name": "sigemptyset",
      "final_name": "ai_sigemptyset_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e30"
        }
      ],
      "import_refs": [
        "sigemptyset"
      ],
      "string_refs": [],
      "constants": [
        "0x422e30"
      ],
      "snippets": {
        "asm": "  0x404ab0  endbr64 \n  0x404ab4  jmp     qword [rel sigemptyset]",
        "hlil": "return sigemptyset(set) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sigemptyset(set);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_sigemptyset_wrapper",
          "confidence": 0.96,
          "rationale": "The function simply forwards its argument to the libc sigemptyset call, acting as a thin wrapper to initialize a signal set to empty.",
          "evidence_refs": [
            "imports:sigemptyset",
            "call:0x404ab0"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_initialize_signal_set",
            "ai_clear_sigset"
          ]
        },
        "explain": {
          "summary": "The function at 0x404ab0 is a thin wrapper that directly forwards its argument to the imported sigemptyset function and returns its result.",
          "details": [
            "Implements a tail call to the system sigemptyset, clearing the provided signal set structure.",
            "No additional logic or side effects are present beyond invoking the imported sigemptyset."
          ],
          "evidence_refs": [
            "imports:sigemptyset",
            "call:0x422e30",
            "strings:none"
          ],
          "unknowns": [
            "Potential calling conventions or error handling beyond the direct call are not visible."
          ],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404ac0",
      "original_name": "stat",
      "final_name": "ai_file_stat",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e38"
        }
      ],
      "import_refs": [
        "stat"
      ],
      "string_refs": [],
      "constants": [
        "0x422e38"
      ],
      "snippets": {
        "asm": "  0x404ac0  endbr64 \n  0x404ac4  jmp     qword [rel stat]",
        "hlil": "return stat() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return stat();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_file_stat",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly tail-calls the imported 'stat' system call, indicating its purpose is to retrieve file metadata (status).",
          "evidence_refs": [
            "imports:stat",
            "call:0x404ac0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_stat_wrapper",
            "ai_get_file_info"
          ]
        },
        "explain": {
          "summary": "The function at 0x404ac0 is a thin wrapper that directly forwards its call to the imported stat function, returning its result. It performs a tail call without any additional processing or error handling. This suggests it serves as a simple alias or compatibility shim for the system stat call.",
          "details": [
            "The function contains only a tailcall to the imported stat routine.",
            "No string literals or additional logic are present, indicating it merely passes through arguments to stat."
          ],
          "evidence_refs": [
            "imports:stat",
            "call:0x422e38"
          ],
          "unknowns": [
            "Exact handling of arguments and return values (e.g., whether it modifies parameters before calling stat)",
            "Context of how this wrapper is used within the larger binary"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404ad0",
      "original_name": "memcpy",
      "final_name": "ai_copy_memory",
      "score": 20.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 12,
      "callees": [
        {
          "addr": "0x422e40"
        }
      ],
      "import_refs": [
        "memcpy"
      ],
      "string_refs": [],
      "constants": [
        "0x422e40"
      ],
      "snippets": {
        "asm": "  0x404ad0  endbr64 \n  0x404ad4  jmp     qword [rel memcpy]",
        "hlil": "return memcpy(arg1, arg2, arg3) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return memcpy(arg1, arg2, arg3);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_copy_memory",
          "confidence": 0.97,
          "rationale": "The function directly tail-calls the standard memcpy import, acting as a thin wrapper for memory copying.",
          "evidence_refs": [
            "imports:memcpy"
          ],
          "tags": [],
          "alt_names": [
            "ai_memcpy_wrapper",
            "ai_copy_buffer"
          ]
        },
        "explain": {
          "summary": "The function at 0x404ad0 is a thin wrapper that directly forwards its arguments to the standard library memcpy and returns its result.",
          "details": [
            "Accepts three arguments: destination pointer, source pointer, and byte count.",
            "Performs a tail-call to the imported memcpy routine (address 0x422e40) with those arguments.",
            "Returns the pointer returned by memcpy, typically the destination address."
          ],
          "evidence_refs": [
            "imports:memcpy",
            "call:0x422e40"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404ae0",
      "original_name": "__isoc23_strtoumax",
      "final_name": "ai_str_to_uintmax",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e48"
        }
      ],
      "import_refs": [
        "__isoc23_strtoumax"
      ],
      "string_refs": [],
      "constants": [
        "0x422e48"
      ],
      "snippets": {
        "asm": "  0x404ae0  endbr64 \n  0x404ae4  jmp     qword [rel __isoc23_strtoumax]",
        "hlil": "return __isoc23_strtoumax() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __isoc23_strtoumax();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_str_to_uintmax",
          "confidence": 0.95,
          "rationale": "The function directly forwards to __isoc23_strtoumax, which parses a string into an unsigned integer of maximum width, indicating a string-to-integer conversion behavior.",
          "evidence_refs": [
            "imports:__isoc23_strtoumax"
          ],
          "tags": [],
          "alt_names": [
            "ai_string_to_uintmax",
            "ai_atoi_uintmax"
          ]
        },
        "explain": {
          "summary": "The function at 0x404ae0 is a thin wrapper that directly tail-calls the imported __isoc23_strtoumax routine, returning its result without additional processing. It serves as a local alias or forwarding stub for the standard library conversion function that parses a string to a uintmax_t value.",
          "details": [
            "The body consists solely of a return statement invoking __isoc23_strtoumax, indicating no extra logic or argument manipulation.",
            "The function imports __isoc23_strtoumax and its only callee is at address 0x422e48, confirming it forwards control to the standard conversion routine."
          ],
          "evidence_refs": [
            "imports:__isoc23_strtoumax",
            "call:0x422e48"
          ],
          "unknowns": [
            "Exact argument passing conventions (registers vs stack) are not shown in the snippet."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404af0",
      "original_name": "tzset",
      "final_name": "ai_set_timezone",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422e50"
        }
      ],
      "import_refs": [
        "tzset"
      ],
      "string_refs": [],
      "constants": [
        "0x422e50"
      ],
      "snippets": {
        "asm": "  0x404af0  endbr64 \n  0x404af4  jmp     qword [rel tzset]",
        "hlil": "return tzset() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return tzset();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_timezone",
          "confidence": 0.88,
          "rationale": "Function is a thin wrapper that directly calls the standard tzset library function to apply timezone changes.",
          "evidence_refs": [
            "imports:tzset",
            "call:0x404af0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_tzset_wrapper",
            "ai_update_timezone"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly invokes the system tzset call and returns its result.",
          "details": [
            "It performs a tailcall to the imported tzset function without any additional processing.",
            "No strings or other logic are involved; it simply forwards the call."
          ],
          "evidence_refs": [
            "imports:tzset",
            "call:0x422e50"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404b00",
      "original_name": "fileno",
      "final_name": "ai_get_fileno",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422e58"
        }
      ],
      "import_refs": [
        "fileno"
      ],
      "string_refs": [],
      "constants": [
        "0x422e58"
      ],
      "snippets": {
        "asm": "  0x404b00  endbr64 \n  0x404b04  jmp     qword [rel fileno]",
        "hlil": "return fileno(fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fileno(fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_fileno",
          "confidence": 0.95,
          "rationale": "Simple wrapper that returns the file descriptor of a FILE* by calling the standard fileno function.",
          "evidence_refs": [
            "imports:fileno",
            "call:0x404b00"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_fileno",
            "ai_file_descriptor"
          ]
        },
        "explain": {
          "summary": "The function at 0x404b00 is a thin wrapper that returns the file descriptor of a FILE* by directly calling the standard library fileno function.",
          "details": [
            "It receives a FILE* pointer (fp) as its argument and immediately returns the result of fileno(fp), performing a tail call.",
            "No additional processing, error handling, or side effects are present; it simply forwards the call to the imported fileno routine."
          ],
          "evidence_refs": [
            "imports:fileno",
            "call:0x422e58"
          ],
          "unknowns": [
            "The broader context in which this wrapper is used beyond the observed callers."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404b10",
      "original_name": "tcgetpgrp",
      "final_name": "ai_get_process_group_id",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e60"
        }
      ],
      "import_refs": [
        "tcgetpgrp"
      ],
      "string_refs": [],
      "constants": [
        "0x422e60"
      ],
      "snippets": {
        "asm": "  0x404b10  endbr64 \n  0x404b14  jmp     qword [rel tcgetpgrp]",
        "hlil": "return tcgetpgrp(fd) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return tcgetpgrp(fd);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_process_group_id",
          "confidence": 0.86,
          "rationale": "The function is a thin wrapper that directly calls the tcgetpgrp system call to retrieve the foreground process group ID for a given file descriptor.",
          "evidence_refs": [
            "imports:tcgetpgrp",
            "call:0x404b10",
            "call:0x422e60"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_tcgetpgrp_wrapper",
            "ai_get_tty_process_group"
          ]
        },
        "explain": {
          "summary": "The function at 0x404b10 is a thin wrapper that directly forwards its argument to the imported tcgetpgrp system call and returns its result.",
          "details": [
            "It receives a file descriptor (fd) and immediately returns the result of tcgetpgrp(fd), performing a tail call.",
            "No additional logic, string handling, or side effects are present in this function."
          ],
          "evidence_refs": [
            "imports:tcgetpgrp",
            "call:0x422e60"
          ],
          "unknowns": [
            "The specific context in which the fd argument is supplied."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404b20",
      "original_name": "readdir",
      "final_name": "ai_read_directory_entry",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e68"
        }
      ],
      "import_refs": [
        "readdir"
      ],
      "string_refs": [],
      "constants": [
        "0x422e68"
      ],
      "snippets": {
        "asm": "  0x404b20  endbr64 \n  0x404b24  jmp     qword [rel readdir]",
        "hlil": "return readdir(dirp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return readdir(dirp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_read_directory_entry",
          "confidence": 0.86,
          "rationale": "The function is a thin wrapper that directly calls the POSIX readdir API to retrieve the next entry from an opened directory stream.",
          "evidence_refs": [
            "imports:readdir",
            "call:0x404b20"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_readdir_wrapper",
            "ai_get_next_dir_entry"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its argument to the standard library readdir function and returns the result.",
          "details": [
            "It receives a DIR* pointer (dirp) as its argument.",
            "It performs a tail call to readdir(dirp) without any additional processing or side effects."
          ],
          "evidence_refs": [
            "imports:readdir",
            "call:0x422e68",
            "strings:none"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404b30",
      "original_name": "wcwidth",
      "final_name": "ai_wcwidth_wrapper",
      "score": 13.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 5,
      "callees": [
        {
          "addr": "0x422e70"
        }
      ],
      "import_refs": [
        "wcwidth"
      ],
      "string_refs": [],
      "constants": [
        "0x422e70"
      ],
      "snippets": {
        "asm": "  0x404b30  endbr64 \n  0x404b34  jmp     qword [rel wcwidth]",
        "hlil": "return wcwidth(ch) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return wcwidth(ch);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wcwidth_wrapper",
          "confidence": 0.95,
          "rationale": "The function directly forwards its argument to the imported wcwidth function, acting as a thin wrapper to compute the display width of a Unicode character.",
          "evidence_refs": [
            "imports:wcwidth"
          ],
          "tags": [],
          "alt_names": [
            "ai_unicode_char_width",
            "ai_get_display_width"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its argument to the imported wcwidth function and returns the result, effectively providing the display width of a wide character.",
          "details": [
            "It imports the wcwidth library function and makes a tail call to it with the provided character argument.",
            "No additional processing or logic is performed; the return value of wcwidth is passed back unchanged."
          ],
          "evidence_refs": [
            "imports:wcwidth",
            "call:0x422e70"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404b40",
      "original_name": "fflush",
      "final_name": "ai_flush_file_stream",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e78"
        }
      ],
      "import_refs": [
        "fflush"
      ],
      "string_refs": [],
      "constants": [
        "0x422e78"
      ],
      "snippets": {
        "asm": "  0x404b40  endbr64 \n  0x404b44  jmp     qword [rel fflush]",
        "hlil": "return fflush(fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fflush(fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_flush_file_stream",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the standard library fflush to flush a FILE* stream, indicating file I/O flushing behavior.",
          "evidence_refs": [
            "imports:fflush",
            "call:0x422e78"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_flush_stream",
            "ai_file_flush"
          ]
        },
        "explain": {
          "summary": "This function is a thin wrapper that directly calls the imported fflush function with the given FILE pointer and returns its result.",
          "details": [
            "It receives a FILE* argument (fp) and immediately returns the result of fflush(fp).",
            "The implementation is a tail-call, providing no additional logic beyond forwarding the call."
          ],
          "evidence_refs": [
            "imports:fflush",
            "call:0x422e78"
          ],
          "unknowns": [
            "No further side effects or error handling beyond the standard fflush behavior."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404b50",
      "original_name": "nl_langinfo",
      "final_name": "ai_get_locale_info",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422e80"
        }
      ],
      "import_refs": [
        "nl_langinfo"
      ],
      "string_refs": [],
      "constants": [
        "0x422e80"
      ],
      "snippets": {
        "asm": "  0x404b50  endbr64 \n  0x404b54  jmp     qword [rel nl_langinfo]",
        "hlil": "return nl_langinfo(item) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return nl_langinfo(item);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_locale_info",
          "confidence": 0.9,
          "rationale": "The function is a thin wrapper that directly calls the standard C library nl_langinfo to retrieve locale/language information, indicating its role in obtaining configuration/locale data.",
          "evidence_refs": [
            "imports:nl_langinfo",
            "call:0x404b50"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_nl_langinfo_wrapper",
            "ai_locale_info"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its argument to the system nl_langinfo function and returns the resulting locale information string.",
          "details": [
            "It receives an integer 'item' and immediately returns nl_langinfo(item) without any additional processing.",
            "The import list confirms nl_langinfo is the only external call, and neighboring functions use this wrapper to query locale encoding strings."
          ],
          "evidence_refs": [
            "imports:nl_langinfo",
            "call:0x404b50"
          ],
          "unknowns": [
            "Specific 'item' values used by callers beyond those observed in neighboring functions."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404b60",
      "original_name": "strcoll",
      "final_name": "ai_string_collate_wrapper",
      "score": 28.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 22,
      "callees": [
        {
          "addr": "0x422e88"
        }
      ],
      "import_refs": [
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x422e88"
      ],
      "snippets": {
        "asm": "  0x404b60  endbr64 \n  0x404b64  jmp     qword [rel strcoll]",
        "hlil": "return strcoll(s1, s2) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strcoll(s1, s2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_string_collate_wrapper",
          "confidence": 0.86,
          "rationale": "The function simply forwards its arguments to the standard library strcoll, acting as a thin wrapper for locale-aware string comparison.",
          "evidence_refs": [
            "imports:strcoll",
            "call:0x404b60"
          ],
          "tags": [],
          "alt_names": [
            "ai_locale_strcmp",
            "ai_strcoll_proxy"
          ]
        },
        "explain": {
          "summary": "The function at 0x404b60 is a thin wrapper that directly forwards its two arguments to the C library function strcoll and returns its result without any additional processing.",
          "details": [
            "Imports the standard library function strcoll.",
            "The implementation consists solely of a tail call: return strcoll(s1, s2);",
            "No string literals or extra logic are present in this function."
          ],
          "evidence_refs": [
            "imports:strcoll",
            "call:0x422e88"
          ],
          "unknowns": [
            "The broader context in which this wrapper is used within the program."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404b70",
      "original_name": "mktime",
      "final_name": "ai_mktime_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422e90"
        }
      ],
      "import_refs": [
        "mktime"
      ],
      "string_refs": [],
      "constants": [
        "0x422e90"
      ],
      "snippets": {
        "asm": "  0x404b70  endbr64 \n  0x404b74  jmp     qword [rel mktime]",
        "hlil": "return mktime(tp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return mktime(tp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_mktime_wrapper",
          "confidence": 0.96,
          "rationale": "Function is a thin wrapper that directly returns the result of the standard library mktime, converting a struct tm to a timestamp.",
          "evidence_refs": [
            "imports:mktime",
            "call:0x404b70"
          ],
          "tags": [],
          "alt_names": [
            "ai_time_struct_to_epoch",
            "ai_convert_tm_to_timestamp"
          ]
        },
        "explain": {
          "summary": "The function at 0x404b70 is a thin wrapper that directly forwards its argument to the standard library mktime function and returns the result. It performs no additional processing, acting as a simple passthrough.",
          "details": [
            "The implementation consists of a single tailcall: return mktime(tp);",
            "The only import referenced is mktime, and the call target address is 0x422e90."
          ],
          "evidence_refs": [
            "imports:mktime",
            "call:0x422e90"
          ],
          "unknowns": [
            "Purpose of the wrapper within the larger binary context"
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404b80",
      "original_name": "__freading",
      "final_name": "ai_file_is_reading",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422e98"
        }
      ],
      "import_refs": [
        "__freading"
      ],
      "string_refs": [],
      "constants": [
        "0x422e98"
      ],
      "snippets": {
        "asm": "  0x404b80  endbr64 \n  0x404b84  jmp     qword [rel __freading]",
        "hlil": "return __freading(fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __freading(fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_file_is_reading",
          "confidence": 0.82,
          "rationale": "The function simply tail-calls __freading on a FILE pointer, indicating it checks whether the stream is in read mode. This aligns with file I/O behavior of testing readability.",
          "evidence_refs": [
            "imports:__freading",
            "call:0x404b80"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_check_file_read_mode",
            "ai_is_file_readable"
          ]
        },
        "explain": {
          "summary": "The function at 0x404b80 is a thin wrapper that simply forwards its FILE* argument to the __freading routine and returns its result.",
          "details": [
            "It performs a tail call to __freading(fp) without any additional logic.",
            "The function imports __freading and has no other strings or constants, indicating it exists solely to expose or alias __freading."
          ],
          "evidence_refs": [
            "imports:__freading",
            "call:0x422e98"
          ],
          "unknowns": [
            "Why this wrapper exists (e.g., symbol aliasing or compatibility layer) is not determinable from the code alone."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404b90",
      "original_name": "fwrite_unlocked",
      "final_name": "ai_write_buffer_to_file",
      "score": 13.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 5,
      "callees": [
        {
          "addr": "0x422ea0"
        }
      ],
      "import_refs": [
        "fwrite_unlocked"
      ],
      "string_refs": [],
      "constants": [
        "0x422ea0"
      ],
      "snippets": {
        "asm": "  0x404b90  endbr64 \n  0x404b94  jmp     qword [rel fwrite_unlocked]",
        "hlil": "return fwrite_unlocked(buf, size, count, fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fwrite_unlocked(buf, size, count, fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_write_buffer_to_file",
          "confidence": 0.78,
          "rationale": "The function is a thin wrapper that directly tail-calls fwrite_unlocked to write a buffer to a FILE stream, indicating its role in generic file output.",
          "evidence_refs": [
            "imports:fwrite_unlocked",
            "call:0x404b90"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_fwrite_wrapper",
            "ai_write_data"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the imported fwrite_unlocked routine and returns its result, performing no additional processing.",
          "details": [
            "It receives parameters (buf, size, count, fp) and tail-calls fwrite_unlocked with the same arguments.",
            "The wrapper returns the value from fwrite_unlocked, acting as a simple pass-through."
          ],
          "evidence_refs": [
            "imports:fwrite_unlocked",
            "call:0x422ea0"
          ],
          "unknowns": [
            "Why this wrapper exists in the codebase (e.g., abstraction or compatibility layer)",
            "Any side effects beyond the fwrite_unlocked call"
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404ba0",
      "original_name": "realloc",
      "final_name": "ai_memory_realloc_wrapper",
      "score": 12.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 4,
      "callees": [
        {
          "addr": "0x422ea8"
        }
      ],
      "import_refs": [
        "realloc"
      ],
      "string_refs": [],
      "constants": [
        "0x422ea8"
      ],
      "snippets": {
        "asm": "  0x404ba0  endbr64 \n  0x404ba4  jmp     qword [rel realloc]",
        "hlil": "return realloc(ptr, n) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return realloc(ptr, n);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memory_realloc_wrapper",
          "confidence": 0.86,
          "rationale": "The function simply forwards its arguments to the standard realloc call, acting as a thin wrapper for memory resizing.",
          "evidence_refs": [
            "imports:realloc",
            "call:0x404ba0"
          ],
          "tags": [],
          "alt_names": [
            "ai_realloc",
            "ai_resize_buffer"
          ]
        },
        "explain": {
          "summary": "The function at 0x404ba0 is a thin wrapper that directly forwards its arguments to the standard realloc function and returns its result.",
          "details": [
            "It imports the realloc symbol and makes a tail call to realloc(ptr, n).",
            "No additional processing, error handling, or memory management is performed beyond the call."
          ],
          "evidence_refs": [
            "imports:realloc",
            "call:0x404ba0"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404bb0",
      "original_name": "__strcpy_chk",
      "final_name": "ai_safe_strcpy",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422eb0"
        }
      ],
      "import_refs": [
        "__strcpy_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422eb0"
      ],
      "snippets": {
        "asm": "  0x404bb0  endbr64 \n  0x404bb4  jmp     qword [rel __strcpy_chk]",
        "hlil": "return __strcpy_chk(dest, src, destlen) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __strcpy_chk(dest, src, destlen);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_safe_strcpy",
          "confidence": 0.95,
          "rationale": "Function is a thin wrapper that tail-calls __strcpy_chk, providing bounded string copy functionality.",
          "evidence_refs": [
            "imports:__strcpy_chk",
            "call:0x422eb0"
          ],
          "tags": [],
          "alt_names": [
            "ai_strcpy_chk_wrapper",
            "ai_copy_string_checked"
          ]
        },
        "explain": {
          "summary": "The function at 0x404bb0 is a thin wrapper that forwards its three arguments to the imported __strcpy_chk routine, performing a safe string copy with length checking.",
          "details": [
            "It receives dest, src, and destlen parameters and immediately returns the result of __strcpy_chk(dest, src, destlen).",
            "Neighbor functions use this wrapper to safely copy user and group name strings into allocated buffers, indicating its role in bounded string copying."
          ],
          "evidence_refs": [
            "imports:__strcpy_chk",
            "call:0x422eb0"
          ],
          "unknowns": [
            "Exact source of destlen value passed by callers"
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404bc0",
      "original_name": "setlocale",
      "final_name": "ai_set_locale_wrapper",
      "score": 12.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 4,
      "callees": [
        {
          "addr": "0x422eb8"
        }
      ],
      "import_refs": [
        "setlocale"
      ],
      "string_refs": [],
      "constants": [
        "0x422eb8"
      ],
      "snippets": {
        "asm": "  0x404bc0  endbr64 \n  0x404bc4  jmp     qword [rel setlocale]",
        "hlil": "return setlocale(category, locale, arg3, arg4, arg5, arg6, category, category) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return setlocale(category, locale, arg3, arg4, arg5, arg6, category, category);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_locale_wrapper",
          "confidence": 0.87,
          "rationale": "The function directly tail-calls the C library setlocale with passed parameters, acting as a thin wrapper for locale initialization/configuration.",
          "evidence_refs": [
            "imports:setlocale",
            "call:0x404bc0",
            "constants:0x422eb8"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_locale_init",
            "ai_setlocale_proxy"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its parameters to the imported setlocale function, returning its result without additional processing.",
          "details": [
            "It performs a tail call to setlocale, passing the original category and locale arguments along with extra repeated category arguments.",
            "No other logic, string handling, or side effects are present; it simply returns the result of the setlocale call."
          ],
          "evidence_refs": [
            "imports:setlocale",
            "call:0x404bc0"
          ],
          "unknowns": [
            "Purpose of the extra arguments (arg3arg6 and repeated category) passed to setlocale, which normally expects only two parameters."
          ],
          "confidence": 0.92
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404bd0",
      "original_name": "__printf_chk",
      "final_name": "ai_printf_chk_wrapper",
      "score": 21.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 13,
      "callees": [
        {
          "addr": "0x422ec0"
        }
      ],
      "import_refs": [
        "__printf_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422ec0"
      ],
      "snippets": {
        "asm": "  0x404bd0  endbr64 \n  0x404bd4  jmp     qword [rel __printf_chk]",
        "hlil": "return __printf_chk(flag, format) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __printf_chk(flag, format);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_printf_chk_wrapper",
          "confidence": 0.86,
          "rationale": "The function simply forwards its arguments to __printf_chk, acting as a thin wrapper for formatted output.",
          "evidence_refs": [
            "imports:__printf_chk",
            "call:0x404bd0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_output_formatted",
            "ai_print_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the imported __printf_chk function and returns its result.",
          "details": [
            "It performs a tail-call to __printf_chk with the provided flag and format parameters.",
            "No additional processing or logic is performed; it simply passes control to the standard library's __printf_chk implementation."
          ],
          "evidence_refs": [
            "imports:__printf_chk",
            "call:0x422ec0"
          ],
          "unknowns": [
            "The specific meaning of the 'flag' argument in this context."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404be0",
      "original_name": "statx",
      "final_name": "ai_statx_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422ec8"
        }
      ],
      "import_refs": [
        "statx"
      ],
      "string_refs": [],
      "constants": [
        "0x422ec8"
      ],
      "snippets": {
        "asm": "  0x404be0  endbr64 \n  0x404be4  jmp     qword [rel statx]",
        "hlil": "return statx(fd, __arg2, flags, mask) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return statx(fd, __arg2, flags, mask);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_statx_wrapper",
          "confidence": 0.96,
          "rationale": "The function directly forwards its arguments to the statx system call, acting as a thin wrapper for file metadata retrieval.",
          "evidence_refs": [
            "imports:statx"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_get_file_stats",
            "ai_file_stat"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the imported statx system call and returns the result without any additional processing.",
          "details": [
            "It performs a tail call to statx with parameters (fd, __arg2, flags, mask).",
            "No other logic, string handling, or data manipulation is performed within this function."
          ],
          "evidence_refs": [
            "imports:statx",
            "call:0x422ec8"
          ],
          "unknowns": [
            "Exact meaning of the arguments (__arg2, flags, mask) in the broader program context"
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404bf0",
      "original_name": "timegm",
      "final_name": "ai_utc_timestamp_from_tm",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422ed0"
        }
      ],
      "import_refs": [
        "timegm"
      ],
      "string_refs": [],
      "constants": [
        "0x422ed0"
      ],
      "snippets": {
        "asm": "  0x404bf0  endbr64 \n  0x404bf4  jmp     qword [rel timegm]",
        "hlil": "return timegm(tmp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return timegm(tmp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_utc_timestamp_from_tm",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the standard library timegm to convert a struct tm (UTC) to a Unix timestamp.",
          "evidence_refs": [
            "imports:timegm"
          ],
          "tags": [],
          "alt_names": [
            "ai_timegm_wrapper",
            "ai_convert_tm_to_epoch"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its argument to the imported timegm function, returning its result.",
          "details": [
            "The implementation consists of a single tailcall: return timegm(tmp);",
            "It imports the standard library timegm function and calls it at address 0x422ed0."
          ],
          "evidence_refs": [
            "imports:timegm",
            "call:0x422ed0"
          ],
          "unknowns": [
            "Exact type and source of the argument 'tmp' (likely a struct tm pointer)",
            "Why this wrapper exists in the binary (potential abstraction or compatibility layer)"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404c00",
      "original_name": "strftime",
      "final_name": "ai_format_timestamp",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422ed8"
        }
      ],
      "import_refs": [
        "strftime"
      ],
      "string_refs": [],
      "constants": [
        "0x422ed8"
      ],
      "snippets": {
        "asm": "  0x404c00  endbr64 \n  0x404c04  jmp     qword [rel strftime]",
        "hlil": "return strftime(s, maxsize, format, tp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strftime(s, maxsize, format, tp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_format_timestamp",
          "confidence": 0.86,
          "rationale": "The function is a thin wrapper that directly calls the C library strftime to format date/time strings, indicating its role in generating timestamps.",
          "evidence_refs": [
            "imports:strftime",
            "call:0x422ed8"
          ],
          "tags": [],
          "alt_names": [
            "ai_strftime_wrapper",
            "ai_timestamp_generator"
          ]
        },
        "explain": {
          "summary": "The function at 0x404c00 is a thin wrapper that directly forwards its arguments to the standard library strftime function and returns its result.",
          "details": [
            "It receives parameters (s, maxsize, format, tp) and performs a tail call to the imported strftime.",
            "No additional processing or logic is performed before or after the call."
          ],
          "evidence_refs": [
            "imports:strftime",
            "call:0x422ed8"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404c10",
      "original_name": "mempcpy",
      "final_name": "ai_memcpy_wrapper",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422ee0"
        }
      ],
      "import_refs": [
        "mempcpy"
      ],
      "string_refs": [],
      "constants": [
        "0x422ee0"
      ],
      "snippets": {
        "asm": "  0x404c10  endbr64 \n  0x404c14  jmp     qword [rel mempcpy]",
        "hlil": "return mempcpy(arg1, arg2, arg3) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return mempcpy(arg1, arg2, arg3);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memcpy_wrapper",
          "confidence": 0.85,
          "rationale": "The function is a thin wrapper that directly tail-calls the standard mempcpy library routine, indicating its role is to copy memory blocks and return a pointer to the end of the destination.",
          "evidence_refs": [
            "imports:mempcpy",
            "call:0x404c10"
          ],
          "tags": [],
          "alt_names": [
            "ai_copy_memory",
            "ai_mempcpy_proxy"
          ]
        },
        "explain": {
          "summary": "The function at 0x404c10 is a thin wrapper that directly forwards its three arguments to the imported mempcpy routine and returns its result.",
          "details": [
            "It performs a tail call to mempcpy(arg1, arg2, arg3) without any additional processing.",
            "The function imports mempcpy and its only callee is at address 0x422ee0, indicating it simply delegates to the standard library implementation."
          ],
          "evidence_refs": [
            "imports:mempcpy",
            "call:0x422ee0"
          ],
          "unknowns": [
            "The broader context or reason for providing this wrapper within the binary."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404c20",
      "original_name": "memmove",
      "final_name": "ai_memmove_wrapper",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422ee8"
        }
      ],
      "import_refs": [
        "memmove"
      ],
      "string_refs": [],
      "constants": [
        "0x422ee8"
      ],
      "snippets": {
        "asm": "  0x404c20  endbr64 \n  0x404c24  jmp     qword [rel memmove]",
        "hlil": "return memmove(arg1, arg2, arg3) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return memmove(arg1, arg2, arg3);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memmove_wrapper",
          "confidence": 0.96,
          "rationale": "The function directly forwards its arguments to the standard memmove import, acting as a thin wrapper for memory copying.",
          "evidence_refs": [
            "imports:memmove"
          ],
          "tags": [],
          "alt_names": [
            "ai_copy_memory",
            "ai_memcpy_wrapper"
          ]
        },
        "explain": {
          "summary": "The function at 0x404c20 is a thin wrapper that directly forwards its three arguments to the standard library memmove function and returns the result. It performs no additional processing or checks.",
          "details": [
            "Accepts three parameters: destination pointer, source pointer, and number of bytes to move.",
            "Calls the imported memmove function with these arguments and returns its return value."
          ],
          "evidence_refs": [
            "imports:memmove",
            "call:0x422ee8"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404c30",
      "original_name": "error",
      "final_name": "ai_error_handler",
      "score": 24.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 16,
      "callees": [
        {
          "addr": "0x422ef0"
        }
      ],
      "import_refs": [
        "error"
      ],
      "string_refs": [],
      "constants": [
        "0x422ef0"
      ],
      "snippets": {
        "asm": "  0x404c30  endbr64 \n  0x404c34  jmp     qword [rel error]",
        "hlil": "return error(status, errnum, message) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return error(status, errnum, message);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_error_handler",
          "confidence": 0.93,
          "rationale": "The function simply forwards its arguments to the imported 'error' function, acting as a thin wrapper for error reporting.",
          "evidence_refs": [
            "imports:error",
            "call:0x422ef0"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_report_error",
            "ai_error_report"
          ]
        },
        "explain": {
          "summary": "The function at 0x404c30 is a thin wrapper that forwards its arguments to the imported GNU error() routine, effectively delegating error handling to that library function.",
          "details": [
            "It receives parameters (status, errnum, message) and performs a tail call to error(status, errnum, message).",
            "The imported error function typically prints a formatted error message to stderr and may terminate the program based on the status argument."
          ],
          "evidence_refs": [
            "imports:error",
            "call:0x422ef0"
          ],
          "unknowns": [
            "Exact side effects of the error() call (e.g., whether it exits the process for nonzero status).",
            "The source of the status, errnum, and message values passed to this wrapper."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404c40",
      "original_name": "fseeko",
      "final_name": "ai_file_seek",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422ef8"
        }
      ],
      "import_refs": [
        "fseeko"
      ],
      "string_refs": [],
      "constants": [
        "0x422ef8"
      ],
      "snippets": {
        "asm": "  0x404c40  endbr64 \n  0x404c44  jmp     qword [rel fseeko]",
        "hlil": "return fseeko(fp, offset, whence) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fseeko(fp, offset, whence);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_file_seek",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls fseeko to reposition a file pointer, indicating file seeking behavior.",
          "evidence_refs": [
            "imports:fseeko",
            "call:0x404c40"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_fseek_wrapper",
            "ai_seek_file"
          ]
        },
        "explain": {
          "summary": "The function at 0x404c40 is a thin wrapper that directly forwards its arguments to the standard library fseeko function and returns its result.",
          "details": [
            "It imports the fseeko symbol and makes a tail-call to it with the same parameters (fp, offset, whence).",
            "No additional logic, checks, or side effects are performed; it simply returns the value from fseeko."
          ],
          "evidence_refs": [
            "imports:fseeko",
            "call:0x422ef8"
          ],
          "unknowns": [
            "The reason for providing this wrapper (e.g., abstraction layer or compatibility shim) is not evident from the code."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404c50",
      "original_name": "unsetenv",
      "final_name": "ai_unset_environment_variable",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422f00"
        }
      ],
      "import_refs": [
        "unsetenv"
      ],
      "string_refs": [],
      "constants": [
        "0x422f00"
      ],
      "snippets": {
        "asm": "  0x404c50  endbr64 \n  0x404c54  jmp     qword [rel unsetenv]",
        "hlil": "return unsetenv(name) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return unsetenv(name);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_unset_environment_variable",
          "confidence": 0.97,
          "rationale": "The function is a thin wrapper that directly calls the libc unsetenv() to remove an environment variable, indicating behavior of clearing environment settings.",
          "evidence_refs": [
            "imports:unsetenv",
            "call:0x404c50"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_clear_env_var",
            "ai_remove_env"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards its argument to the system unsetenv call and returns the result.",
          "details": [
            "It takes a single argument (the environment variable name) and immediately calls the imported unsetenv function with that argument.",
            "The function performs no additional logic, checks, or error handling beyond the tailcall to unsetenv."
          ],
          "evidence_refs": [
            "imports:unsetenv",
            "call:0x422f00"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x404c60",
      "original_name": "__cxa_atexit",
      "final_name": "ai_register_exit_handler",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422f08"
        }
      ],
      "import_refs": [
        "__cxa_atexit"
      ],
      "string_refs": [],
      "constants": [
        "0x422f08"
      ],
      "snippets": {
        "asm": "  0x404c60  endbr64 \n  0x404c64  jmp     qword [rel __cxa_atexit]",
        "hlil": "return __cxa_atexit(func, arg, dso_handle) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __cxa_atexit(func, arg, dso_handle);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_register_exit_handler",
          "confidence": 0.86,
          "rationale": "Wrapper that forwards arguments to __cxa_atexit, registering a function to be called on program termination.",
          "evidence_refs": [
            "imports:__cxa_atexit",
            "call:0x404c60"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_atexit_wrapper",
            "ai_register_atexit_callback"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that registers a cleanup routine to be called on program termination by forwarding its arguments to the C++ runtime __cxa_atexit.",
          "details": [
            "It receives a function pointer (func), an argument (arg), and a DSO handle, then tailcalls the imported __cxa_atexit with those parameters.",
            "The return value of __cxa_atexit is directly returned, indicating no additional processing."
          ],
          "evidence_refs": [
            "imports:__cxa_atexit",
            "call:0x422f08"
          ],
          "unknowns": [],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404c70",
      "original_name": "wcstombs",
      "final_name": "ai_wide_to_multibyte",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422f10"
        }
      ],
      "import_refs": [
        "wcstombs"
      ],
      "string_refs": [],
      "constants": [
        "0x422f10"
      ],
      "snippets": {
        "asm": "  0x404c70  endbr64 \n  0x404c74  jmp     qword [rel wcstombs]",
        "hlil": "return wcstombs(s, pwcs, n) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return wcstombs(s, pwcs, n);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_wide_to_multibyte",
          "confidence": 0.93,
          "rationale": "The function is a thin wrapper that directly calls the standard wcstombs API to convert a wide-character string to a multibyte string.",
          "evidence_refs": [
            "imports:wcstombs",
            "call:0x404c70"
          ],
          "tags": [],
          "alt_names": [
            "ai_wchar_to_mb",
            "ai_unicode_to_ascii"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the standard library wcstombs function and returns its result, performing a wide-character to multibyte string conversion.",
          "details": [
            "It imports the wcstombs symbol and makes a tail call to it with parameters (s, pwcs, n).",
            "No additional logic, string literals, or error handling is present; it simply returns the wcstombs return value."
          ],
          "evidence_refs": [
            "imports:wcstombs",
            "call:0x422f10"
          ],
          "unknowns": [
            "The surrounding context in which this wrapper is used (e.g., caller expectations or error handling) is not shown."
          ],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404c80",
      "original_name": "getxattr",
      "final_name": "ai_get_extended_attribute",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422f18"
        }
      ],
      "import_refs": [
        "getxattr"
      ],
      "string_refs": [],
      "constants": [
        "0x422f18"
      ],
      "snippets": {
        "asm": "  0x404c80  endbr64 \n  0x404c84  jmp     qword [rel getxattr]",
        "hlil": "return getxattr() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return getxattr();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_extended_attribute",
          "confidence": 0.96,
          "rationale": "Function is a thin wrapper that directly tail-calls the getxattr system/library call, indicating it retrieves file extended attributes.",
          "evidence_refs": [
            "imports:getxattr",
            "call:0x422f18"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_get_xattr",
            "ai_file_xattr"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards execution to the imported getxattr routine and returns its result without any additional processing.",
          "details": [
            "It performs a tail call to the getxattr import, effectively acting as a passthrough.",
            "No strings, constants, or extra logic are present, indicating it simply forwards arguments to the system getxattr call."
          ],
          "evidence_refs": [
            "imports:getxattr",
            "call:0x422f18"
          ],
          "unknowns": [
            "Exact arguments passed to getxattr (register usage) are not shown in the snippet",
            "Context of how this wrapper is used within the larger program"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404c90",
      "original_name": "gethostname",
      "final_name": "ai_get_hostname",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422f20"
        }
      ],
      "import_refs": [
        "gethostname"
      ],
      "string_refs": [],
      "constants": [
        "0x422f20"
      ],
      "snippets": {
        "asm": "  0x404c90  endbr64 \n  0x404c94  jmp     qword [rel gethostname]",
        "hlil": "return gethostname(name, len) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return gethostname(name, len);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_hostname",
          "confidence": 0.96,
          "rationale": "The function directly forwards its arguments to the imported gethostname API, acting as a thin wrapper to retrieve the system's hostname.",
          "evidence_refs": [
            "imports:gethostname",
            "call:0x404c90"
          ],
          "tags": [
            "networking"
          ],
          "alt_names": [
            "ai_retrieve_hostname",
            "ai_fetch_hostname"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the imported gethostname system call and returns its result.",
          "details": [
            "It receives parameters (name, len) and performs a tail call to gethostname.",
            "No additional processing, validation, or error handling is performed."
          ],
          "evidence_refs": [
            "imports:gethostname",
            "call:0x422f20"
          ],
          "unknowns": [
            "Potential side effects of the underlying gethostname implementation"
          ],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": [
        "networking"
      ]
    },
    {
      "addr": "0x404ca0",
      "original_name": "sigismember",
      "final_name": "ai_check_signal_membership",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422f28"
        }
      ],
      "import_refs": [
        "sigismember"
      ],
      "string_refs": [],
      "constants": [
        "0x422f28"
      ],
      "snippets": {
        "asm": "  0x404ca0  endbr64 \n  0x404ca4  jmp     qword [rel sigismember]",
        "hlil": "return sigismember(set, signo) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sigismember(set, signo);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_check_signal_membership",
          "confidence": 0.88,
          "rationale": "The function is a thin wrapper that directly calls the imported sigismember API to test if a signal number is present in a signal set, indicating signal set membership checking.",
          "evidence_refs": [
            "imports:sigismember",
            "call:0x404ca0"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_signal_set_member",
            "ai_is_signal_in_set"
          ]
        },
        "explain": {
          "summary": "The function at 0x404ca0 is a thin wrapper that directly forwards its arguments to the imported sigismember library function and returns its result.",
          "details": [
            "It receives parameters 'set' and 'signo' and performs a tail-call to sigismember(set, signo).",
            "No additional processing or logic is performed; it simply returns the result of the library call."
          ],
          "evidence_refs": [
            "imports:sigismember",
            "call:0x422f28"
          ],
          "unknowns": [],
          "confidence": 1.0
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404cb0",
      "original_name": "exit",
      "final_name": "ai_exit_wrapper",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422f30"
        }
      ],
      "import_refs": [
        "exit"
      ],
      "string_refs": [],
      "constants": [
        "0x422f30"
      ],
      "snippets": {
        "asm": "  0x404cb0  endbr64 \n  0x404cb4  jmp     qword [rel exit]\n  0x404cb4  { Does not return }",
        "hlil": "noreturn exit(status) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return exit(status);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_exit_wrapper",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the imported exit() function to terminate the process.",
          "evidence_refs": [
            "imports:exit",
            "call:0x422f30"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_terminate_process",
            "ai_exit_call"
          ]
        },
        "explain": {
          "summary": "The function at 0x404cb0 is a thin wrapper that directly forwards its argument to the standard library exit function, terminating the process with the given status.",
          "details": [
            "It performs a tail call to exit(status), with no additional logic or cleanup.",
            "The function imports the exit symbol and its only callee address is 0x422f30, which resolves to the actual exit implementation."
          ],
          "evidence_refs": [
            "imports:exit",
            "call:0x422f30"
          ],
          "unknowns": [
            "The origin of the status argument passed to this wrapper is not shown in the provided snippet."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404cc0",
      "original_name": "fwrite",
      "final_name": "ai_fwrite_wrapper",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422f38"
        }
      ],
      "import_refs": [
        "fwrite"
      ],
      "string_refs": [],
      "constants": [
        "0x422f38"
      ],
      "snippets": {
        "asm": "  0x404cc0  endbr64 \n  0x404cc4  jmp     qword [rel fwrite]",
        "hlil": "return fwrite(buf, size, count, fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fwrite(buf, size, count, fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_fwrite_wrapper",
          "confidence": 0.97,
          "rationale": "The function directly forwards its arguments to the standard library fwrite, acting as a thin wrapper for writing buffers to a file stream.",
          "evidence_refs": [
            "imports:fwrite",
            "call:0x404cc0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_write_buffer_to_file",
            "ai_file_write"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the standard library fwrite and returns its result.",
          "details": [
            "It receives parameters (buf, size, count, fp) and performs a tailcall to fwrite with the same arguments.",
            "No additional processing, checks, or transformations are performed before calling fwrite."
          ],
          "evidence_refs": [
            "imports:fwrite",
            "call:0x422f38"
          ],
          "unknowns": [
            "The broader context or reason why this wrapper exists in the program."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404cd0",
      "original_name": "__fprintf_chk",
      "final_name": "ai_safe_fprintf_wrapper",
      "score": 25.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 17,
      "callees": [
        {
          "addr": "0x422f40"
        }
      ],
      "import_refs": [
        "__fprintf_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422f40"
      ],
      "snippets": {
        "asm": "  0x404cd0  endbr64 \n  0x404cd4  jmp     qword [rel __fprintf_chk]",
        "hlil": "return __fprintf_chk(fp, flag, format) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __fprintf_chk(fp, flag, format);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_safe_fprintf_wrapper",
          "confidence": 0.86,
          "rationale": "The function simply forwards its arguments to __fprintf_chk, acting as a thin wrapper for safe formatted output to a file stream.",
          "evidence_refs": [
            "imports:__fprintf_chk"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_fprintf_wrapper",
            "ai_print_formatted_output"
          ]
        },
        "explain": {
          "summary": "The function at 0x404cd0 is a thin wrapper that directly forwards its arguments to the imported __fprintf_chk function and returns its result. It performs no additional processing, acting solely as a tail-call to the standard library's checked fprintf implementation.",
          "details": [
            "Accepts a FILE pointer (fp), a flag, and a format string, then calls __fprintf_chk(fp, flag, format).",
            "The function imports __fprintf_chk and contains no other logic or string handling."
          ],
          "evidence_refs": [
            "imports:__fprintf_chk",
            "call:0x404cd0"
          ],
          "unknowns": [
            "The specific purpose of the flag argument in this context.",
            "The role of the constant 0x422f40 listed in the metadata."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404ce0",
      "original_name": "getfilecon",
      "final_name": "ai_get_file_security_context",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422f48"
        }
      ],
      "import_refs": [
        "getfilecon"
      ],
      "string_refs": [],
      "constants": [
        "0x422f48"
      ],
      "snippets": {
        "asm": "  0x404ce0  endbr64 \n  0x404ce4  jmp     qword [rel getfilecon]",
        "hlil": "return getfilecon() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return getfilecon();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_file_security_context",
          "confidence": 0.86,
          "rationale": "The function is a thin wrapper that directly calls the imported SELinux API getfilecon, which retrieves a file's security context.",
          "evidence_refs": [
            "imports:getfilecon",
            "call:0x404ce0"
          ],
          "tags": [
            "file_io",
            "config"
          ],
          "alt_names": [
            "ai_selinux_getfilecon",
            "ai_get_file_context"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly tailcalls the imported getfilecon routine and returns its result without any additional logic.",
          "details": [
            "It contains a single instruction that performs a tail call to the imported getfilecon function.",
            "No local processing, string handling, or other operations are performed; it simply forwards control to getfilecon."
          ],
          "evidence_refs": [
            "imports:getfilecon",
            "call:0x422f48"
          ],
          "unknowns": [
            "Whether any arguments are prepared or passed to getfilecon before the call (the wrapper shows no explicit argument handling)."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "file_io",
        "config"
      ]
    },
    {
      "addr": "0x404cf0",
      "original_name": "fflush_unlocked",
      "final_name": "ai_flush_file_stream",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422f50"
        }
      ],
      "import_refs": [
        "fflush_unlocked"
      ],
      "string_refs": [],
      "constants": [
        "0x422f50"
      ],
      "snippets": {
        "asm": "  0x404cf0  endbr64 \n  0x404cf4  jmp     qword [rel fflush_unlocked]",
        "hlil": "return fflush_unlocked(fp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return fflush_unlocked(fp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_flush_file_stream",
          "confidence": 0.95,
          "rationale": "The function is a thin wrapper that directly calls fflush_unlocked on a FILE pointer, indicating its role is to flush output buffers.",
          "evidence_refs": [
            "imports:fflush_unlocked",
            "call:0x422f50"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_flush_output",
            "ai_flush_stdout"
          ]
        },
        "explain": {
          "summary": "The function at 0x404cf0 is a thin wrapper that directly forwards its FILE* argument to the imported fflush_unlocked and returns the result.",
          "details": [
            "It imports the standard library function fflush_unlocked.",
            "The implementation consists solely of a tail call: return fflush_unlocked(fp);",
            "No additional processing, error handling, or side effects are performed."
          ],
          "evidence_refs": [
            "imports:fflush_unlocked",
            "call:0x422f50"
          ],
          "unknowns": [
            "Reason for providing a wrapper instead of calling fflush_unlocked directly in callers."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404d00",
      "original_name": "mbsinit",
      "final_name": "ai_check_multibyte_state",
      "score": 11.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 3,
      "callees": [
        {
          "addr": "0x422f58"
        }
      ],
      "import_refs": [
        "mbsinit"
      ],
      "string_refs": [],
      "constants": [
        "0x422f58"
      ],
      "snippets": {
        "asm": "  0x404d00  endbr64 \n  0x404d04  jmp     qword [rel mbsinit]",
        "hlil": "return mbsinit(ps) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return mbsinit(ps);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_check_multibyte_state",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly returns the result of the standard library call mbsinit, which checks if a multibyte conversion state is in its initial state.",
          "evidence_refs": [
            "imports:mbsinit",
            "call:0x422f58"
          ],
          "tags": [],
          "alt_names": [
            "ai_mbs_state_init_check",
            "ai_mbsinit_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its argument to the standard library function mbsinit and returns its result.",
          "details": [
            "The implementation consists of a single tail-call to mbsinit(ps), indicating no additional processing.",
            "The function imports mbsinit and its only callee is at address 0x422f58, which is the imported mbsinit routine."
          ],
          "evidence_refs": [
            "imports:mbsinit",
            "call:0x422f58"
          ],
          "unknowns": [
            "The broader context in which this wrapper is used within the binary."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404d10",
      "original_name": "lgetfilecon",
      "final_name": "ai_get_file_security_context",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422f60"
        }
      ],
      "import_refs": [
        "lgetfilecon"
      ],
      "string_refs": [],
      "constants": [
        "0x422f60"
      ],
      "snippets": {
        "asm": "  0x404d10  endbr64 \n  0x404d14  jmp     qword [rel lgetfilecon]",
        "hlil": "return lgetfilecon() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return lgetfilecon();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_file_security_context",
          "confidence": 0.95,
          "rationale": "Function is a thin wrapper that tail-calls the imported SELinux API lgetfilecon, which retrieves a file's security context.",
          "evidence_refs": [
            "imports:lgetfilecon"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_selinux_get_file_context",
            "ai_retrieve_file_context"
          ]
        },
        "explain": {
          "summary": "The function at 0x404d10 is a thin wrapper that directly tailcalls the imported lgetfilecon routine and returns its result without any additional processing.",
          "details": [
            "The only operation in the function is a tailcall to lgetfilecon, indicating it forwards arguments unchanged.",
            "No strings or extra logic are present, suggesting it serves as an alias or compatibility shim for the library call."
          ],
          "evidence_refs": [
            "imports:lgetfilecon",
            "call:0x422f60"
          ],
          "unknowns": [
            "Exact arguments passed to lgetfilecon (register state) are not shown in the snippet."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x404d20",
      "original_name": "iswprint",
      "final_name": "ai_is_wide_printable",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422f68"
        }
      ],
      "import_refs": [
        "iswprint"
      ],
      "string_refs": [],
      "constants": [
        "0x422f68"
      ],
      "snippets": {
        "asm": "  0x404d20  endbr64 \n  0x404d24  jmp     qword [rel iswprint]",
        "hlil": "return iswprint(wc) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return iswprint(wc);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_is_wide_printable",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the imported iswprint to determine if a wide character is printable.",
          "evidence_refs": [
            "imports:iswprint",
            "call:0x404d20"
          ],
          "tags": [],
          "alt_names": [
            "ai_check_wide_printable",
            "ai_iswprint_wrapper"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards its wide character argument to the imported C library function iswprint and returns its result, effectively checking if the character is printable.",
          "details": [
            "It performs a tail call to the imported iswprint function with the provided wide character argument.",
            "No additional processing, checks, or side effects are performed within this wrapper."
          ],
          "evidence_refs": [
            "imports:iswprint",
            "call:0x422f68"
          ],
          "unknowns": [
            "Potential locale-specific behavior is delegated to the imported iswprint implementation."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404d30",
      "original_name": "sigaddset",
      "final_name": "ai_add_signal_to_set",
      "score": 9.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422f70"
        }
      ],
      "import_refs": [
        "sigaddset"
      ],
      "string_refs": [],
      "constants": [
        "0x422f70"
      ],
      "snippets": {
        "asm": "  0x404d30  endbr64 \n  0x404d34  jmp     qword [rel sigaddset]",
        "hlil": "return sigaddset(set, signo) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sigaddset(set, signo);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_add_signal_to_set",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the imported sigaddset to add a signal number to a signal set, indicating signal handling behavior.",
          "evidence_refs": [
            "imports:sigaddset",
            "call:0x422f70"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_sigaddset_wrapper",
            "ai_signal_set_add"
          ]
        },
        "explain": {
          "summary": "The function at 0x404d30 is a thin wrapper that directly forwards its arguments to the imported sigaddset library function and returns its result.",
          "details": [
            "The body consists of a tailcall returning sigaddset(set, signo), indicating no additional processing.",
            "It imports the sigaddset symbol and calls it at address 0x422f70."
          ],
          "evidence_refs": [
            "imports:sigaddset",
            "call:0x422f70"
          ],
          "unknowns": [],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x404d40",
      "original_name": "__ctype_tolower_loc",
      "final_name": "ai_get_locale_tolower_table",
      "score": 10.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 2,
      "callees": [
        {
          "addr": "0x422f78"
        }
      ],
      "import_refs": [
        "__ctype_tolower_loc"
      ],
      "string_refs": [],
      "constants": [
        "0x422f78"
      ],
      "snippets": {
        "asm": "  0x404d40  endbr64 \n  0x404d44  jmp     qword [rel __ctype_tolower_loc]",
        "hlil": "return __ctype_tolower_loc() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __ctype_tolower_loc();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_locale_tolower_table",
          "confidence": 0.78,
          "rationale": "The function simply forwards to __ctype_tolower_loc, which returns a pointer to the locale-specific lower-case character mapping table.",
          "evidence_refs": [
            "imports:__ctype_tolower_loc",
            "call:0x404d40"
          ],
          "tags": [],
          "alt_names": [
            "ai_get_ctype_lower_table",
            "ai_locale_tolower"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that simply forwards the call to the imported __ctype_tolower_loc and returns its result.",
          "details": [
            "It contains only a tailcall to __ctype_tolower_loc, indicating no additional processing.",
            "The function likely exists to provide an indirect reference or to match a specific calling convention."
          ],
          "evidence_refs": [
            "imports:__ctype_tolower_loc",
            "call:0x422f78"
          ],
          "unknowns": [
            "Why this wrapper exists in the binary's design or any side effects beyond the call."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404d50",
      "original_name": "__ctype_b_loc",
      "final_name": "ai_get_ctype_table",
      "score": 14.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 6,
      "callees": [
        {
          "addr": "0x422f80"
        }
      ],
      "import_refs": [
        "__ctype_b_loc"
      ],
      "string_refs": [],
      "constants": [
        "0x422f80"
      ],
      "snippets": {
        "asm": "  0x404d50  endbr64 \n  0x404d54  jmp     qword [rel __ctype_b_loc]",
        "hlil": "return __ctype_b_loc() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __ctype_b_loc();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_ctype_table",
          "confidence": 0.87,
          "rationale": "The function is a thin wrapper that directly returns the result of __ctype_b_loc, which provides a pointer to the locale's character classification table.",
          "evidence_refs": [
            "imports:__ctype_b_loc",
            "call:0x404d50"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_ctype_loc",
            "ai_locale_ctype_lookup"
          ]
        },
        "explain": {
          "summary": "The function at 0x404d50 is a thin wrapper that simply forwards to the imported __ctype_b_loc function and returns its result, providing access to the locale's character classification table.",
          "details": [
            "The implementation consists of a single tailcall: return __ctype_b_loc();",
            "It imports __ctype_b_loc and calls it at address 0x422f80, returning the pointer to the ctype bitmap."
          ],
          "evidence_refs": [
            "imports:__ctype_b_loc",
            "call:0x422f80"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x404d60",
      "original_name": "__sprintf_chk",
      "final_name": "ai_sprintf_wrapper",
      "score": 17.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 9,
      "callees": [
        {
          "addr": "0x422f88"
        }
      ],
      "import_refs": [
        "__sprintf_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x422f88"
      ],
      "snippets": {
        "asm": "  0x404d60  endbr64 \n  0x404d64  jmp     qword [rel __sprintf_chk]",
        "hlil": "return __sprintf_chk(s, flag, slen, format) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __sprintf_chk(s, flag, slen, format);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_sprintf_wrapper",
          "confidence": 0.86,
          "rationale": "The function simply forwards its arguments to the imported __sprintf_chk, acting as a thin wrapper for safe string formatting.",
          "evidence_refs": [
            "imports:__sprintf_chk"
          ],
          "tags": [],
          "alt_names": [
            "ai_safe_sprintf",
            "ai_format_string"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that directly forwards its arguments to the standard library __sprintf_chk, performing a tail-call without additional processing.",
          "details": [
            "It receives parameters (s, flag, slen, format) and immediately returns the result of __sprintf_chk with those same arguments.",
            "No extra logic, string handling, or memory operations are performed within this function; it serves as a simple alias or wrapper."
          ],
          "evidence_refs": [
            "imports:__sprintf_chk",
            "call:0x422f88"
          ],
          "unknowns": [
            "The specific purpose of the wrapper in the broader program context and the meaning of the flag and slen parameters."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x404da0",
      "original_name": "main",
      "final_name": "ai_ls_initialize",
      "score": 533.0,
      "bb_count": 381,
      "insn_est": 1641,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404970",
          "name": "ai_strrchr_wrapper",
          "original_name": "strrchr"
        },
        {
          "addr": "0x404770",
          "name": "ai_strncmp_wrapper",
          "original_name": "strncmp"
        },
        {
          "addr": "0x404bc0",
          "name": "ai_set_locale_wrapper",
          "original_name": "setlocale"
        },
        {
          "addr": "0x4048a0",
          "name": "ai_bind_textdomain_wrapper",
          "original_name": "bindtextdomain"
        },
        {
          "addr": "0x404860",
          "name": "ai_set_textdomain",
          "original_name": "textdomain"
        },
        {
          "addr": "0x418d90",
          "name": "ai_register_atexit_handler",
          "original_name": "sub_418d90"
        },
        {
          "addr": "0x404900",
          "name": "ai_cli_option_parser",
          "original_name": "getopt_long"
        },
        {
          "addr": "0x404770",
          "name": "ai_strncmp_wrapper",
          "original_name": "strncmp"
        },
        {
          "addr": "0x413ec0",
          "name": "ai_print_valid_arguments",
          "original_name": "sub_413ec0"
        },
        {
          "addr": "0x413ec0",
          "name": "ai_print_valid_arguments",
          "original_name": "sub_413ec0"
        },
        {
          "addr": "0x413ec0",
          "name": "ai_print_valid_arguments",
          "original_name": "sub_413ec0"
        },
        {
          "addr": "0x413ec0",
          "name": "ai_print_valid_arguments",
          "original_name": "sub_413ec0"
        },
        {
          "addr": "0x413ec0",
          "name": "ai_print_valid_arguments",
          "original_name": "sub_413ec0"
        },
        {
          "addr": "0x409ee0",
          "name": "ai_stdout_isatty_cached",
          "original_name": "sub_409ee0"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x413ec0",
          "name": "ai_print_valid_arguments",
          "original_name": "sub_413ec0"
        },
        {
          "addr": "0x413ec0",
          "name": "ai_print_valid_arguments",
          "original_name": "sub_413ec0"
        },
        {
          "addr": "0x409ee0",
          "name": "ai_stdout_isatty_cached",
          "original_name": "sub_409ee0"
        },
        {
          "addr": "0x412420",
          "name": "ai_get_blocksize_config",
          "original_name": "sub_412420"
        },
        {
          "addr": "0x409070",
          "name": "ai_safe_strtoumax",
          "original_name": "sub_409070"
        },
        {
          "addr": "0x409cf0",
          "name": "ai_dynamic_buffer_init",
          "original_name": "sub_409cf0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x411f60",
          "name": "ai_parse_uintmax",
          "original_name": "sub_411f60"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x413ce0",
          "name": "ai_dynamic_array_ensure_and_process",
          "original_name": "sub_413ce0"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x40e470",
          "name": "ai_allocate_and_store_128bit",
          "original_name": "sub_40e470"
        },
        {
          "addr": "0x413ec0",
          "name": "ai_print_valid_arguments",
          "original_name": "sub_413ec0"
        },
        {
          "addr": "0x409ee0",
          "name": "ai_stdout_isatty_cached",
          "original_name": "sub_409ee0"
        },
        {
          "addr": "0x40e470",
          "name": "ai_allocate_and_store_128bit",
          "original_name": "sub_40e470"
        },
        {
          "addr": "0x40e470",
          "name": "ai_allocate_and_store_128bit",
          "original_name": "sub_40e470"
        },
        {
          "addr": "0x408c20",
          "name": "ai_is_utf8_locale",
          "original_name": "sub_408c20"
        },
        {
          "addr": "0x408c20",
          "name": "ai_is_utf8_locale",
          "original_name": "sub_408c20"
        },
        {
          "addr": "0x411790",
          "name": "ai_print_version_and_license",
          "original_name": "sub_411790"
        },
        {
          "addr": "0x404cb0",
          "name": "ai_exit_wrapper",
          "original_name": "exit"
        },
        {
          "addr": "0x411e10",
          "name": "ai_allocate_and_init_static_struct",
          "original_name": "sub_411e10"
        },
        {
          "addr": "0x411e10",
          "name": "ai_allocate_and_init_static_struct",
          "original_name": "sub_411e10"
        },
        {
          "addr": "0x404770",
          "name": "ai_strncmp_wrapper",
          "original_name": "strncmp"
        },
        {
          "addr": "0x40c6a0",
          "name": "ai_check_posix_locale",
          "original_name": "sub_40c6a0"
        },
        {
          "addr": "0x416a40",
          "name": "ai_initialize_object_pool",
          "original_name": "sub_416a40"
        },
        {
          "addr": "0x40dc60",
          "name": "ai_obstack_init",
          "original_name": "_obstack_begin"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x408fc0",
          "name": "ai_allocate_string_struct",
          "original_name": "sub_408fc0"
        },
        {
          "addr": "0x4047f0",
          "name": "ai_reallocarray_wrapper",
          "original_name": "reallocarray"
        },
        {
          "addr": "0x409f10",
          "name": "ai_cleanup_global_structs",
          "original_name": "sub_409f10"
        },
        {
          "addr": "0x417490",
          "name": "ai_collect_file_acl_info",
          "original_name": "sub_417490"
        },
        {
          "addr": "0x410fc0",
          "name": "ai_directory_traversal",
          "original_name": "sub_410fc0"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x409a50",
          "name": "ai_hash_table_lookup",
          "original_name": "sub_409a50"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x404cf0",
          "name": "ai_flush_file_stream",
          "original_name": "fflush_unlocked"
        },
        {
          "addr": "0x408a60",
          "name": "ai_signal_handler_setup",
          "original_name": "sub_408a60"
        },
        {
          "addr": "0x404730",
          "name": "ai_raise_signal",
          "original_name": "raise"
        },
        {
          "addr": "0x40c840",
          "name": "ai_cleanup_linked_structure",
          "original_name": "sub_40c840"
        },
        {
          "addr": "0x411e10",
          "name": "ai_allocate_and_init_static_struct",
          "original_name": "sub_411e10"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x417490",
          "name": "ai_collect_file_acl_info",
          "original_name": "sub_417490"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x411f60",
          "name": "ai_parse_uintmax",
          "original_name": "sub_411f60"
        },
        {
          "addr": "0x40c7b0",
          "name": "ai_validate_float_bounds",
          "original_name": "sub_40c7b0"
        },
        {
          "addr": "0x40b590",
          "name": "ai_ensure_capacity",
          "original_name": "sub_40b590"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x411e70",
          "name": "ai_match_argument_in_list",
          "original_name": "sub_411e70"
        },
        {
          "addr": "0x409ee0",
          "name": "ai_stdout_isatty_cached",
          "original_name": "sub_409ee0"
        },
        {
          "addr": "0x409ee0",
          "name": "ai_stdout_isatty_cached",
          "original_name": "sub_409ee0"
        },
        {
          "addr": "0x40dc60",
          "name": "ai_obstack_init",
          "original_name": "_obstack_begin"
        },
        {
          "addr": "0x40dc60",
          "name": "ai_obstack_init",
          "original_name": "_obstack_begin"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404c90",
          "name": "ai_get_hostname",
          "original_name": "gethostname"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x410a20",
          "name": "ai_safe_buffer_resize",
          "original_name": "sub_410a20"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x412420",
          "name": "ai_get_blocksize_config",
          "original_name": "sub_412420"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x410b30",
          "name": "ai_strdup",
          "original_name": "sub_410b30"
        },
        {
          "addr": "0x404a10",
          "name": "ai_memcmp_wrapper",
          "original_name": "memcmp"
        },
        {
          "addr": "0x407d70",
          "name": "ai_strnicmp",
          "original_name": "sub_407d70"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x406ea0",
          "name": "ai_decode_escape_sequence",
          "original_name": "sub_406ea0"
        },
        {
          "addr": "0x409cf0",
          "name": "ai_dynamic_buffer_init",
          "original_name": "sub_409cf0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4049a0",
          "name": "ai_assert_failure_handler",
          "original_name": "__assert_fail"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        },
        {
          "addr": "0x408190",
          "name": "ai_print_long_array",
          "original_name": "sub_408190"
        },
        {
          "addr": "0x408190",
          "name": "ai_print_long_array",
          "original_name": "sub_408190"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x411e70",
          "name": "ai_match_argument_in_list",
          "original_name": "sub_411e70"
        },
        {
          "addr": "0x408280",
          "name": "ai_parse_format_placeholders",
          "original_name": "sub_408280"
        },
        {
          "addr": "0x40e4b0",
          "name": "ai_resize_sort_file_buffer",
          "original_name": "sub_40e4b0"
        },
        {
          "addr": "0x4105e0",
          "name": "ai_jump_table_dispatch",
          "original_name": "sub_4105e0"
        },
        {
          "addr": "0x409ee0",
          "name": "ai_stdout_isatty_cached",
          "original_name": "sub_409ee0"
        },
        {
          "addr": "0x4049d0",
          "name": "ai_ioctl_wrapper",
          "original_name": "ioctl"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404770",
          "name": "ai_strncmp_wrapper",
          "original_name": "strncmp"
        },
        {
          "addr": "0x4049b0",
          "name": "ai_fnmatch_wrapper",
          "original_name": "fnmatch"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x411e10",
          "name": "ai_allocate_and_init_static_struct",
          "original_name": "sub_411e10"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404770",
          "name": "ai_strncmp_wrapper",
          "original_name": "strncmp"
        },
        {
          "addr": "0x410b70",
          "name": "ai_add_list_node",
          "original_name": "sub_410b70"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x406ea0",
          "name": "ai_decode_escape_sequence",
          "original_name": "sub_406ea0"
        },
        {
          "addr": "0x406ea0",
          "name": "ai_decode_escape_sequence",
          "original_name": "sub_406ea0"
        },
        {
          "addr": "0x40c040",
          "name": "ai_argument_error_report",
          "original_name": "sub_40c040"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4090e0",
          "name": "ai_print_usage_help",
          "original_name": "sub_4090e0"
        },
        {
          "addr": "0x4090e0",
          "name": "ai_print_usage_help",
          "original_name": "sub_4090e0"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x404730",
          "name": "ai_raise_signal",
          "original_name": "raise"
        },
        {
          "addr": "0x40c6a0",
          "name": "ai_check_posix_locale",
          "original_name": "sub_40c6a0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x404a10",
          "name": "ai_memcmp_wrapper",
          "original_name": "memcmp"
        },
        {
          "addr": "0x404930",
          "name": "ai_strchr_wrapper",
          "original_name": "strchr"
        },
        {
          "addr": "0x404930",
          "name": "ai_strchr_wrapper",
          "original_name": "strchr"
        },
        {
          "addr": "0x409ee0",
          "name": "ai_stdout_isatty_cached",
          "original_name": "sub_409ee0"
        },
        {
          "addr": "0x410bf0",
          "name": "ai_process_config_entries",
          "original_name": "sub_410bf0"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x409070",
          "name": "ai_safe_strtoumax",
          "original_name": "sub_409070"
        },
        {
          "addr": "0x409cf0",
          "name": "ai_dynamic_buffer_init",
          "original_name": "sub_409cf0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404aa0",
          "name": "ai_safe_memory_copy",
          "original_name": "__memcpy_chk"
        },
        {
          "addr": "0x4049a0",
          "name": "ai_assert_failure_handler",
          "original_name": "__assert_fail"
        },
        {
          "addr": "0x409cf0",
          "name": "ai_dynamic_buffer_init",
          "original_name": "sub_409cf0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        },
        {
          "addr": "0x4049a0",
          "name": "ai_assert_failure_handler",
          "original_name": "__assert_fail"
        },
        {
          "addr": "0x409cf0",
          "name": "ai_dynamic_buffer_init",
          "original_name": "sub_409cf0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        },
        {
          "addr": "0x409cf0",
          "name": "ai_dynamic_buffer_init",
          "original_name": "sub_409cf0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x404cc0",
          "name": "ai_fwrite_wrapper",
          "original_name": "fwrite"
        },
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        }
      ],
      "import_refs": [
        "strrchr",
        "strncmp",
        "setlocale",
        "bindtextdomain",
        "textdomain",
        "getopt_long",
        "strncmp",
        "malloc",
        "dcgettext",
        "error",
        "dcgettext",
        "__errno_location",
        "__errno_location",
        "error",
        "exit",
        "strncmp",
        "getenv",
        "reallocarray",
        "free",
        "free",
        "free",
        "free",
        "free",
        "free",
        "free",
        "fflush_unlocked",
        "raise",
        "__errno_location",
        "getenv",
        "free",
        "getenv",
        "__errno_location",
        "gethostname",
        "strlen",
        "free",
        "getenv",
        "getenv",
        "memcmp",
        "strcmp",
        "dcgettext",
        "error",
        "dcgettext",
        "error",
        "free",
        "__assert_fail",
        "__printf_chk",
        "ioctl",
        "getenv",
        "getenv",
        "getenv",
        "strlen",
        "strncmp",
        "fnmatch",
        "free",
        "strncmp",
        "malloc",
        "dcgettext",
        "fputs_unlocked",
        "__fprintf_chk",
        "dcgettext",
        "fputs_unlocked",
        "getenv",
        "raise",
        "dcgettext",
        "dcgettext",
        "__overflow",
        "memcmp",
        "strchr",
        "strchr",
        "getenv",
        "dcgettext",
        "error",
        "malloc",
        "__memcpy_chk",
        "__assert_fail",
        "dcgettext",
        "error",
        "__stack_chk_fail",
        "__assert_fail",
        "dcgettext",
        "error",
        "dcgettext",
        "error",
        "abort",
        "dcgettext",
        "error",
        "dcgettext",
        "error",
        "fwrite",
        "abort"
      ],
      "string_refs": [
        "M;.u",
        "posix-",
        "# Configuration file for dircolors, a utility to help you set the",
        "dev_ino_pop",
        "main",
        "GNU coreutils",
        "src/ls.c",
        "invalid %s%s argument '%s'",
        "%s%s argument '%s' too large",
        "full-iso",
        "/.libs/",
        "/usr/share/locale",
        "invalid line width",
        "%s: %s",
        "--classify",
        "invalid tab size",
        "--sort",
        "--time",
        "--format",
        "--color"
      ],
      "constants": [
        "0x108",
        "0x422ff8",
        "0x41d5d8",
        "0x404cc0",
        "0x404750",
        "0x404970",
        "0x422fd0",
        "0x423460",
        "0x41af54",
        "0x422340",
        "0x41ae52",
        "0x41d610",
        "0x404bc0",
        "0x41b029",
        "0x4048a0",
        "0x419194",
        "0x404860",
        "0x40b880",
        "0x423088",
        "0x418d90",
        "0x41daf0",
        "0x42372c",
        "0x423728",
        "0x423720",
        "0xfffffffffffffee8",
        "0xfffffffffffffee0",
        "0xffffffff",
        "0xffffffffffffff00",
        "0xfffffffffffffefc",
        "0xfffffffffffffefb"
      ],
      "snippets": {
        "asm": "  0x404da0  endbr64 \n  0x404da4  push    rbp {__saved_rbp}\n  0x404da5  mov     rbp, rsp {__saved_rbp}\n  0x404da8  push    r15 {__saved_r15}\n  0x404daa  push    r14 {__saved_r14}\n  0x404dac  push    r13 {__saved_r13}\n  0x404dae  push    r12 {__saved_r12}\n  0x404db0  push    rbx {__saved_rbx}\n  0x404db1  sub     rsp, 0x108\n  0x404db8  mov     dword [rbp-0xe4 {var_ec}], edi\n  0x404dbe  mov     rbx, qword [rsi]\n  0x404dc1  mov     qword [rbp-0xf0 {var_f8}], rsi\n  0x404dc8  mov     rax, qword [fs:0x28]\n  0x404dd1  mov     qword [rbp-0x38 {var_40}], rax\n  0x404dd5  xor     eax, eax  {0x0}\n  0x404dd7  test    rbx, rbx\n  0x404dda  je      0x406d03\n  0x406d03  mov     rax, qword [rel stderr]\n  0x406d0a  mov     edx, 0x37\n  0x406d0f  mov     esi, 0x1\n  0x406d14  lea     rdi, [rel data_41d5d8]  {\"A NULL argv[0] was passed through an exec system call.\\n\"}\n  0x406d1b  mov     rcx, qword [rax]\n  0x406d1e  call    fwrite\n  0x406d23  call    abort\n  0x406d23  { Does not return }\n  0x404de0  mov     esi, 0x2f\n  0x404de5  mov     rdi, rbx\n  0x404de8  call    strrchr\n  0x404ded  mov     r12, rax\n  0x404df0  test    rax, rax\n  ... (8029 bytes total, truncated)",
        "hlil": "char* rbx = *argv\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nif (rbx != 0)\nchar* rax_2\nint64_t rcx_1\nint64_t rdx\nuint64_t r8_1\nssize_t r9_1\nrax_2, rcx_1, rdx, r8_1, r9_1 = strrchr(rbx, 0x2f)\nif (rax_2 != 0 && &rax_2[1] - rbx s> 6)\nint32_t rax_5\nrax_5, rcx_1, rdx, r8_1, r9_1 = strncmp(&rax_2[-6], \"/.libs/\", 7)\nif (rax_5 == 0)\nrbx = &rax_2[1]\nint32_t rax_11\nrax_11, rcx_1, rdx, r8_1, r9_1 = strncmp(&rax_2[1], \"lt-\", 3)\nif (rax_11 == 0)\nrbx = &rax_2[4]\n*program_invocation_short_name = rbx\ndata_423460 = rbx\n*program_invocation_name = rbx\nvoid category\nint32_t category_1\nsetlocale(6, &data_41af54, rdx, rcx_1, r8_1, r9_1, category, category_1)\nbindtextdomain(\"coreutils\", \"/usr/share/locale\")\nuint32_t* const rbx_1 = &jump_table_419194\ntextdomain(\"coreutils\")\ndata_423088 = 2\nsub_418d90(sub_40b880)\nint128_t zmm0_1 = data_41daf0\ndata_42372c = 0\ndata_423728 = 1\ndata_423720 = 0\nint64_t var_120_1 = -1\nuint64_t var_128_1 = -1\nint32_t var_100_1 = 0xffffffff\nint32_t var_108_1 = 0xffffffff\nint32_t var_10c_1 = 0xffffffff\nint32_t var_f0_1 = 0xffffffff\n// ... truncated",
        "pseudoc": "{\n    char* rbx = *(uint64_t*)argv;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (rbx)\n    {\n        char* rax_2;\n        int64_t rcx_1;\n        int64_t rdx;\n        uint64_t r8_1;\n        ssize_t r9_1;\n        rax_2 = strrchr(rbx, 0x2f);\n        \n        if (rax_2 && &rax_2[1] - rbx > 6)\n        {\n            int32_t rax_5;\n            rax_5 = strncmp(&rax_2[-6], \"/.libs/\", 7);\n            \n            if (!rax_5)\n            {\n                rbx = &rax_2[1];\n                int32_t rax_11;\n                rax_11 = strncmp(&rax_2[1], \"lt-\", 3);\n                \n                if (!rax_11)\n                {\n                    rbx = &rax_2[4];\n                    *(uint64_t*)program_invocation_short_name = rbx;\n                }\n            }\n        }\n        \n        data_423460 = rbx;\n        *(uint64_t*)program_invocation_name = rbx;\n        void category;\n        int32_t category_1;\n        setlocale(6, &data_41af54, rdx, rcx_1, r8_1, r9_1, category, category_1);\n        bindtextdomain(\"coreutils\", \"/usr/share/locale\");\n        uint32_t* const rbx_1 = &jump_table_419194;\n        textdomain(\"coreutils\");\n        data_423088 = 2;\n        sub_418d90(sub_40b880);\n        int128_t zmm0_1 = data_41daf0;\n        data_42372c = 0;\n        data_423728 = 1;\n        data_423720 = 0;\n        int64_t var_120_1 = -1;\n        uint64_t var_128_1 = -1;\n        int32_t var_100_1 = 0xffffffff;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_ls_initialize",
          "confidence": 0.95,
          "rationale": "The function is the main entry point of GNU coreutils 'ls', handling program name extraction, locale setup, and text domain binding, typical of command initialization.",
          "evidence_refs": [
            "strings:'GNU coreutils'",
            "strings:'src/ls.c'",
            "strings:'Configuration file for dircolors'",
            "imports:setlocale",
            "imports:bindtextdomain",
            "imports:textdomain",
            "call:0x404970",
            "call:0x404770"
          ],
          "tags": [
            "process",
            "config"
          ],
          "alt_names": [
            "ai_ls_main",
            "ai_coreutils_ls_entry"
          ]
        },
        "explain": {
          "summary": "The main function initializes the GNU coreutils program by extracting the executable name, handling libtool wrapper paths, setting locale and translation domains, and preparing global state before delegating to further initialization and option parsing routines.",
          "details": [
            "It extracts the base name from argv[0] using strrchr and adjusts it if the path contains '/.libs/lt-' (common for libtool), storing the result in program_invocation_name and program_invocation_short_name.",
            "It calls setlocale, bindtextdomain, and textdomain to configure internationalization for the \"coreutils\" domain.",
            "Global variables such as data_423460, data_423088, and others are initialized, and a subroutine sub_418d90 is invoked with a function pointer argument, likely to set up further program state or parse command-line options."
          ],
          "evidence_refs": [
            "strings:\"GNU coreutils\"",
            "strings:\"src/ls.c\"",
            "imports:strrchr",
            "imports:strncmp",
            "imports:setlocale",
            "imports:bindtextdomain",
            "imports:textdomain",
            "call:0x404970",
            "call:0x404770",
            "call:0x404bc0"
          ],
          "unknowns": [
            "Exact purpose of the later global variables (data_42372c, data_423728, etc.)",
            "Detailed command-line parsing and core functionality performed after the shown initialization"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": [
        "process",
        "config"
      ]
    },
    {
      "addr": "0x406d30",
      "original_name": "_start",
      "final_name": "ai_entry_point",
      "score": 13.6,
      "bb_count": 1,
      "insn_est": 12,
      "callers": 0,
      "callees": [
        {
          "addr": "0x422f98"
        }
      ],
      "import_refs": [
        "__libc_start_main"
      ],
      "string_refs": [],
      "constants": [
        "0x404da0",
        "0x422f98"
      ],
      "snippets": {
        "asm": "  0x406d30  endbr64 \n  0x406d34  xor     ebp, ebp  {0x0}\n  0x406d36  mov     r9, rdx\n  0x406d39  pop     rsi {__return_addr}\n  0x406d3a  mov     rdx, rsp {ubp_av}\n  0x406d3d  and     rsp, 0xfffffffffffffff0\n  0x406d41  push    rax {stack_end}\n  0x406d42  push    rsp {stack_end} {var_10}\n  0x406d43  xor     r8d, r8d  {0x0}\n  0x406d46  xor     ecx, ecx  {0x0}\n  0x406d48  lea     rdi, [rel main]\n  0x406d4f  call    qword [rel __libc_start_main]\n  0x406d4f  { Does not return }",
        "hlil": "int64_t stack_end_1\nint64_t stack_end = stack_end_1\nvoid ubp_av\n__libc_start_main(main, __return_addr.d, &ubp_av, nullptr, nullptr, arg3, &stack_end)\nnoreturn",
        "pseudoc": "{\n    int64_t stack_end_1;\n    int64_t stack_end = stack_end_1;\n    void ubp_av;\n    __libc_start_main(main, (uint32_t)__return_addr, &ubp_av, nullptr, nullptr, arg3, &stack_end);\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_entry_point",
          "confidence": 0.96,
          "rationale": "Function is the ELF _start routine that invokes __libc_start_main to launch the main program, typical of program entry initialization.",
          "evidence_refs": [
            "imports:__libc_start_main",
            "call:0x422f98"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_program_start",
            "ai_init_entry"
          ]
        },
        "explain": {
          "summary": "The _start function is the program entry point that prepares the runtime environment and invokes __libc_start_main with the program's main function and stack end pointer, then never returns.",
          "details": [
            "It defines a stack_end variable and passes its address to __libc_start_main to inform the C runtime of the stack limit.",
            "It calls __libc_start_main with main, a return address placeholder, a ubp_av placeholder, two null pointers, an arg3 value, and the stack_end pointer, handing control over to the C runtime."
          ],
          "evidence_refs": [
            "imports:__libc_start_main",
            "call:0x422f98"
          ],
          "unknowns": [
            "Exact value of arg3 passed to __libc_start_main",
            "The concrete address of the main function referenced in the call",
            "Purpose of the ubp_av placeholder variable"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x406d60",
      "original_name": "deregister_tm_clones",
      "final_name": "ai_cleanup_tm_clone_registry",
      "score": 18.2,
      "bb_count": 4,
      "insn_est": 9,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422fa0"
        }
      ],
      "import_refs": [
        "_ITM_deregisterTMCloneTable"
      ],
      "string_refs": [],
      "constants": [
        "0x423278",
        "0x422fa0"
      ],
      "snippets": {
        "asm": "  0x406d60  lea     rdi, [rel data_423278]\n  0x406d67  lea     rax, [rel data_423278]\n  0x406d6e  cmp     rax, rdi  {0x1}\n  0x406d71  je      0x406d88\n  0x406d88  retn     {__return_addr}\n  0x406d73  mov     rax, qword [rel _ITM_deregisterTMCloneTable]\n  0x406d7a  test    rax, rax\n  0x406d7d  je      0x406d88\n  0x406d7f  jmp     rax",
        "hlil": "return &data_423278",
        "pseudoc": "{\n    return &data_423278;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_cleanup_tm_clone_registry",
          "confidence": 0.95,
          "rationale": "Function deregisters transactional memory clones via _ITM_deregisterTMCloneTable, typical cleanup routine called during program termination.",
          "evidence_refs": [
            "imports:_ITM_deregisterTMCloneTable",
            "call:0x422fa0"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_deregister_tm_clones",
            "ai_unregister_tm_clones"
          ]
        },
        "explain": {
          "summary": "The deregister_tm_clones function simply returns the address of a global data item (data_423278), likely representing a TM clone table used during program termination.",
          "details": [
            "The function contains a single return statement that yields &data_423278.",
            "It is imported alongside _ITM_deregisterTMCloneTable, suggesting its role in TM clone deregistration, and is called by the _FINI_0 cleanup routine after __cxa_finalize."
          ],
          "evidence_refs": [
            "imports:_ITM_deregisterTMCloneTable",
            "call:0x406d60",
            "strings:none"
          ],
          "unknowns": [
            "Exact contents and purpose of data_423278",
            "Whether the function internally invokes _ITM_deregisterTMCloneTable (no call shown in snippet)"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x406d90",
      "original_name": "sub_406d90",
      "final_name": "ai_null_stub",
      "score": 19.7,
      "bb_count": 4,
      "insn_est": 14,
      "callers": 1,
      "callees": [
        {
          "addr": "0x422fe0"
        }
      ],
      "import_refs": [
        "_ITM_registerTMCloneTable"
      ],
      "string_refs": [],
      "constants": [
        "0x423278",
        "0x422fe0"
      ],
      "snippets": {
        "asm": "  0x406d90  lea     rdi, [rel data_423278]\n  0x406d97  lea     rsi, [rel data_423278]\n  0x406d9e  sub     rsi, rdi\n  0x406da1  mov     rax, rsi\n  0x406da4  shr     rsi, 0x3f\n  0x406da8  sar     rax, 0x3\n  0x406dac  add     rsi, rax\n  0x406daf  sar     rsi, 0x1  {0x0}  {0x1}\n  0x406db2  je      0x406dc8\n  0x406dc8  retn     {__return_addr}\n  0x406db4  mov     rax, qword [rel _ITM_registerTMCloneTable]\n  0x406dbb  test    rax, rax\n  0x406dbe  je      0x406dc8\n  0x406dc0  jmp     rax",
        "hlil": "return nullptr",
        "pseudoc": "{\n    return nullptr;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_null_stub",
          "confidence": 0.88,
          "rationale": "Function contains only a return nullptr with no side effects, acting as a no-op placeholder.",
          "evidence_refs": [
            "imports:_ITM_registerTMCloneTable",
            "call:0x406e10"
          ],
          "tags": [],
          "alt_names": [
            "ai_noop",
            "ai_stub"
          ]
        },
        "explain": {
          "summary": "The function sub_406d90 is a stub that immediately returns a null pointer without performing any operations.",
          "details": [
            "The implementation consists solely of 'return nullptr;', indicating no side effects or processing.",
            "It is invoked by the _INIT_0 function via a tail call, suggesting it may serve as a placeholder or default initializer."
          ],
          "evidence_refs": [
            "strings:none",
            "imports:_ITM_registerTMCloneTable",
            "call:0x406d90"
          ],
          "unknowns": [
            "The purpose of the imported _ITM_registerTMCloneTable symbol, which is not referenced in the function."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x406dd0",
      "original_name": "_FINI_0",
      "final_name": "ai_runtime_cleanup",
      "score": 25.7,
      "bb_count": 5,
      "insn_est": 14,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046e0",
          "name": "ai_runtime_cleanup_wrapper",
          "original_name": "__cxa_finalize"
        },
        {
          "addr": "0x406d60",
          "name": "ai_cleanup_tm_clone_registry",
          "original_name": "deregister_tm_clones"
        }
      ],
      "import_refs": [
        "__cxa_finalize"
      ],
      "string_refs": [],
      "constants": [
        "0x423280",
        "0x406d60",
        "0x423008",
        "0x4046e0"
      ],
      "snippets": {
        "asm": "  0x406dd0  endbr64 \n  0x406dd4  cmp     byte [rel data_423280], 0x0\n  0x406ddb  jne     0x406e08\n  0x406e08  retn     {__return_addr}\n  0x406ddd  push    rbp {__saved_rbp}\n  0x406dde  cmp     qword [rel __cxa_finalize], 0x0\n  0x406de6  mov     rbp, rsp {__saved_rbp}\n  0x406de9  je      0x406df7\n  0x406df7  call    deregister_tm_clones\n  0x406dfc  mov     byte [rel data_423280], 0x1\n  0x406e03  pop     rbp {__saved_rbp}\n  0x406e04  retn     {__return_addr}\n  0x406deb  mov     rdi, qword [rel data_423008]\n  0x406df2  call    __cxa_finalize",
        "hlil": "if (data_423280 != 0)\nreturn \nif (__cxa_finalize != 0)\n__cxa_finalize(data_423008)\nderegister_tm_clones()\ndata_423280 = 1\nreturn ",
        "pseudoc": "{\n    if (data_423280)\n        return;\n    \n    if (__cxa_finalize)\n        __cxa_finalize(data_423008);\n    \n    deregister_tm_clones();\n    data_423280 = 1;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_runtime_cleanup",
          "confidence": 0.86,
          "rationale": "The function checks a flag, calls __cxa_finalize to run global destructors, deregisters TM clones, and sets a flag, indicating it performs process termination cleanup.",
          "evidence_refs": [
            "imports:__cxa_finalize",
            "call:0x4046e0",
            "call:0x406d60"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_global_destructor",
            "ai_finalize_wrapper"
          ]
        },
        "explain": {
          "summary": "The function implements a one-time finalization routine that checks a flag, invokes __cxa_finalize with a global pointer, deregisters transactional memory clones, and then marks the finalization as completed.",
          "details": [
            "If the flag data_423280 is already set, the function returns immediately to avoid duplicate execution.",
            "When not yet run, it calls __cxa_finalize with data_423008 to run C++ static destructors or cleanup handlers.",
            "It then calls deregister_tm_clones to clean up any transactional memory clone tables.",
            "Finally, it sets data_423280 to 1 to indicate that finalization has been performed."
          ],
          "evidence_refs": [
            "imports:__cxa_finalize",
            "call:0x4046e0",
            "call:0x406d60"
          ],
          "unknowns": [
            "The exact semantics of data_423008 (what object it points to).",
            "The internal behavior of deregister_tm_clones beyond returning a pointer."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x406e10",
      "original_name": "_INIT_0",
      "final_name": "ai_null_initializer",
      "score": 5.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 0,
      "callees": [
        {
          "addr": "0x406d90",
          "name": "ai_null_stub",
          "original_name": "sub_406d90"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x406d90"
      ],
      "snippets": {
        "asm": "  0x406e10  endbr64 \n  0x406e14  jmp     sub_406d90",
        "hlil": "return sub_406d90() __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sub_406d90();\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_null_initializer",
          "confidence": 0.85,
          "rationale": "Function simply tail-calls another stub that returns nullptr, indicating a no-op initialization routine.",
          "evidence_refs": [
            "call:0x406d90"
          ],
          "tags": [],
          "alt_names": [
            "ai_stub_init",
            "ai_no_op"
          ]
        },
        "explain": {
          "summary": "The _INIT_0 function simply forwards execution to sub_406d90 and returns its result, which is a null pointer, acting as a no-op initializer.",
          "details": [
            "The function contains a tail call to sub_406d90 and returns its value.",
            "sub_406d90 performs no operations and returns nullptr."
          ],
          "evidence_refs": [
            "call:0x406d90",
            "imports:_ITM_registerTMCloneTable"
          ],
          "unknowns": [
            "The broader context or purpose of this initialization stub within the program."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x406e20",
      "original_name": "sub_406e20",
      "final_name": "ai_modulo_hash_index",
      "score": 3.3,
      "bb_count": 1,
      "insn_est": 6,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x406e20  endbr64 \n  0x406e24  mov     rax, qword [rdi]\n  0x406e27  xor     edx, edx  {0x0}\n  0x406e29  div     rsi\n  0x406e2c  mov     rax, rdx\n  0x406e2f  retn     {__return_addr}",
        "hlil": "return modu.dp.q(0:(*arg1), arg2)",
        "pseudoc": "{\n    return COMBINE(0, *(uint64_t*)arg1) % arg2;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_modulo_hash_index",
          "confidence": 0.62,
          "rationale": "The function reads a 64-bit value from memory, combines it with zero, and returns the result modulo a given divisor, typical of a simple hash or bucket index calculation.",
          "evidence_refs": [
            "call:0x406e20"
          ],
          "tags": [],
          "alt_names": [
            "ai_compute_modulo",
            "ai_hash_bucket"
          ]
        },
        "explain": {
          "summary": "The function reads a 64-bit integer from the memory address given by arg1, combines it with a zero high part, and returns the remainder of dividing this value by arg2.",
          "details": [
            "Loads a uint64_t value from the pointer arg1.",
            "Applies a COMBINE operation with a zero high word, effectively using the loaded value as a 64-bit integer.",
            "Computes the modulo of this integer with arg2 and returns the result."
          ],
          "evidence_refs": [],
          "unknowns": [
            "Exact definition of the COMBINE macro (e.g., whether it creates a larger integer type)."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x406e30",
      "original_name": "sub_406e30",
      "final_name": "ai_memcmp_8byte",
      "score": 7.5,
      "bb_count": 3,
      "insn_est": 10,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x406e30  endbr64 \n  0x406e34  mov     rdx, qword [rsi]\n  0x406e37  xor     eax, eax  {0x0}\n  0x406e39  cmp     qword [rdi], rdx\n  0x406e3c  je      0x406e40\n  0x406e40  mov     rax, qword [rsi+0x8]\n  0x406e44  cmp     qword [rdi+0x8], rax\n  0x406e48  sete    al\n  0x406e4b  retn     {__return_addr}\n  0x406e3e  retn     {__return_addr}",
        "hlil": "if (*arg1 != *arg2)\nreturn 0\nint64_t result\nresult.b = arg1[1] == arg2[1]\nreturn result",
        "pseudoc": "{\n    if (*(uint64_t*)arg1 != *(uint64_t*)arg2)\n        return 0;\n    \n    int64_t result;\n    (uint8_t)result = arg1[1] == arg2[1];\n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memcmp_8byte",
          "confidence": 0.78,
          "rationale": "The function checks equality of two memory regions by comparing a 64-bit value and a subsequent byte, indicating a simple memory comparison utility.",
          "evidence_refs": [],
          "tags": [],
          "alt_names": [
            "ai_compare_struct",
            "ai_memory_equality"
          ]
        },
        "explain": {
          "summary": "The function compares two memory buffers: it first checks if the first 8 bytes of arg1 and arg2 are equal, and if so, it then checks if the second byte of each buffer matches, returning 1 only when both checks succeed.",
          "details": [
            "If the 64-bit value at the start of arg1 differs from that at arg2, the function returns 0 immediately.",
            "When the 64-bit values match, it evaluates whether arg1[1] equals arg2[1] and returns that boolean result."
          ],
          "evidence_refs": [],
          "unknowns": [
            "Exact semantic meaning of the compared data (e.g., structure layout or purpose)."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x406e50",
      "original_name": "sub_406e50",
      "final_name": "ai_lazy_global_set",
      "score": 8.3,
      "bb_count": 3,
      "insn_est": 6,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x4237c8"
      ],
      "snippets": {
        "asm": "  0x406e50  endbr64 \n  0x406e54  mov     eax, dword [rel data_4237c8]\n  0x406e5a  test    eax, eax\n  0x406e5c  jne     0x406e64\n  0x406e64  retn     {__return_addr}\n  0x406e5e  mov     dword [rel data_4237c8], edi",
        "hlil": "int32_t result = data_4237c8\nif (result == 0)\ndata_4237c8 = arg1\nreturn result",
        "pseudoc": "{\n    int32_t result = data_4237c8;\n    \n    if (!result)\n        data_4237c8 = arg1;\n    \n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_lazy_global_set",
          "confidence": 0.86,
          "rationale": "The function returns a global variable's current value and, if it is zero, initializes it with the provided argument, acting as a lazy initializer/set-once for a global state.",
          "evidence_refs": [
            "constants:0x4237c8"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_set_if_zero",
            "ai_get_or_initialize_global"
          ]
        },
        "explain": {
          "summary": "The function returns the current value of a global variable at 0x4237c8, and if that value is zero it initializes the variable with the provided argument before returning the original value.",
          "details": [
            "Loads the global variable data_4237c8 into a local result.",
            "If result is zero, stores the input argument arg1 into data_4237c8.",
            "Returns the original value of data_4237c8 (zero if it was uninitialized)."
          ],
          "evidence_refs": [
            "constants:0x4237c8"
          ],
          "unknowns": [
            "Purpose of the global variable in the broader program",
            "Thread-safety considerations",
            "Potential side effects of setting data_4237c8"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x406e70",
      "original_name": "sub_406e70",
      "final_name": "ai_increment_global_counter",
      "score": 10.9,
      "bb_count": 3,
      "insn_est": 8,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x4237c8",
        "0x4237c4"
      ],
      "snippets": {
        "asm": "  0x406e70  endbr64 \n  0x406e74  mov     eax, dword [rel data_4237c8]\n  0x406e7a  test    eax, eax\n  0x406e7c  jne     0x406e8d\n  0x406e8d  retn     {__return_addr}\n  0x406e7e  mov     eax, dword [rel data_4237c4]\n  0x406e84  add     eax, 0x1\n  0x406e87  mov     dword [rel data_4237c4], eax",
        "hlil": "int32_t result = data_4237c8\nif (result == 0)\nresult = data_4237c4 + 1\ndata_4237c4 = result\nreturn result",
        "pseudoc": "{\n    int32_t result = data_4237c8;\n    \n    if (!result)\n    {\n        result = data_4237c4 + 1;\n        data_4237c4 = result;\n    }\n    \n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_increment_global_counter",
          "confidence": 0.85,
          "rationale": "The function returns a stored value; if the primary value is zero it increments a secondary global counter and returns the new value, acting as a simple sequential ID generator.",
          "evidence_refs": [
            "constants:0x4237c8",
            "constants:0x4237c4"
          ],
          "tags": [],
          "alt_names": [
            "ai_get_next_counter",
            "ai_generate_sequence_id"
          ]
        },
        "explain": {
          "summary": "The function returns the value of a global variable at 0x4237c8; if that value is zero it increments another global counter at 0x4237c4 and returns the incremented value.",
          "details": [
            "Loads data_4237c8 into a local result.",
            "If result is zero, increments data_4237c4 by one and stores it back, then returns the new counter value.",
            "Otherwise returns the original data_4237c8 value unchanged."
          ],
          "evidence_refs": [
            "constants:0x4237c8",
            "constants:0x4237c4"
          ],
          "unknowns": [
            "The semantic meaning of the two global variables and why one is used as a fallback counter."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x406e90",
      "original_name": "sub_406e90",
      "final_name": "ai_free_memory",
      "score": 8.6,
      "bb_count": 1,
      "insn_est": 2,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        }
      ],
      "import_refs": [
        "free"
      ],
      "string_refs": [],
      "constants": [
        "0x4046b0"
      ],
      "snippets": {
        "asm": "  0x406e90  endbr64 \n  0x406e94  jmp     free",
        "hlil": "return free(ptr) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return free(ptr);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_free_memory",
          "confidence": 0.96,
          "rationale": "The function is a thin wrapper that directly calls the imported free() to deallocate a pointer, indicating memory release behavior.",
          "evidence_refs": [
            "imports:free",
            "call:0x4046b0"
          ],
          "tags": [],
          "alt_names": [
            "ai_deallocate",
            "ai_release_memory"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that forwards its argument to the standard free() routine, effectively deallocating the provided memory.",
          "details": [
            "It takes a pointer argument and immediately calls free(ptr) via a tail call.",
            "No additional logic, checks, or side effects are present."
          ],
          "evidence_refs": [
            "imports:free",
            "call:0x4046b0"
          ],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x406ea0",
      "original_name": "sub_406ea0",
      "final_name": "ai_decode_escape_sequence",
      "score": 136.1,
      "bb_count": 52,
      "insn_est": 177,
      "callers": 3,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x419040"
      ],
      "snippets": {
        "asm": "  0x406ea0  push    rbp {__saved_rbp}\n  0x406ea1  mov     r11, rsi\n  0x406ea4  mov     eax, edx\n  0x406ea6  xor     r10d, r10d  {0x0}\n  0x406ea9  xor     r9d, r9d  {0x0}\n  0x406eac  mov     rbp, rsp {__saved_rbp}\n  0x406eaf  push    r15 {__saved_r15}\n  0x406eb1  push    r14 {__saved_r14}\n  0x406eb3  mov     r14d, edx\n  0x406eb6  push    r13 {__saved_r13}\n  0x406eb8  lea     r13, [rel jump_table_419040]\n  0x406ebf  push    r12 {__saved_r12}\n  0x406ec1  mov     r12, rcx\n  0x406ec4  push    rbx {__saved_rbx}\n  0x406ec5  mov     r8, qword [rsi]\n  0x406ec8  mov     rbx, rdi\n  0x406ecb  xor     esi, esi  {0x0}\n  0x406ecd  mov     r15, qword [rdi]\n  0x406ed0  movzx   ecx, byte [r8]\n  0x406f19  cmp     r10d, 0x2\n  0x406f1d  jne     0x406f37\n  0x406ee0  test    cl, cl\n  0x406ee2  je      0x407090\n  0x406f37  cmp     cl, 0x5c\n  0x406f3a  je      0x406f70\n  0x406f1f  lea     r8d, [rcx-0x30]\n  0x406f23  cmp     r8b, 0x7\n  0x406f27  jbe     0x406f90\n  0x407090  add     r8, 0x1\n  0x407094  mov     rdi, r15\n  ... (607 bytes total, truncated)",
        "hlil": "uint64_t result = zx.q(arg3)\nint32_t r10 = 0\nint64_t r9 = 0\nchar* r8 = *arg2\nuint64_t rsi = 0\nchar* r15 = *arg1\nuint32_t rcx = zx.d(*r8)\nwhile (true)\nchar* rdi = r15\nchar* rdx = r8\nif (r10 == 1)\nif (rcx.b == 0)\nr8 = &r8[1]\nrdi = r15\nresult = 0\nlabel_406f5a:\n*arg1 = rdi\n*arg2 = r8\n*arg4 = r9\nreturn result\nrsi = zx.q(rcx - 0x30)\nswitch (rsi.b)\ncase 0, 1, 2, 3, 4, 5, 6, 7\nrdi = r15\nr10 = 2\nrcx = zx.d(r8[1])\nrdx = &r8[1]\ncase 0xf\nrsi = 0x7f\ngoto label_406f02\ncase 0x28, 0x48\nuint32_t rcx_3 = zx.d(r8[1])\nrdx = &r8[1]\nrsi = 0\nlabel_4070b0:\nwhile (rcx_3.b s<= 0x46)\nif (rcx_3.b s> 0x40)\nrdx = &rdx[1]\nrsi = zx.q(rcx_3 + (rsi.d << 4) - 0x37)\nrcx_3 = zx.d(*rdx)\n// ... truncated",
        "pseudoc": "{\n    uint64_t result = (uint64_t)arg3;\n    int32_t r10 = 0;\n    int64_t r9 = 0;\n    char* r8 = *(uint64_t*)arg2;\n    uint64_t rsi = 0;\n    char* r15 = *(uint64_t*)arg1;\n    uint32_t rcx = (uint32_t)*(uint8_t*)r8;\n    \n    while (true)\n    {\n        char* rdi = r15;\n        char* rdx = r8;\n        \n        if (r10 == 1)\n        {\n            if (!(uint8_t)rcx)\n            {\n                r8 = &r8[1];\n                rdi = r15;\n                result = 0;\n            label_406f5a:\n                *(uint64_t*)arg1 = rdi;\n                *(uint64_t*)arg2 = r8;\n                *(uint64_t*)arg4 = r9;\n                return result;\n            }\n            \n            rsi = (uint64_t)(rcx - 0x30);\n            \n            switch ((uint8_t)rsi)\n            {\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                {\n                    rdi = r15;\n                    r10 = 2;\n                    rcx = (uint32_t)r8[1];\n                    rdx = &r8[1];\n                    break;\n                }\n                case 0xf:\n                {\n                    rsi = 0x7f;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_decode_escape_sequence",
          "confidence": 0.78,
          "rationale": "The function walks through a character buffer, checks for a leading backslash-like context, subtracts '0' to detect octal digits (0-7) and handles '?' escape, indicating parsing of C-style escape sequences, likely decoding octal/hex escapes in strings.",
          "evidence_refs": [
            "constants:0x419040"
          ],
          "tags": [],
          "alt_names": [
            "ai_parse_octal_escape",
            "ai_decode_string_literal"
          ]
        },
        "explain": {
          "summary": "The function parses a numeric literal from a character buffer, handling different bases (decimal, octal, possibly hex) and returns the parsed integer while updating the input pointers.",
          "details": [
            "It reads characters from the buffer pointed to by arg2, converting ASCII digits by subtracting 0x30 and using a switch to handle digit ranges.",
            "State variable r10 controls parsing phases; when a digit is recognized it updates the accumulator r9 and advances pointers arg1 and arg2, storing the final value in arg4.",
            "The function returns zero on end-of-string or invalid input and updates the caller's pointers to the next unprocessed character."
          ],
          "evidence_refs": [
            "constants:0x419040"
          ],
          "unknowns": [
            "Exact handling of hexadecimal prefixes and overflow conditions",
            "The purpose of the constant 0x419040 in the broader context"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407130",
      "original_name": "sub_407130",
      "final_name": "ai_compare_struct_by_fields",
      "score": 17.9,
      "bb_count": 3,
      "insn_est": 23,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407130  endbr64 \n  0x407134  mov     rax, qword [rdi+0x80]\n  0x40713b  xor     edx, edx  {0x0}\n  0x40713d  cmp     qword [rsi+0x80], rax\n  0x407144  setg    al\n  0x407147  setl    dl\n  0x40714a  movzx   eax, al\n  0x40714d  sub     edx, eax\n  0x40714f  mov     rax, qword [rdi+0x88]\n  0x407156  cmp     qword [rsi+0x88], rax\n  0x40715d  setl    al\n  0x407160  setg    cl\n  0x407163  movzx   eax, al\n  0x407166  movzx   ecx, cl\n  0x407169  sub     eax, ecx\n  0x40716b  lea     eax, [rax+rdx*2]\n  0x40716e  test    eax, eax\n  0x407170  jne     0x407180\n  0x407180  retn     {__return_addr}\n  0x407172  mov     rax, qword [rdi]\n  0x407175  mov     rdi, qword [rsi]\n  0x407178  mov     rsi, rax\n  0x40717b  jmp     strcmp",
        "hlil": "int64_t rax = arg1[0x10]\nint64_t temp0 = arg2[0x10]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg1[0x11]\nint64_t temp1 = arg2[0x11]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nreturn strcmp(*arg2, *arg1) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[0x10];\n    int64_t temp0 = arg2[0x10];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg1[0x11];\n    int64_t temp1 = arg2[0x11];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg2, *(uint64_t*)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_fields",
          "confidence": 0.85,
          "rationale": "Function compares two objects by numeric fields at offsets 0x10 and 0x11, then falls back to strcmp on their string members, acting as a custom comparator.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_field_comparator",
            "ai_custom_sort_key"
          ]
        },
        "explain": {
          "summary": "The function implements a three-stage comparator: it first compares 64-bit values at offset 0x10 of the two arguments, then compares values at offset 0x11 if the first comparison is equal, and finally falls back to a lexical string comparison using strcmp on the pointers at the start of each structure. It returns a non-zero integer indicating ordering, otherwise the strcmp result.",
          "details": [
            "Loads arg1[0x10] and arg2[0x10] and computes a signed comparison, encoding the result in a small integer.",
            "Repeats the comparison for arg1[0x11] and arg2[0x11] and combines both comparison outcomes into a single integer result.",
            "If the combined numeric result is zero (both fields equal), it calls strcmp on the strings pointed to by arg1 and arg2 and returns that result."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantics of the fields at offsets 0x10 and 0x11 (e.g., timestamps, version numbers).",
            "Whether the function is used for sorting, searching, or other logic."
          ],
          "confidence": 0.94
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407190",
      "original_name": "sub_407190",
      "final_name": "ai_struct_compare",
      "score": 17.6,
      "bb_count": 3,
      "insn_est": 22,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407190  endbr64 \n  0x407194  mov     rax, qword [rsi+0x80]\n  0x40719b  xor     edx, edx  {0x0}\n  0x40719d  cmp     qword [rdi+0x80], rax\n  0x4071a4  setg    al\n  0x4071a7  setl    dl\n  0x4071aa  movzx   eax, al\n  0x4071ad  sub     edx, eax\n  0x4071af  mov     rax, qword [rsi+0x88]\n  0x4071b6  cmp     qword [rdi+0x88], rax\n  0x4071bd  setl    al\n  0x4071c0  setg    cl\n  0x4071c3  movzx   eax, al\n  0x4071c6  movzx   ecx, cl\n  0x4071c9  sub     eax, ecx\n  0x4071cb  lea     eax, [rax+rdx*2]\n  0x4071ce  test    eax, eax\n  0x4071d0  jne     0x4071e0\n  0x4071e0  retn     {__return_addr}\n  0x4071d2  mov     rsi, qword [rsi]\n  0x4071d5  mov     rdi, qword [rdi]\n  0x4071d8  jmp     strcmp",
        "hlil": "int64_t rax = arg2[0x10]\nint64_t temp0 = arg1[0x10]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg2[0x11]\nint64_t temp1 = arg1[0x11]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nreturn strcmp(*arg1, *arg2) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[0x10];\n    int64_t temp0 = arg1[0x10];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg2[0x11];\n    int64_t temp1 = arg1[0x11];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare",
          "confidence": 0.86,
          "rationale": "The function compares two data structures by inspecting fields at offsets 0x10 and 0x11, computes a result, and falls back to a string comparison via strcmp, indicating a custom comparator routine.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_custom_struct_compare",
            "ai_struct_cmp"
          ]
        },
        "explain": {
          "summary": "The function acts as a comparator: it first compares two 64bit fields at offsets 0x10 and 0x11 of the two input structures, computes a numeric ordering result, and if those fields are equal it falls back to a lexical string comparison of the pointers at the start of each structure.",
          "details": [
            "Loads arg1[0x10] and arg2[0x10] and sets flags based on < and > comparisons, contributing to a result value.",
            "Loads arg1[0x11] and arg2[0x11] and similarly contributes to the result.",
            "Combines the comparison flags into a 32bit integer; if nonzero, returns it as the ordering.",
            "If the numeric fields are equal (result == 0), tailcalls strcmp on the strings pointed to by arg1 and arg2 and returns that result."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "strings:none"
          ],
          "unknowns": [
            "Exact signedness of the 64bit fields and the intended meaning of the offsets.",
            "Whether the function is used for sorting, searching, or other logic beyond comparison."
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x4071f0",
      "original_name": "sub_4071f0",
      "final_name": "ai_compare_struct_by_type_and_name",
      "score": 38.3,
      "bb_count": 10,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x4071f0  endbr64 \n  0x4071f4  mov     rdx, rdi\n  0x4071f7  mov     rcx, rsi\n  0x4071fa  mov     edi, dword [rsi+0xa8]\n  0x407200  mov     eax, dword [rdx+0xa8]\n  0x407206  cmp     eax, 0x3\n  0x407209  sete    sil\n  0x40720d  cmp     eax, 0x9\n  0x407210  sete    al\n  0x407213  or      esi, eax\n  0x407215  cmp     edi, 0x3\n  0x407218  je      0x407248\n  0x407248  mov     eax, 0x1\n  0x40724d  test    sil, sil\n  0x407250  je      0x4072a0\n  0x40721a  cmp     edi, 0x9\n  0x40721d  je      0x407248\n  0x4072a0  mov     esi, dword [rdx+0xac]\n  0x4072a6  xor     edi, edi  {0x0}\n  0x4072a8  and     esi, 0xf000\n  0x4072ae  cmp     esi, 0x4000\n  0x4072b4  sete    dil\n  0x4072b8  sub     eax, edi\n  0x4072ba  jne     0x407243\n  0x407252  mov     rax, qword [rcx+0x80]\n  0x407259  xor     esi, esi  {0x0}\n  0x40725b  cmp     qword [rdx+0x80], rax\n  0x407262  setg    al\n  0x407265  setl    sil\n  0x407269  movzx   eax, al\n  ... (200 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nchar rsi = arg2.b | rax.b\nuint32_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi == 0)\nlabel_4072b4:\nrdi.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = rax_3 - rdi\nif (rax_3 == rdi)\ngoto label_407252\nlabel_407252:\nint64_t rax_4 = rcx[0x10]\nint64_t temp1_1 = arg1[0x10]\nbool cond:0_1 = temp1_1 s< rax_4\nrax_4.b = temp1_1 s> rax_4\nint32_t rsi_1\nrsi_1.b = cond:0_1\nint64_t rax_6 = rcx[0x11]\nint64_t temp2_1 = arg1[0x11]\nbool cond:1_1 = temp2_1 s> rax_6\nrax_6.b = temp2_1 s< rax_6\nrdi.b = cond:1_1\nresult = zx.d(rax_6.b) - zx.d(rdi.b) + ((rsi_1 - zx.d(rax_4.b)) << 1)\nif (result == 0)\nreturn strcmp(*arg1, *rcx) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi == 0)\ngoto label_4072b4\nresult = rax_3 - 1\nif (rax_3 == 1)\ngoto label_407252\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rsi = (uint8_t)arg2 | (uint8_t)rax;\n    uint32_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rsi)\n        {\n        label_4072b4:\n            (uint8_t)rdi = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = rax_3 - rdi;\n            \n            if (rax_3 == rdi)\n                goto label_407252;\n        }\n        else\n        {\n        label_407252:\n            int64_t rax_4 = rcx[0x10];\n            int64_t temp1_1 = arg1[0x10];\n            bool cond:0_1 = temp1_1 < rax_4;\n            (uint8_t)rax_4 = temp1_1 > rax_4;\n            int32_t rsi_1;\n            (uint8_t)rsi_1 = cond:0_1;\n            int64_t rax_6 = rcx[0x11];\n            int64_t temp2_1 = arg1[0x11];\n            bool cond:1_1 = temp2_1 > rax_6;\n            (uint8_t)rax_6 = temp2_1 < rax_6;\n            (uint8_t)rdi = cond:1_1;\n            result = (uint32_t)(uint8_t)rax_6 - (uint32_t)(uint8_t)rdi\n                + ((rsi_1 - (uint32_t)(uint8_t)rax_4) << 1);\n            \n            if (!result)\n                /* tailcall */\n                return strcmp(*(uint64_t*)arg1, *(uint64_t*)rcx);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_name",
          "confidence": 0.78,
          "rationale": "The function checks type fields (values 3 or 9), a flag mask (0x4000), compares numeric fields at offsets 0x10/0x11, and finally falls back to strcmp on string fields, indicating a comparator for struct entries based on type, flags, and name.",
          "evidence_refs": [
            "imports:strcmp",
            "constants:0xf000",
            "constants:0x4000",
            "call:0x4046c0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_struct_comparator",
            "ai_entry_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two objects based on a type field (offset 0x15) and a flag mask (0xf000 == 0x4000), then optionally compares numeric fields at offsets 0x10 and 0x11, and finally delegates to strcmp on the objects' string members if all checks succeed.",
          "details": [
            "It first checks if arg1[0x15] and arg2[0x15] are either 3 or 9, setting a flag rsi accordingly.",
            "If the type matches, it verifies a flag in each object's 0xac field using the mask 0xf000 against 0x4000.",
            "When the flag condition holds, it compares the 0x10 and 0x11 fields of both objects with a mixed <, > logic, producing a zero result only when they match the expected ordering.",
            "If all conditions are satisfied, the function tailcalls strcmp on the first 8byte member of each object, effectively comparing their string identifiers."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0x15, 0xac, 0x10, and 0x11",
            "Why the specific type values 3 and 9 are used"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x4072c0",
      "original_name": "sub_4072c0",
      "final_name": "ai_struct_comparator",
      "score": 38.3,
      "bb_count": 10,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x4072c0  endbr64 \n  0x4072c4  mov     rdx, rdi\n  0x4072c7  mov     rcx, rsi\n  0x4072ca  mov     edi, dword [rsi+0xa8]\n  0x4072d0  mov     eax, dword [rdx+0xa8]\n  0x4072d6  cmp     eax, 0x3\n  0x4072d9  sete    sil\n  0x4072dd  cmp     eax, 0x9\n  0x4072e0  sete    al\n  0x4072e3  or      esi, eax\n  0x4072e5  cmp     edi, 0x3\n  0x4072e8  je      0x407318\n  0x407318  mov     eax, 0x1\n  0x40731d  test    sil, sil\n  0x407320  je      0x407370\n  0x4072ea  cmp     edi, 0x9\n  0x4072ed  je      0x407318\n  0x407370  mov     esi, dword [rdx+0xac]\n  0x407376  xor     edi, edi  {0x0}\n  0x407378  and     esi, 0xf000\n  0x40737e  cmp     esi, 0x4000\n  0x407384  sete    dil\n  0x407388  sub     eax, edi\n  0x40738a  jne     0x407313\n  0x407322  mov     rax, qword [rdx+0x80]\n  0x407329  xor     esi, esi  {0x0}\n  0x40732b  cmp     qword [rcx+0x80], rax\n  0x407332  setg    al\n  0x407335  setl    sil\n  0x407339  movzx   eax, al\n  ... (200 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nchar rsi = arg2.b | rax.b\nuint32_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi == 0)\nlabel_407384:\nrdi.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = rax_3 - rdi\nif (rax_3 == rdi)\ngoto label_407322\nlabel_407322:\nint64_t rax_4 = arg1[0x10]\nint64_t temp1_1 = rcx[0x10]\nbool cond:0_1 = temp1_1 s< rax_4\nrax_4.b = temp1_1 s> rax_4\nint32_t rsi_1\nrsi_1.b = cond:0_1\nint64_t rax_6 = arg1[0x11]\nint64_t temp2_1 = rcx[0x11]\nbool cond:1_1 = temp2_1 s> rax_6\nrax_6.b = temp2_1 s< rax_6\nrdi.b = cond:1_1\nresult = zx.d(rax_6.b) - zx.d(rdi.b) + ((rsi_1 - zx.d(rax_4.b)) << 1)\nif (result == 0)\nreturn strcmp(*rcx, *arg1) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi == 0)\ngoto label_407384\nresult = rax_3 - 1\nif (rax_3 == 1)\ngoto label_407322\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rsi = (uint8_t)arg2 | (uint8_t)rax;\n    uint32_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rsi)\n        {\n        label_407384:\n            (uint8_t)rdi = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = rax_3 - rdi;\n            \n            if (rax_3 == rdi)\n                goto label_407322;\n        }\n        else\n        {\n        label_407322:\n            int64_t rax_4 = arg1[0x10];\n            int64_t temp1_1 = rcx[0x10];\n            bool cond:0_1 = temp1_1 < rax_4;\n            (uint8_t)rax_4 = temp1_1 > rax_4;\n            int32_t rsi_1;\n            (uint8_t)rsi_1 = cond:0_1;\n            int64_t rax_6 = arg1[0x11];\n            int64_t temp2_1 = rcx[0x11];\n            bool cond:1_1 = temp2_1 > rax_6;\n            (uint8_t)rax_6 = temp2_1 < rax_6;\n            (uint8_t)rdi = cond:1_1;\n            result = (uint32_t)(uint8_t)rax_6 - (uint32_t)(uint8_t)rdi\n                + ((rsi_1 - (uint32_t)(uint8_t)rax_4) << 1);\n            \n            if (!result)\n                /* tailcall */\n                return strcmp(*(uint64_t*)rcx, *(uint64_t*)arg1);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_comparator",
          "confidence": 0.86,
          "rationale": "The function compares two data structures by checking type fields (values 3 or 9), flag bits at offset 0xac, and numeric fields at offsets 0x10/0x11, then falls back to strcmp on string members, indicating a custom comparator for sorting or matching objects.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_object",
            "ai_entry_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two structures (arg1 and arg2) based on a type field, a flag mask, and two numeric fields, and if they match it delegates to strcmp to compare their string members.",
          "details": [
            "It checks the value at offset 0x15 of each argument; only values 3 or 9 trigger further comparison.",
            "It tests a flag at offset 0xac masked with 0xf000 against 0x4000 for both structures.",
            "It compares the 64bit values at offsets 0x10 and 0x11 of the two structures, computing a combined result that is zero only when both pairs match.",
            "When all conditions are satisfied, it tailcalls strcmp on the pointers stored at the start of each structure, returning the strcmp result."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "constants:0xf000",
            "constants:0x4000",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact meaning of the fields at offsets 0x15, 0xac, 0x10, and 0x11",
            "Why only type values 3 and 9 are considered"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407390",
      "original_name": "sub_407390",
      "final_name": "ai_struct_compare_by_fields",
      "score": 17.9,
      "bb_count": 3,
      "insn_est": 23,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407390  endbr64 \n  0x407394  mov     rax, qword [rdi+0x70]\n  0x407398  xor     edx, edx  {0x0}\n  0x40739a  cmp     qword [rsi+0x70], rax\n  0x40739e  setg    al\n  0x4073a1  setl    dl\n  0x4073a4  movzx   eax, al\n  0x4073a7  sub     edx, eax\n  0x4073a9  mov     rax, qword [rdi+0x78]\n  0x4073ad  cmp     qword [rsi+0x78], rax\n  0x4073b1  setl    al\n  0x4073b4  setg    cl\n  0x4073b7  movzx   eax, al\n  0x4073ba  movzx   ecx, cl\n  0x4073bd  sub     eax, ecx\n  0x4073bf  lea     eax, [rax+rdx*2]\n  0x4073c2  test    eax, eax\n  0x4073c4  jne     0x4073d8\n  0x4073d8  retn     {__return_addr}\n  0x4073c6  mov     rax, qword [rdi]\n  0x4073c9  mov     rdi, qword [rsi]\n  0x4073cc  mov     rsi, rax\n  0x4073cf  jmp     strcmp",
        "hlil": "int64_t rax = arg1[0xe]\nint64_t temp0 = arg2[0xe]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg1[0xf]\nint64_t temp1 = arg2[0xf]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nreturn strcmp(*arg2, *arg1) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[0xe];\n    int64_t temp0 = arg2[0xe];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg1[0xf];\n    int64_t temp1 = arg2[0xf];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg2, *(uint64_t*)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_by_fields",
          "confidence": 0.86,
          "rationale": "The function compares two structures by numeric fields at offsets 0xe and 0xf, then falls back to a string comparison using strcmp, indicating a comparator for sorting or ordering objects.",
          "evidence_refs": [
            "imports:strcmp"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_struct_entries",
            "ai_struct_key_compare"
          ]
        },
        "explain": {
          "summary": "The function acts as a comparator for two data structures: it first compares integer fields at offsets 0xE and 0xF, returning a nonzero ordering value if they differ; if those fields are equal it falls back to a lexical comparison of the strings referenced by the first pointer in each structure via strcmp.",
          "details": [
            "Loads 64bit values from arg1[0xE] and arg2[0xE] and computes a signed/unsigned comparison, contributing to the result.",
            "Loads 64bit values from arg1[0xF] and arg2[0xF] and performs a second comparison, combining both results into a signed ordering integer.",
            "If the combined comparison result is zero, it tailcalls strcmp on the pointers stored at the start of each structure and returns that result."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Whether the fields at offsets 0xE and 0xF are signed or unsigned integers.",
            "Exact semantics of the bitwise manipulation used to compute the ordering value."
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x4073e0",
      "original_name": "sub_4073e0",
      "final_name": "ai_struct_field_string_compare",
      "score": 17.6,
      "bb_count": 3,
      "insn_est": 22,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x4073e0  endbr64 \n  0x4073e4  mov     rax, qword [rsi+0x70]\n  0x4073e8  xor     edx, edx  {0x0}\n  0x4073ea  cmp     qword [rdi+0x70], rax\n  0x4073ee  setg    al\n  0x4073f1  setl    dl\n  0x4073f4  movzx   eax, al\n  0x4073f7  sub     edx, eax\n  0x4073f9  mov     rax, qword [rsi+0x78]\n  0x4073fd  cmp     qword [rdi+0x78], rax\n  0x407401  setl    al\n  0x407404  setg    cl\n  0x407407  movzx   eax, al\n  0x40740a  movzx   ecx, cl\n  0x40740d  sub     eax, ecx\n  0x40740f  lea     eax, [rax+rdx*2]\n  0x407412  test    eax, eax\n  0x407414  jne     0x407428\n  0x407428  retn     {__return_addr}\n  0x407416  mov     rsi, qword [rsi]\n  0x407419  mov     rdi, qword [rdi]\n  0x40741c  jmp     strcmp",
        "hlil": "int64_t rax = arg2[0xe]\nint64_t temp0 = arg1[0xe]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg2[0xf]\nint64_t temp1 = arg1[0xf]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nreturn strcmp(*arg1, *arg2) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[0xe];\n    int64_t temp0 = arg1[0xe];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg2[0xf];\n    int64_t temp1 = arg1[0xf];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_field_string_compare",
          "confidence": 0.86,
          "rationale": "The function compares two structures by fields at offsets 0xe and 0xf, then falls back to strcmp on their string pointers, indicating a custom comparator for sorting or ordering objects.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_custom_struct_compare",
            "ai_field_then_name_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two objects by two integer fields at offsets 0xE and 0xF, returning a signed ordering value; if those fields are equal it falls back to a lexical string comparison of the pointers at offset 0.",
          "details": [
            "It loads 64bit values from arg1[0xE] and arg2[0xE] and computes a signed comparison result weighted by 2.",
            "It then loads values from arg1[0xF] and arg2[0xF] and computes a signed comparison result weighted by 1, adding both to form the final ordering.",
            "If the combined result is zero (both fields equal), it tailcalls strcmp on the pointers stored at the start of each structure."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "strings:none"
          ],
          "unknowns": [
            "Exact data type and semantic meaning of the fields at offsets 0xE and 0xF",
            "Whether the comparison is signed or unsigned for those fields"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407430",
      "original_name": "sub_407430",
      "final_name": "ai_compare_struct_by_type_and_range",
      "score": 38.3,
      "bb_count": 10,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407430  endbr64 \n  0x407434  mov     rdx, rdi\n  0x407437  mov     rcx, rsi\n  0x40743a  mov     edi, dword [rsi+0xa8]\n  0x407440  mov     eax, dword [rdx+0xa8]\n  0x407446  cmp     eax, 0x3\n  0x407449  sete    sil\n  0x40744d  cmp     eax, 0x9\n  0x407450  sete    al\n  0x407453  or      esi, eax\n  0x407455  cmp     edi, 0x3\n  0x407458  je      0x407488\n  0x407488  mov     eax, 0x1\n  0x40748d  test    sil, sil\n  0x407490  je      0x4074d8\n  0x40745a  cmp     edi, 0x9\n  0x40745d  je      0x407488\n  0x4074d8  mov     esi, dword [rdx+0xac]\n  0x4074de  xor     edi, edi  {0x0}\n  0x4074e0  and     esi, 0xf000\n  0x4074e6  cmp     esi, 0x4000\n  0x4074ec  sete    dil\n  0x4074f0  sub     eax, edi\n  0x4074f2  jne     0x407483\n  0x407492  mov     rax, qword [rcx+0x70]\n  0x407496  xor     esi, esi  {0x0}\n  0x407498  cmp     qword [rdx+0x70], rax\n  0x40749c  setg    al\n  0x40749f  setl    sil\n  0x4074a3  movzx   eax, al\n  ... (188 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nchar rsi = arg2.b | rax.b\nuint32_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi == 0)\nlabel_4074ec:\nrdi.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = rax_3 - rdi\nif (rax_3 == rdi)\ngoto label_407492\nlabel_407492:\nint64_t rax_4 = rcx[0xe]\nint64_t temp1_1 = arg1[0xe]\nbool cond:0_1 = temp1_1 s< rax_4\nrax_4.b = temp1_1 s> rax_4\nint32_t rsi_1\nrsi_1.b = cond:0_1\nint64_t rax_6 = rcx[0xf]\nint64_t temp2_1 = arg1[0xf]\nbool cond:1_1 = temp2_1 s> rax_6\nrax_6.b = temp2_1 s< rax_6\nrdi.b = cond:1_1\nresult = zx.d(rax_6.b) - zx.d(rdi.b) + ((rsi_1 - zx.d(rax_4.b)) << 1)\nif (result == 0)\nreturn strcmp(*arg1, *rcx) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi == 0)\ngoto label_4074ec\nresult = rax_3 - 1\nif (rax_3 == 1)\ngoto label_407492\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rsi = (uint8_t)arg2 | (uint8_t)rax;\n    uint32_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rsi)\n        {\n        label_4074ec:\n            (uint8_t)rdi = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = rax_3 - rdi;\n            \n            if (rax_3 == rdi)\n                goto label_407492;\n        }\n        else\n        {\n        label_407492:\n            int64_t rax_4 = rcx[0xe];\n            int64_t temp1_1 = arg1[0xe];\n            bool cond:0_1 = temp1_1 < rax_4;\n            (uint8_t)rax_4 = temp1_1 > rax_4;\n            int32_t rsi_1;\n            (uint8_t)rsi_1 = cond:0_1;\n            int64_t rax_6 = rcx[0xf];\n            int64_t temp2_1 = arg1[0xf];\n            bool cond:1_1 = temp2_1 > rax_6;\n            (uint8_t)rax_6 = temp2_1 < rax_6;\n            (uint8_t)rdi = cond:1_1;\n            result = (uint32_t)(uint8_t)rax_6 - (uint32_t)(uint8_t)rdi\n                + ((rsi_1 - (uint32_t)(uint8_t)rax_4) << 1);\n            \n            if (!result)\n                /* tailcall */\n                return strcmp(*(uint64_t*)arg1, *(uint64_t*)rcx);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_range",
          "confidence": 0.78,
          "rationale": "The function checks type fields (values 3 or 9), examines flag bits at offset 0xac, compares range values at offsets 0xe/0xf, and finally calls strcmp on the objects' string fields, indicating a custom comparator for structured data.",
          "evidence_refs": [
            "imports:strcmp",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_custom_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two data structures, first checking a type field at offset 0x15 for values 3 or 9, then evaluating a flag in a masked field at offset 0xac. If those checks pass, it compares two 64bit fields at offsets 0xe and 0xf, and only if those numeric fields match does it fall back to a string comparison via strcmp.",
          "details": [
            "It reads arg1[0x15] and arg2[0x15] and proceeds only when either value is 3 or 9.",
            "A mask (0xf000) on a field at offset 0xac is compared against 0x4000 to influence the comparison logic.",
            "It then compares the 64bit values at offsets 0xe and 0xf of both structures, combining the results into a numeric 'result'.",
            "If the numeric fields are equal (result == 0), the function tailcalls strcmp on the pointers at the start of each structure."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0x15, 0xac, 0xe, and 0xf",
            "Purpose of the constants 0xf000 and 0x4000 beyond the mask check"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407500",
      "original_name": "sub_407500",
      "final_name": "ai_struct_compare_by_type_and_range",
      "score": 38.3,
      "bb_count": 10,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407500  endbr64 \n  0x407504  mov     rdx, rdi\n  0x407507  mov     rcx, rsi\n  0x40750a  mov     edi, dword [rsi+0xa8]\n  0x407510  mov     eax, dword [rdx+0xa8]\n  0x407516  cmp     eax, 0x3\n  0x407519  sete    sil\n  0x40751d  cmp     eax, 0x9\n  0x407520  sete    al\n  0x407523  or      esi, eax\n  0x407525  cmp     edi, 0x3\n  0x407528  je      0x407558\n  0x407558  mov     eax, 0x1\n  0x40755d  test    sil, sil\n  0x407560  je      0x4075a8\n  0x40752a  cmp     edi, 0x9\n  0x40752d  je      0x407558\n  0x4075a8  mov     esi, dword [rdx+0xac]\n  0x4075ae  xor     edi, edi  {0x0}\n  0x4075b0  and     esi, 0xf000\n  0x4075b6  cmp     esi, 0x4000\n  0x4075bc  sete    dil\n  0x4075c0  sub     eax, edi\n  0x4075c2  jne     0x407553\n  0x407562  mov     rax, qword [rdx+0x70]\n  0x407566  xor     esi, esi  {0x0}\n  0x407568  cmp     qword [rcx+0x70], rax\n  0x40756c  setg    al\n  0x40756f  setl    sil\n  0x407573  movzx   eax, al\n  ... (188 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nchar rsi = arg2.b | rax.b\nuint32_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi == 0)\nlabel_4075bc:\nrdi.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = rax_3 - rdi\nif (rax_3 == rdi)\ngoto label_407562\nlabel_407562:\nint64_t rax_4 = arg1[0xe]\nint64_t temp1_1 = rcx[0xe]\nbool cond:0_1 = temp1_1 s< rax_4\nrax_4.b = temp1_1 s> rax_4\nint32_t rsi_1\nrsi_1.b = cond:0_1\nint64_t rax_6 = arg1[0xf]\nint64_t temp2_1 = rcx[0xf]\nbool cond:1_1 = temp2_1 s> rax_6\nrax_6.b = temp2_1 s< rax_6\nrdi.b = cond:1_1\nresult = zx.d(rax_6.b) - zx.d(rdi.b) + ((rsi_1 - zx.d(rax_4.b)) << 1)\nif (result == 0)\nreturn strcmp(*rcx, *arg1) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi == 0)\ngoto label_4075bc\nresult = rax_3 - 1\nif (rax_3 == 1)\ngoto label_407562\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rsi = (uint8_t)arg2 | (uint8_t)rax;\n    uint32_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rsi)\n        {\n        label_4075bc:\n            (uint8_t)rdi = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = rax_3 - rdi;\n            \n            if (rax_3 == rdi)\n                goto label_407562;\n        }\n        else\n        {\n        label_407562:\n            int64_t rax_4 = arg1[0xe];\n            int64_t temp1_1 = rcx[0xe];\n            bool cond:0_1 = temp1_1 < rax_4;\n            (uint8_t)rax_4 = temp1_1 > rax_4;\n            int32_t rsi_1;\n            (uint8_t)rsi_1 = cond:0_1;\n            int64_t rax_6 = arg1[0xf];\n            int64_t temp2_1 = rcx[0xf];\n            bool cond:1_1 = temp2_1 > rax_6;\n            (uint8_t)rax_6 = temp2_1 < rax_6;\n            (uint8_t)rdi = cond:1_1;\n            result = (uint32_t)(uint8_t)rax_6 - (uint32_t)(uint8_t)rdi\n                + ((rsi_1 - (uint32_t)(uint8_t)rax_4) << 1);\n            \n            if (!result)\n                /* tailcall */\n                return strcmp(*(uint64_t*)rcx, *(uint64_t*)arg1);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_by_type_and_range",
          "confidence": 0.86,
          "rationale": "The function checks type fields (values 3 or 9), evaluates flag bits, compares range values, and finally falls back to strcmp, indicating it is a comparator for structured objects.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_entries",
            "ai_struct_cmp"
          ]
        },
        "explain": {
          "summary": "The function compares two data structures, checking a type field at offset 0x15 for values 3 or 9, then verifying a flag in the 0xac field (mask 0xf000 == 0x4000) and matching range fields at offsets 0xe and 0xf. If all checks succeed, it delegates to strcmp to compare the strings pointed to by the structures; otherwise it returns a boolean-like result based on the checks.",
          "details": [
            "It reads arg1[0x15] and arg2[0x15] and proceeds only if either value is 3 or 9.",
            "It checks whether the high nibble of the dword at offset 0xac equals 0x4000 for both structures.",
            "It compares the 64-bit values at offsets 0xe and 0xf between the two structures, combining the results into a zero/non-zero flag.",
            "When the flag is zero (indicating equality), it tailcalls strcmp on the pointers stored at the start of each structure."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantics of the type values (3, 9) and the flag at offset 0xac",
            "What the function returns when the early checks fail or when the range comparison is nonzero"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x4075d0",
      "original_name": "sub_4075d0",
      "final_name": "ai_struct_comparator",
      "score": 17.9,
      "bb_count": 3,
      "insn_est": 23,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x4075d0  endbr64 \n  0x4075d4  mov     rax, qword [rdi+0x60]\n  0x4075d8  xor     edx, edx  {0x0}\n  0x4075da  cmp     qword [rsi+0x60], rax\n  0x4075de  setg    al\n  0x4075e1  setl    dl\n  0x4075e4  movzx   eax, al\n  0x4075e7  sub     edx, eax\n  0x4075e9  mov     rax, qword [rdi+0x68]\n  0x4075ed  cmp     qword [rsi+0x68], rax\n  0x4075f1  setl    al\n  0x4075f4  setg    cl\n  0x4075f7  movzx   eax, al\n  0x4075fa  movzx   ecx, cl\n  0x4075fd  sub     eax, ecx\n  0x4075ff  lea     eax, [rax+rdx*2]\n  0x407602  test    eax, eax\n  0x407604  jne     0x407618\n  0x407618  retn     {__return_addr}\n  0x407606  mov     rax, qword [rdi]\n  0x407609  mov     rdi, qword [rsi]\n  0x40760c  mov     rsi, rax\n  0x40760f  jmp     strcmp",
        "hlil": "int64_t rax = arg1[0xc]\nint64_t temp0 = arg2[0xc]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg1[0xd]\nint64_t temp1 = arg2[0xd]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nreturn strcmp(*arg2, *arg1) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[0xc];\n    int64_t temp0 = arg2[0xc];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg1[0xd];\n    int64_t temp1 = arg2[0xd];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg2, *(uint64_t*)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_comparator",
          "confidence": 0.86,
          "rationale": "The function compares two structures by numeric fields at offsets 0xc and 0xd, then falls back to strcmp on their string pointers, typical of a custom comparator used for sorting or searching.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_struct",
            "ai_entry_comparator"
          ]
        },
        "explain": {
          "summary": "The function compares two structures by first evaluating the 64bit values at offset 0xC, then at offset 0xD, and finally falling back to a lexical strcmp of the strings pointed to by the first field of each structure, returning an integer ordering result.",
          "details": [
            "Loads arg1[0xC] and arg2[0xC] and determines ordering using < and > comparisons.",
            "If the first numeric fields are equal, it compares arg1[0xD] and arg2[0xD] similarly.",
            "When both numeric fields match, it calls strcmp on the pointers stored at the start of each structure."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact signedness and size of the fields at offsets 0xC and 0xD",
            "Purpose of the specific bitwise result calculation beyond ordering"
          ],
          "confidence": 0.94
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407620",
      "original_name": "sub_407620",
      "final_name": "ai_struct_comparator",
      "score": 17.6,
      "bb_count": 3,
      "insn_est": 22,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407620  endbr64 \n  0x407624  mov     rax, qword [rsi+0x60]\n  0x407628  xor     edx, edx  {0x0}\n  0x40762a  cmp     qword [rdi+0x60], rax\n  0x40762e  setg    al\n  0x407631  setl    dl\n  0x407634  movzx   eax, al\n  0x407637  sub     edx, eax\n  0x407639  mov     rax, qword [rsi+0x68]\n  0x40763d  cmp     qword [rdi+0x68], rax\n  0x407641  setl    al\n  0x407644  setg    cl\n  0x407647  movzx   eax, al\n  0x40764a  movzx   ecx, cl\n  0x40764d  sub     eax, ecx\n  0x40764f  lea     eax, [rax+rdx*2]\n  0x407652  test    eax, eax\n  0x407654  jne     0x407668\n  0x407668  retn     {__return_addr}\n  0x407656  mov     rsi, qword [rsi]\n  0x407659  mov     rdi, qword [rdi]\n  0x40765c  jmp     strcmp",
        "hlil": "int64_t rax = arg2[0xc]\nint64_t temp0 = arg1[0xc]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg2[0xd]\nint64_t temp1 = arg1[0xd]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nreturn strcmp(*arg1, *arg2) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[0xc];\n    int64_t temp0 = arg1[0xc];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg2[0xd];\n    int64_t temp1 = arg1[0xd];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_comparator",
          "confidence": 0.86,
          "rationale": "The function compares two objects by their fields at offsets 0xc and 0xd, returning a numeric ordering result, and falls back to strcmp on the first pointer field. This pattern matches a custom comparator used for sorting or ordering structures.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_compare_entries",
            "ai_custom_sort_key"
          ]
        },
        "explain": {
          "summary": "The function implements a custom comparator for two structures: it first compares 64bit values at offsets 0xC and 0xD, producing a signed result based on those numeric fields; if those fields are equal it falls back to a lexical comparison of the strings pointed to by the structures using strcmp.",
          "details": [
            "Loads two 64bit values from each argument at offsets 0xC and 0xD and evaluates <, > relationships to compute a small integer result.",
            "Combines the boolean outcomes into a single integer (result = (secondDiff) + ((firstDiff) << 1)).",
            "If the numeric comparison yields zero (both fields equal), the function calls strcmp on the pointers stored at the start of each structure and returns that result."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0xC and 0xD",
            "Structure layout beyond the examined fields"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x407670",
      "original_name": "sub_407670",
      "final_name": "ai_compare_struct_by_type_and_name",
      "score": 38.3,
      "bb_count": 10,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407670  endbr64 \n  0x407674  mov     rdx, rdi\n  0x407677  mov     rcx, rsi\n  0x40767a  mov     edi, dword [rsi+0xa8]\n  0x407680  mov     eax, dword [rdx+0xa8]\n  0x407686  cmp     eax, 0x3\n  0x407689  sete    sil\n  0x40768d  cmp     eax, 0x9\n  0x407690  sete    al\n  0x407693  or      esi, eax\n  0x407695  cmp     edi, 0x3\n  0x407698  je      0x4076c8\n  0x4076c8  mov     eax, 0x1\n  0x4076cd  test    sil, sil\n  0x4076d0  je      0x407718\n  0x40769a  cmp     edi, 0x9\n  0x40769d  je      0x4076c8\n  0x407718  mov     esi, dword [rdx+0xac]\n  0x40771e  xor     edi, edi  {0x0}\n  0x407720  and     esi, 0xf000\n  0x407726  cmp     esi, 0x4000\n  0x40772c  sete    dil\n  0x407730  sub     eax, edi\n  0x407732  jne     0x4076c3\n  0x4076d2  mov     rax, qword [rcx+0x60]\n  0x4076d6  xor     esi, esi  {0x0}\n  0x4076d8  cmp     qword [rdx+0x60], rax\n  0x4076dc  setg    al\n  0x4076df  setl    sil\n  0x4076e3  movzx   eax, al\n  ... (188 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nchar rsi = arg2.b | rax.b\nuint32_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi == 0)\nlabel_40772c:\nrdi.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = rax_3 - rdi\nif (rax_3 == rdi)\ngoto label_4076d2\nlabel_4076d2:\nint64_t rax_4 = rcx[0xc]\nint64_t temp1_1 = arg1[0xc]\nbool cond:0_1 = temp1_1 s< rax_4\nrax_4.b = temp1_1 s> rax_4\nint32_t rsi_1\nrsi_1.b = cond:0_1\nint64_t rax_6 = rcx[0xd]\nint64_t temp2_1 = arg1[0xd]\nbool cond:1_1 = temp2_1 s> rax_6\nrax_6.b = temp2_1 s< rax_6\nrdi.b = cond:1_1\nresult = zx.d(rax_6.b) - zx.d(rdi.b) + ((rsi_1 - zx.d(rax_4.b)) << 1)\nif (result == 0)\nreturn strcmp(*arg1, *rcx) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi == 0)\ngoto label_40772c\nresult = rax_3 - 1\nif (rax_3 == 1)\ngoto label_4076d2\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rsi = (uint8_t)arg2 | (uint8_t)rax;\n    uint32_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rsi)\n        {\n        label_40772c:\n            (uint8_t)rdi = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = rax_3 - rdi;\n            \n            if (rax_3 == rdi)\n                goto label_4076d2;\n        }\n        else\n        {\n        label_4076d2:\n            int64_t rax_4 = rcx[0xc];\n            int64_t temp1_1 = arg1[0xc];\n            bool cond:0_1 = temp1_1 < rax_4;\n            (uint8_t)rax_4 = temp1_1 > rax_4;\n            int32_t rsi_1;\n            (uint8_t)rsi_1 = cond:0_1;\n            int64_t rax_6 = rcx[0xd];\n            int64_t temp2_1 = arg1[0xd];\n            bool cond:1_1 = temp2_1 > rax_6;\n            (uint8_t)rax_6 = temp2_1 < rax_6;\n            (uint8_t)rdi = cond:1_1;\n            result = (uint32_t)(uint8_t)rax_6 - (uint32_t)(uint8_t)rdi\n                + ((rsi_1 - (uint32_t)(uint8_t)rax_4) << 1);\n            \n            if (!result)\n                /* tailcall */\n                return strcmp(*(uint64_t*)arg1, *(uint64_t*)rcx);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_name",
          "confidence": 0.78,
          "rationale": "The function checks type fields (values 3 or 9), examines a flag mask, compares numeric fields, and finally delegates to strcmp to compare string pointers, indicating it is a comparator for structured entries based on type, flags, and name.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "strings:none"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_struct_comparator",
            "ai_entry_compare"
          ]
        },
        "explain": {
          "summary": "sub_407670 compares two data structures based on type fields and flag bits, then optionally compares numeric range fields before delegating to a string comparison. If both structures have type values 3 or 9, or a specific flag (0x4000) is set, it checks the values at offsets 0xc and 0xd for equality; when those match it calls strcmp on the first member of each structure. The function returns the result of strcmp or a derived integer indicating mismatch.",
          "details": [
            "The function reads a type field at offset 0x15 from both arguments and sets a flag if either equals 3 or 9.",
            "When the type flag is set, it checks a flag bitmask ((value & 0xf000) == 0x4000) in the first argument to influence control flow.",
            "It then compares 64bit values at offsets 0xc and 0xd of the two structures, combining the comparison results into a temporary integer.",
            "If those numeric comparisons indicate equality, the function tailcalls strcmp (imported at 0x4046c0) on the pointers stored at offset 0 of each structure.",
            "If the initial type/flag checks fail, the function returns a nonzero integer derived from the flag test."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0x15, 0xc, 0xd, and 0xac",
            "Why the function returns rax_3 - rdi in some branches",
            "The broader context in which this comparison is used"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x407740",
      "original_name": "sub_407740",
      "final_name": "ai_compare_struct_by_type_and_name",
      "score": 38.3,
      "bb_count": 10,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407740  endbr64 \n  0x407744  mov     rdx, rdi\n  0x407747  mov     rcx, rsi\n  0x40774a  mov     edi, dword [rsi+0xa8]\n  0x407750  mov     eax, dword [rdx+0xa8]\n  0x407756  cmp     eax, 0x3\n  0x407759  sete    sil\n  0x40775d  cmp     eax, 0x9\n  0x407760  sete    al\n  0x407763  or      esi, eax\n  0x407765  cmp     edi, 0x3\n  0x407768  je      0x407798\n  0x407798  mov     eax, 0x1\n  0x40779d  test    sil, sil\n  0x4077a0  je      0x4077e8\n  0x40776a  cmp     edi, 0x9\n  0x40776d  je      0x407798\n  0x4077e8  mov     esi, dword [rdx+0xac]\n  0x4077ee  xor     edi, edi  {0x0}\n  0x4077f0  and     esi, 0xf000\n  0x4077f6  cmp     esi, 0x4000\n  0x4077fc  sete    dil\n  0x407800  sub     eax, edi\n  0x407802  jne     0x407793\n  0x4077a2  mov     rax, qword [rdx+0x60]\n  0x4077a6  xor     esi, esi  {0x0}\n  0x4077a8  cmp     qword [rcx+0x60], rax\n  0x4077ac  setg    al\n  0x4077af  setl    sil\n  0x4077b3  movzx   eax, al\n  ... (188 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nchar rsi = arg2.b | rax.b\nuint32_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi == 0)\nlabel_4077fc:\nrdi.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = rax_3 - rdi\nif (rax_3 == rdi)\ngoto label_4077a2\nlabel_4077a2:\nint64_t rax_4 = arg1[0xc]\nint64_t temp1_1 = rcx[0xc]\nbool cond:0_1 = temp1_1 s< rax_4\nrax_4.b = temp1_1 s> rax_4\nint32_t rsi_1\nrsi_1.b = cond:0_1\nint64_t rax_6 = arg1[0xd]\nint64_t temp2_1 = rcx[0xd]\nbool cond:1_1 = temp2_1 s> rax_6\nrax_6.b = temp2_1 s< rax_6\nrdi.b = cond:1_1\nresult = zx.d(rax_6.b) - zx.d(rdi.b) + ((rsi_1 - zx.d(rax_4.b)) << 1)\nif (result == 0)\nreturn strcmp(*rcx, *arg1) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi == 0)\ngoto label_4077fc\nresult = rax_3 - 1\nif (rax_3 == 1)\ngoto label_4077a2\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rsi = (uint8_t)arg2 | (uint8_t)rax;\n    uint32_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rsi)\n        {\n        label_4077fc:\n            (uint8_t)rdi = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = rax_3 - rdi;\n            \n            if (rax_3 == rdi)\n                goto label_4077a2;\n        }\n        else\n        {\n        label_4077a2:\n            int64_t rax_4 = arg1[0xc];\n            int64_t temp1_1 = rcx[0xc];\n            bool cond:0_1 = temp1_1 < rax_4;\n            (uint8_t)rax_4 = temp1_1 > rax_4;\n            int32_t rsi_1;\n            (uint8_t)rsi_1 = cond:0_1;\n            int64_t rax_6 = arg1[0xd];\n            int64_t temp2_1 = rcx[0xd];\n            bool cond:1_1 = temp2_1 > rax_6;\n            (uint8_t)rax_6 = temp2_1 < rax_6;\n            (uint8_t)rdi = cond:1_1;\n            result = (uint32_t)(uint8_t)rax_6 - (uint32_t)(uint8_t)rdi\n                + ((rsi_1 - (uint32_t)(uint8_t)rax_4) << 1);\n            \n            if (!result)\n                /* tailcall */\n                return strcmp(*(uint64_t*)rcx, *(uint64_t*)arg1);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_name",
          "confidence": 0.78,
          "rationale": "The function checks type fields (values 3 or 9), mask flags at offset 0xac, compares numeric fields at offsets 0xc and 0xd, and finally falls back to strcmp on string fields, indicating it is a comparator for structured objects based on type, flags, and name.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_compare_entries"
          ]
        },
        "explain": {
          "summary": "The function compares two data structures (arg1 and arg2) primarily when their type field at offset 0x15 equals 3 or 9. It checks a flag in a field at offset 0xac, compares two numeric fields at offsets 0xc and 0xd, and if those are equal it falls back to a lexical string comparison via strcmp.",
          "details": [
            "It first verifies that both structures have a type value of 3 or 9 (offset 0x15).",
            "It tests a flag by masking the 32bit value at offset 0xac with 0xf000 and checking for 0x4000.",
            "It then compares the 64bit values at offsets 0xc and 0xd of each structure, combining the results into a numeric comparison.",
            "If the numeric fields match, it calls strcmp on the pointers stored at the start of each structure to perform a final string comparison."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantics of the fields at offsets 0xc and 0xd (e.g., coordinates, timestamps) are not identified.",
            "Behavior for types other than 3 or 9 is truncated in the provided snippet."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407810",
      "original_name": "sub_407810",
      "final_name": "ai_struct_compare_by_fields",
      "score": 17.9,
      "bb_count": 3,
      "insn_est": 23,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407810  endbr64 \n  0x407814  mov     rax, qword [rdi+0x70]\n  0x407818  xor     edx, edx  {0x0}\n  0x40781a  cmp     qword [rsi+0x70], rax\n  0x40781e  setg    al\n  0x407821  setl    dl\n  0x407824  movzx   eax, al\n  0x407827  sub     edx, eax\n  0x407829  mov     rax, qword [rdi+0x78]\n  0x40782d  cmp     qword [rsi+0x78], rax\n  0x407831  setl    al\n  0x407834  setg    cl\n  0x407837  movzx   eax, al\n  0x40783a  movzx   ecx, cl\n  0x40783d  sub     eax, ecx\n  0x40783f  lea     eax, [rax+rdx*2]\n  0x407842  test    eax, eax\n  0x407844  jne     0x407858\n  0x407858  retn     {__return_addr}\n  0x407846  mov     rax, qword [rdi]\n  0x407849  mov     rdi, qword [rsi]\n  0x40784c  mov     rsi, rax\n  0x40784f  jmp     strcmp",
        "hlil": "int64_t rax = arg1[0xe]\nint64_t temp0 = arg2[0xe]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg1[0xf]\nint64_t temp1 = arg2[0xf]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nreturn strcmp(*arg2, *arg1) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[0xe];\n    int64_t temp0 = arg2[0xe];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg1[0xf];\n    int64_t temp1 = arg2[0xf];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg2, *(uint64_t*)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_by_fields",
          "confidence": 0.86,
          "rationale": "The function compares two structures by numeric fields at offsets 0xe and 0xf, then falls back to strcmp on their string members, acting as a custom comparator for sorting or ordering.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_compare_entries",
            "ai_sort_key_compare"
          ]
        },
        "explain": {
          "summary": "sub_407810 is a comparator that orders two objects by first comparing a 64bit field at offset 0xE, then a field at offset 0xF, and finally falling back to a lexical string comparison of the pointers at the start of each object.",
          "details": [
            "It loads arg1[0xE] and arg2[0xE] and computes a boolean result based on < and > comparisons, contributing to a numeric result.",
            "It then loads arg1[0xF] and arg2[0xF] and similarly contributes to the result; if the combined result is nonzero it returns it.",
            "When the numeric fields are equal (result == 0), it tailcalls strcmp on the first 8byte pointers of each argument to break the tie."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "strings:none"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0xE and 0xF (e.g., signed vs unsigned, data type).",
            "Why the result is computed with the specific bitwise/shift expression rather than a straightforward subtraction."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x407860",
      "original_name": "sub_407860",
      "final_name": "ai_struct_field_string_compare",
      "score": 17.6,
      "bb_count": 3,
      "insn_est": 22,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407860  endbr64 \n  0x407864  mov     rax, qword [rsi+0x70]\n  0x407868  xor     edx, edx  {0x0}\n  0x40786a  cmp     qword [rdi+0x70], rax\n  0x40786e  setg    al\n  0x407871  setl    dl\n  0x407874  movzx   eax, al\n  0x407877  sub     edx, eax\n  0x407879  mov     rax, qword [rsi+0x78]\n  0x40787d  cmp     qword [rdi+0x78], rax\n  0x407881  setl    al\n  0x407884  setg    cl\n  0x407887  movzx   eax, al\n  0x40788a  movzx   ecx, cl\n  0x40788d  sub     eax, ecx\n  0x40788f  lea     eax, [rax+rdx*2]\n  0x407892  test    eax, eax\n  0x407894  jne     0x4078a8\n  0x4078a8  retn     {__return_addr}\n  0x407896  mov     rsi, qword [rsi]\n  0x407899  mov     rdi, qword [rdi]\n  0x40789c  jmp     strcmp",
        "hlil": "int64_t rax = arg2[0xe]\nint64_t temp0 = arg1[0xe]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg2[0xf]\nint64_t temp1 = arg1[0xf]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nreturn strcmp(*arg1, *arg2) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[0xe];\n    int64_t temp0 = arg1[0xe];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg2[0xf];\n    int64_t temp1 = arg1[0xf];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_field_string_compare",
          "confidence": 0.78,
          "rationale": "The function compares two structures by two numeric fields (offsets 0xE and 0xF) and falls back to strcmp on their string members, acting as a custom comparator.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_custom_struct_comparator",
            "ai_field_then_name_compare"
          ]
        },
        "explain": {
          "summary": "The function implements a comparator that first compares two 64-bit fields at offsets 0xE and 0xF of the two input structures; if they differ it returns a non-zero ordering value, otherwise it falls back to a lexical string comparison using strcmp on the pointers at the start of each structure.",
          "details": [
            "It loads arg1[0xe] and arg2[0xe] and sets flags for less/greater, then does the same for arg1[0xf] and arg2[0xf].",
            "A result is computed from the comparison flags; a non-zero result is returned immediately, otherwise strcmp is called on the first 8-byte pointers of the structures."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "strings:none"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0xE and 0xF (e.g., version, timestamp).",
            "Whether the arguments are pointers to structs or arrays of 64-bit values."
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x4078b0",
      "original_name": "sub_4078b0",
      "final_name": "ai_compare_struct_by_type_and_name",
      "score": 38.3,
      "bb_count": 10,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x4078b0  endbr64 \n  0x4078b4  mov     rdx, rdi\n  0x4078b7  mov     rcx, rsi\n  0x4078ba  mov     edi, dword [rsi+0xa8]\n  0x4078c0  mov     eax, dword [rdx+0xa8]\n  0x4078c6  cmp     eax, 0x3\n  0x4078c9  sete    sil\n  0x4078cd  cmp     eax, 0x9\n  0x4078d0  sete    al\n  0x4078d3  or      esi, eax\n  0x4078d5  cmp     edi, 0x3\n  0x4078d8  je      0x407908\n  0x407908  mov     eax, 0x1\n  0x40790d  test    sil, sil\n  0x407910  je      0x407958\n  0x4078da  cmp     edi, 0x9\n  0x4078dd  je      0x407908\n  0x407958  mov     esi, dword [rdx+0xac]\n  0x40795e  xor     edi, edi  {0x0}\n  0x407960  and     esi, 0xf000\n  0x407966  cmp     esi, 0x4000\n  0x40796c  sete    dil\n  0x407970  sub     eax, edi\n  0x407972  jne     0x407903\n  0x407912  mov     rax, qword [rcx+0x70]\n  0x407916  xor     esi, esi  {0x0}\n  0x407918  cmp     qword [rdx+0x70], rax\n  0x40791c  setg    al\n  0x40791f  setl    sil\n  0x407923  movzx   eax, al\n  ... (188 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nchar rsi = arg2.b | rax.b\nuint32_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi == 0)\nlabel_40796c:\nrdi.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = rax_3 - rdi\nif (rax_3 == rdi)\ngoto label_407912\nlabel_407912:\nint64_t rax_4 = rcx[0xe]\nint64_t temp1_1 = arg1[0xe]\nbool cond:0_1 = temp1_1 s< rax_4\nrax_4.b = temp1_1 s> rax_4\nint32_t rsi_1\nrsi_1.b = cond:0_1\nint64_t rax_6 = rcx[0xf]\nint64_t temp2_1 = arg1[0xf]\nbool cond:1_1 = temp2_1 s> rax_6\nrax_6.b = temp2_1 s< rax_6\nrdi.b = cond:1_1\nresult = zx.d(rax_6.b) - zx.d(rdi.b) + ((rsi_1 - zx.d(rax_4.b)) << 1)\nif (result == 0)\nreturn strcmp(*arg1, *rcx) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi == 0)\ngoto label_40796c\nresult = rax_3 - 1\nif (rax_3 == 1)\ngoto label_407912\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rsi = (uint8_t)arg2 | (uint8_t)rax;\n    uint32_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rsi)\n        {\n        label_40796c:\n            (uint8_t)rdi = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = rax_3 - rdi;\n            \n            if (rax_3 == rdi)\n                goto label_407912;\n        }\n        else\n        {\n        label_407912:\n            int64_t rax_4 = rcx[0xe];\n            int64_t temp1_1 = arg1[0xe];\n            bool cond:0_1 = temp1_1 < rax_4;\n            (uint8_t)rax_4 = temp1_1 > rax_4;\n            int32_t rsi_1;\n            (uint8_t)rsi_1 = cond:0_1;\n            int64_t rax_6 = rcx[0xf];\n            int64_t temp2_1 = arg1[0xf];\n            bool cond:1_1 = temp2_1 > rax_6;\n            (uint8_t)rax_6 = temp2_1 < rax_6;\n            (uint8_t)rdi = cond:1_1;\n            result = (uint32_t)(uint8_t)rax_6 - (uint32_t)(uint8_t)rdi\n                + ((rsi_1 - (uint32_t)(uint8_t)rax_4) << 1);\n            \n            if (!result)\n                /* tailcall */\n                return strcmp(*(uint64_t*)arg1, *(uint64_t*)rcx);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_name",
          "confidence": 0.78,
          "rationale": "The function checks type fields (values 3 or 9), examines flag bits, compares numeric fields, and finally delegates to strcmp, indicating it implements a custom comparator for structured objects.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_struct_comparator",
            "ai_entry_compare"
          ]
        },
        "explain": {
          "summary": "sub_4078b0 compares two data structures, first checking a type field at offset 0x15 for values 3 or 9, then evaluating a flag in the 0xac field masked with 0xf000 against 0x4000. If those checks pass, it compares range fields at offsets 0xe and 0xf, and finally delegates to strcmp to compare the strings referenced by the structures.",
          "details": [
            "The function reads a type identifier from both arguments (arg1[0x15] and arg2[0x15]) and proceeds only if either is 3 or 9.",
            "It checks a flag in each structure: (*(uint32_t*)((char*)argX + 0xac) & 0xf000) == 0x4000.",
            "If the flag matches, it compares the 64bit values at offsets 0xe and 0xf of both structures, using both lessthan and greaterthan comparisons to compute a result.",
            "When all earlier conditions are satisfied and the computed result is zero, the function tailcalls strcmp on the pointers stored at the start of each structure."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "constants:0xf000",
            "constants:0x4000",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0x15, 0xac, 0xe, and 0xf",
            "Why the function returns the difference of flag checks (rax_3 - rdi) in some paths"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x407980",
      "original_name": "sub_407980",
      "final_name": "ai_compare_structs_by_type_and_position",
      "score": 38.3,
      "bb_count": 10,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407980  endbr64 \n  0x407984  mov     rdx, rdi\n  0x407987  mov     rcx, rsi\n  0x40798a  mov     edi, dword [rsi+0xa8]\n  0x407990  mov     eax, dword [rdx+0xa8]\n  0x407996  cmp     eax, 0x3\n  0x407999  sete    sil\n  0x40799d  cmp     eax, 0x9\n  0x4079a0  sete    al\n  0x4079a3  or      esi, eax\n  0x4079a5  cmp     edi, 0x3\n  0x4079a8  je      0x4079d8\n  0x4079d8  mov     eax, 0x1\n  0x4079dd  test    sil, sil\n  0x4079e0  je      0x407a28\n  0x4079aa  cmp     edi, 0x9\n  0x4079ad  je      0x4079d8\n  0x407a28  mov     esi, dword [rdx+0xac]\n  0x407a2e  xor     edi, edi  {0x0}\n  0x407a30  and     esi, 0xf000\n  0x407a36  cmp     esi, 0x4000\n  0x407a3c  sete    dil\n  0x407a40  sub     eax, edi\n  0x407a42  jne     0x4079d3\n  0x4079e2  mov     rax, qword [rdx+0x70]\n  0x4079e6  xor     esi, esi  {0x0}\n  0x4079e8  cmp     qword [rcx+0x70], rax\n  0x4079ec  setg    al\n  0x4079ef  setl    sil\n  0x4079f3  movzx   eax, al\n  ... (188 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nchar rsi = arg2.b | rax.b\nuint32_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi == 0)\nlabel_407a3c:\nrdi.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = rax_3 - rdi\nif (rax_3 == rdi)\ngoto label_4079e2\nlabel_4079e2:\nint64_t rax_4 = arg1[0xe]\nint64_t temp1_1 = rcx[0xe]\nbool cond:0_1 = temp1_1 s< rax_4\nrax_4.b = temp1_1 s> rax_4\nint32_t rsi_1\nrsi_1.b = cond:0_1\nint64_t rax_6 = arg1[0xf]\nint64_t temp2_1 = rcx[0xf]\nbool cond:1_1 = temp2_1 s> rax_6\nrax_6.b = temp2_1 s< rax_6\nrdi.b = cond:1_1\nresult = zx.d(rax_6.b) - zx.d(rdi.b) + ((rsi_1 - zx.d(rax_4.b)) << 1)\nif (result == 0)\nreturn strcmp(*rcx, *arg1) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi == 0)\ngoto label_407a3c\nresult = rax_3 - 1\nif (rax_3 == 1)\ngoto label_4079e2\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rsi = (uint8_t)arg2 | (uint8_t)rax;\n    uint32_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rsi)\n        {\n        label_407a3c:\n            (uint8_t)rdi = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = rax_3 - rdi;\n            \n            if (rax_3 == rdi)\n                goto label_4079e2;\n        }\n        else\n        {\n        label_4079e2:\n            int64_t rax_4 = arg1[0xe];\n            int64_t temp1_1 = rcx[0xe];\n            bool cond:0_1 = temp1_1 < rax_4;\n            (uint8_t)rax_4 = temp1_1 > rax_4;\n            int32_t rsi_1;\n            (uint8_t)rsi_1 = cond:0_1;\n            int64_t rax_6 = arg1[0xf];\n            int64_t temp2_1 = rcx[0xf];\n            bool cond:1_1 = temp2_1 > rax_6;\n            (uint8_t)rax_6 = temp2_1 < rax_6;\n            (uint8_t)rdi = cond:1_1;\n            result = (uint32_t)(uint8_t)rax_6 - (uint32_t)(uint8_t)rdi\n                + ((rsi_1 - (uint32_t)(uint8_t)rax_4) << 1);\n            \n            if (!result)\n                /* tailcall */\n                return strcmp(*(uint64_t*)rcx, *(uint64_t*)arg1);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_structs_by_type_and_position",
          "confidence": 0.78,
          "rationale": "Function checks type fields (values 3 or 9), flag bits (0xf000 == 0x4000), compares coordinate fields, and finally falls back to strcmp, indicating a custom comparator for struct objects.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_compare",
            "ai_custom_comparator"
          ]
        },
        "explain": {
          "summary": "sub_407980 compares two data structures, first checking a type field at offset 0x15 for values 3 or 9, then evaluating a flag mask at offset 0xac. If the flag condition matches, it compares two coordinate fields (offsets 0xe and 0xf) for equality; when all checks succeed it falls back to a string comparison via strcmp. Otherwise it returns a boolean-like result based on the flag comparison.",
          "details": [
            "The function reads arg1[0x15] and arg2[0x15] and proceeds only if either value is 3 or 9.",
            "It checks whether the high nibble of the dword at offset 0xac masked with 0xf000 equals 0x4000 for each argument.",
            "If the flag check fails, it returns the difference of the flag results (result = rax_3 - rdi).",
            "When the flag check passes, it compares the 64bit values at offsets 0xe and 0xf of both structures, forming a composite result; a zero result triggers a tailcall to strcmp on the pointers stored at the start of each structure.",
            "The only external call made is to strcmp (imported at 0x4046c0)."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantic meaning of the type values 3 and 9",
            "Purpose of the structures being compared (e.g., file entries, UI objects)",
            "What the function returns in the nonstrcmp branch beyond the boolean flag difference"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407a50",
      "original_name": "sub_407a50",
      "final_name": "ai_compare_by_field_then_string",
      "score": 15.2,
      "bb_count": 3,
      "insn_est": 14,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407a50  endbr64 \n  0x407a54  mov     rax, qword [rdi+0x48]\n  0x407a58  cmp     qword [rsi+0x48], rax\n  0x407a5c  setl    al\n  0x407a5f  setg    dl\n  0x407a62  movzx   eax, al\n  0x407a65  movzx   edx, dl\n  0x407a68  sub     eax, edx\n  0x407a6a  jne     0x407a80\n  0x407a80  retn     {__return_addr}\n  0x407a6c  mov     rax, qword [rdi]\n  0x407a6f  mov     rdi, qword [rsi]\n  0x407a72  mov     rsi, rax\n  0x407a75  jmp     strcmp",
        "hlil": "int64_t rax = arg1[9]\nint64_t temp0 = arg2[9]\nbool cond:0 = temp0 s> rax\nrax.b = temp0 s< rax\nuint32_t rax_1 = zx.d(rax.b)\nuint32_t rdx_1 = zx.d(cond:0)\nif (rax_1 != rdx_1)\nreturn zx.q(rax_1 - rdx_1)\nreturn strcmp(*arg2, *arg1) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[9];\n    int64_t temp0 = arg2[9];\n    bool cond:0 = temp0 > rax;\n    (uint8_t)rax = temp0 < rax;\n    uint32_t rax_1 = (uint32_t)(uint8_t)rax;\n    uint32_t rdx_1 = (uint32_t)cond:0;\n    \n    if (rax_1 != rdx_1)\n        return (uint64_t)(rax_1 - rdx_1);\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg2, *(uint64_t*)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_by_field_then_string",
          "confidence": 0.86,
          "rationale": "The function compares a numeric field at offset 9 of two structures, returning ordering based on that field, and falls back to a strcmp of the first element if equal, indicating a comparator for sorting objects.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_sort_key_compare"
          ]
        },
        "explain": {
          "summary": "The function implements a two-stage comparator: it first compares the 10th 64-bit field of two structures, returning -1, 0, or 1 based on that numeric difference; if those fields are equal it falls back to a lexical comparison of the strings pointed to by the structures using strcmp.",
          "details": [
            "Loads arg1[9] and arg2[9] (the 10th 64bit element) and determines if one is greater, less, or equal.",
            "If the numeric fields differ, returns 1 when arg2[9] < arg1[9] and -1 when arg2[9] > arg1[9].",
            "When the numeric fields are equal, it tailcalls strcmp on the pointers stored at the start of each structure."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantic meaning of the 10th field (e.g., timestamp, ID) and the layout of the structures."
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407a90",
      "original_name": "sub_407a90",
      "final_name": "ai_compare_by_field9_then_string",
      "score": 14.9,
      "bb_count": 3,
      "insn_est": 13,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407a90  endbr64 \n  0x407a94  mov     rax, qword [rsi+0x48]\n  0x407a98  cmp     qword [rdi+0x48], rax\n  0x407a9c  setl    al\n  0x407a9f  setg    dl\n  0x407aa2  movzx   eax, al\n  0x407aa5  movzx   edx, dl\n  0x407aa8  sub     eax, edx\n  0x407aaa  jne     0x407ac0\n  0x407ac0  retn     {__return_addr}\n  0x407aac  mov     rsi, qword [rsi]\n  0x407aaf  mov     rdi, qword [rdi]\n  0x407ab2  jmp     strcmp",
        "hlil": "int64_t rax = arg2[9]\nint64_t temp0 = arg1[9]\nbool cond:0 = temp0 s> rax\nrax.b = temp0 s< rax\nuint32_t rax_1 = zx.d(rax.b)\nuint32_t rdx_1 = zx.d(cond:0)\nif (rax_1 != rdx_1)\nreturn zx.q(rax_1 - rdx_1)\nreturn strcmp(*arg1, *arg2) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[9];\n    int64_t temp0 = arg1[9];\n    bool cond:0 = temp0 > rax;\n    (uint8_t)rax = temp0 < rax;\n    uint32_t rax_1 = (uint32_t)(uint8_t)rax;\n    uint32_t rdx_1 = (uint32_t)cond:0;\n    \n    if (rax_1 != rdx_1)\n        return (uint64_t)(rax_1 - rdx_1);\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_by_field9_then_string",
          "confidence": 0.78,
          "rationale": "The function first compares the value at offset 9 of two structures, returning the difference if they differ; otherwise it falls back to strcmp on the first field. This pattern matches a comparator that orders items by a numeric field then by a string name.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [
            "config",
            "file_io"
          ],
          "alt_names": [
            "ai_struct_comparator",
            "ai_sort_key_compare"
          ]
        },
        "explain": {
          "summary": "The function acts as a comparator: it first compares the 10th 64-bit element of two structures, returning a signed difference if they differ, otherwise it falls back to a lexical string comparison of the first element.",
          "details": [
            "Loads arg1[9] and arg2[9] and determines if one is greater, less, or equal.",
            "If the comparison yields a nonzero ordering (one is greater or less), it returns 1 or -1 accordingly.",
            "If the values are equal, it delegates to strcmp on the pointers stored at arg1[0] and arg2[0]."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact type and meaning of the structures referenced by arg1 and arg2",
            "Why the 10th element (index 9) is chosen as the primary key"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "file_io"
      ]
    },
    {
      "addr": "0x407ad0",
      "original_name": "sub_407ad0",
      "final_name": "ai_compare_structs_by_type_and_name",
      "score": 35.3,
      "bb_count": 10,
      "insn_est": 46,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407ad0  endbr64 \n  0x407ad4  mov     rdx, rdi\n  0x407ad7  mov     edi, dword [rsi+0xa8]\n  0x407add  mov     eax, dword [rdx+0xa8]\n  0x407ae3  cmp     eax, 0x3\n  0x407ae6  sete    cl\n  0x407ae9  cmp     eax, 0x9\n  0x407aec  sete    al\n  0x407aef  or      ecx, eax\n  0x407af1  cmp     edi, 0x3\n  0x407af4  je      0x407b20\n  0x407b20  mov     eax, 0x1\n  0x407b25  test    cl, cl\n  0x407b27  je      0x407b50\n  0x407af6  cmp     edi, 0x9\n  0x407af9  je      0x407b20\n  0x407b50  mov     ecx, dword [rdx+0xac]\n  0x407b56  xor     edi, edi  {0x0}\n  0x407b58  and     ecx, 0xf000\n  0x407b5e  cmp     ecx, 0x4000\n  0x407b64  sete    dil\n  0x407b68  sub     eax, edi\n  0x407b6a  jne     0x407b1e\n  0x407b29  mov     rax, qword [rsi+0x48]\n  0x407b2d  cmp     qword [rdx+0x48], rax\n  0x407b31  setl    al\n  0x407b34  setg    cl\n  0x407b37  movzx   eax, al\n  0x407b3a  movzx   ecx, cl\n  0x407b3d  sub     eax, ecx\n  ... (153 bytes total, truncated)",
        "hlil": "int32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\nint32_t rcx\nrcx.b = rax == 3\nrax.b = rax == 9\nint32_t rcx_1 = rcx | rax\nuint64_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rcx_1.b == 0)\nlabel_407b64:\nint32_t rdi_3\nrdi_3.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = zx.q(rax_3 - rdi_3)\nif (rax_3 == rdi_3)\ngoto label_407b29\nlabel_407b29:\nint64_t rax_4 = arg2[9]\nint64_t temp1_1 = arg1[9]\nbool cond:0_1 = temp1_1 s> rax_4\nrax_4.b = temp1_1 s< rax_4\nrcx_1.b = cond:0_1\nuint32_t rax_5 = zx.d(rax_4.b)\nuint32_t rcx_2 = zx.d(rcx_1.b)\nresult = zx.q(rax_5 - rcx_2)\nif (rax_5 == rcx_2)\nreturn strcmp(*arg1, *arg2) __tailcall\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rcx_1.b == 0)\ngoto label_407b64\nresult = zx.q(rax_3 - 1)\nif (rax_3 == 1)\ngoto label_407b29\nreturn result",
        "pseudoc": "{\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    int32_t rcx;\n    (uint8_t)rcx = rax == 3;\n    (uint8_t)rax = rax == 9;\n    int32_t rcx_1 = rcx | rax;\n    uint64_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!(uint8_t)rcx_1)\n        {\n        label_407b64:\n            int32_t rdi_3;\n            (uint8_t)rdi_3 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = (uint64_t)(rax_3 - rdi_3);\n            \n            if (rax_3 == rdi_3)\n                goto label_407b29;\n        }\n        else\n        {\n        label_407b29:\n            int64_t rax_4 = arg2[9];\n            int64_t temp1_1 = arg1[9];\n            bool cond:0_1 = temp1_1 > rax_4;\n            (uint8_t)rax_4 = temp1_1 < rax_4;\n            (uint8_t)rcx_1 = cond:0_1;\n            uint32_t rax_5 = (uint32_t)(uint8_t)rax_4;\n            uint32_t rcx_2 = (uint32_t)(uint8_t)rcx_1;\n            result = (uint64_t)(rax_5 - rcx_2);\n            \n            if (rax_5 == rcx_2)\n                /* tailcall */\n                return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!(uint8_t)rcx_1)\n            goto label_407b64;\n        \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_structs_by_type_and_name",
          "confidence": 0.78,
          "rationale": "The function checks specific fields (type values 3 or 9, flag bits) of two structures, performs conditional numeric comparisons, and finally falls back to strcmp on the structures' string fields, indicating a custom comparator for sorting or ordering entries.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_entry_sort_compare"
          ]
        },
        "explain": {
          "summary": "sub_407ad0 implements a custom comparison routine for two structures, first checking a type field for values 3 or 9, then a flag masked with 0xf000, followed by a numeric field comparison, and finally falling back to a string comparison via strcmp if earlier checks indicate equality.",
          "details": [
            "The function reads arg1[0x15] and arg2[0x15] and treats values 3 or 9 as special types, setting a flag rcx_1 accordingly.",
            "It checks a flag at offset 0xac masked with 0xf000 against 0x4000 for each argument to influence the comparison outcome.",
            "If the type and flag checks pass, it compares the 64-bit values at offset 9 of both structures, using the result to decide further action.",
            "When the numeric fields are equal, the function delegates to strcmp to compare the strings pointed to by the first fields of the structures."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "constants:0xf000",
            "constants:0x4000",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantic meaning of the type codes (3 and 9) and the flag at offset 0xac",
            "Purpose of the returned integer difference values before the strcmp call",
            "Structure layout beyond the accessed offsets"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407b70",
      "original_name": "sub_407b70",
      "final_name": "ai_file_entry_compare",
      "score": 35.6,
      "bb_count": 10,
      "insn_est": 47,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407b70  endbr64 \n  0x407b74  mov     rdx, rdi\n  0x407b77  mov     rcx, rsi\n  0x407b7a  mov     edi, dword [rsi+0xa8]\n  0x407b80  mov     eax, dword [rdx+0xa8]\n  0x407b86  cmp     eax, 0x3\n  0x407b89  sete    sil\n  0x407b8d  cmp     eax, 0x9\n  0x407b90  sete    al\n  0x407b93  or      esi, eax\n  0x407b95  cmp     edi, 0x3\n  0x407b98  je      0x407bc8\n  0x407bc8  mov     eax, 0x1\n  0x407bcd  test    sil, sil\n  0x407bd0  je      0x407c00\n  0x407b9a  cmp     edi, 0x9\n  0x407b9d  je      0x407bc8\n  0x407c00  mov     esi, dword [rdx+0xac]\n  0x407c06  xor     edi, edi  {0x0}\n  0x407c08  and     esi, 0xf000\n  0x407c0e  cmp     esi, 0x4000\n  0x407c14  sete    dil\n  0x407c18  sub     eax, edi\n  0x407c1a  jne     0x407bc3\n  0x407bd2  mov     rax, qword [rdx+0x48]\n  0x407bd6  cmp     qword [rcx+0x48], rax\n  0x407bda  setl    al\n  0x407bdd  setg    sil\n  0x407be1  movzx   eax, al\n  0x407be4  movzx   esi, sil\n  ... (161 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 3\nrax.b = rax == 9\nint32_t rsi = arg2.d | rax\nuint64_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi.b == 0)\nlabel_407c14:\nint32_t rdi_3\nrdi_3.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = zx.q(rax_3 - rdi_3)\nif (rax_3 == rdi_3)\ngoto label_407bd2\nlabel_407bd2:\nint64_t rax_4 = arg1[9]\nint64_t temp1_1 = rcx[9]\nbool cond:0_1 = temp1_1 s> rax_4\nrax_4.b = temp1_1 s< rax_4\nrsi.b = cond:0_1\nuint32_t rax_5 = zx.d(rax_4.b)\nuint32_t rsi_1 = zx.d(rsi.b)\nresult = zx.q(rax_5 - rsi_1)\nif (rax_5 == rsi_1)\nreturn strcmp(*rcx, *arg1) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi.b == 0)\ngoto label_407c14\nresult = zx.q(rax_3 - 1)\nif (rax_3 == 1)\ngoto label_407bd2\nreturn result",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 3;\n    (uint8_t)rax = rax == 9;\n    int32_t rsi = (uint32_t)arg2 | rax;\n    uint64_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!(uint8_t)rsi)\n        {\n        label_407c14:\n            int32_t rdi_3;\n            (uint8_t)rdi_3 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = (uint64_t)(rax_3 - rdi_3);\n            \n            if (rax_3 == rdi_3)\n                goto label_407bd2;\n        }\n        else\n        {\n        label_407bd2:\n            int64_t rax_4 = arg1[9];\n            int64_t temp1_1 = rcx[9];\n            bool cond:0_1 = temp1_1 > rax_4;\n            (uint8_t)rax_4 = temp1_1 < rax_4;\n            (uint8_t)rsi = cond:0_1;\n            uint32_t rax_5 = (uint32_t)(uint8_t)rax_4;\n            uint32_t rsi_1 = (uint32_t)(uint8_t)rsi;\n            result = (uint64_t)(rax_5 - rsi_1);\n            \n            if (rax_5 == rsi_1)\n                /* tailcall */\n                return strcmp(*(uint64_t*)rcx, *(uint64_t*)arg1);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!(uint8_t)rsi)\n            goto label_407c14;\n        \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_file_entry_compare",
          "confidence": 0.78,
          "rationale": "The function compares two structures based on type fields (values 3 or 9), a flag mask at offset 0xac, and a numeric field at index 9, falling back to strcmp on string fields. This pattern matches a custom comparator for file or directory entries.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_compare_entries",
            "ai_sort_key_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two structures based on a type field, a flag mask, a numeric field, and finally a string field. It first checks if either structure has a type of 3 or 9, then verifies a specific flag (0x4000) in a masked word at offset 0xac. If those checks match, it compares a numeric value at offset 9; if those also match, it delegates to strcmp to compare the strings pointed to by the structures. If any check fails, it returns a simple integer difference derived from the flag comparison.",
          "details": [
            "Loads type values from offset 0x15 of both arguments and sets a boolean if the type equals 3 or 9.",
            "Checks a flag by masking a dword at offset 0xac with 0xf000 and comparing to 0x4000 for each structure.",
            "If flag checks succeed, compares a numeric field at offset 9 of both structures, producing a signed difference.",
            "When the numeric fields are equal, calls strcmp on the first pointer of each structure and returns its result.",
            "If any earlier condition fails, returns the difference of the flag check results or a constant based on type presence."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000",
            "constants:0x4046c0"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0x15, 0x9, and 0xac",
            "Why type values 3 and 9 are special in this context",
            "What the overall higher-level purpose of this comparison is within the program"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x407c20",
      "original_name": "sub_407c20",
      "final_name": "ai_string_compare",
      "score": 9.2,
      "bb_count": 1,
      "insn_est": 4,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407c20  endbr64 \n  0x407c24  mov     rsi, qword [rsi]\n  0x407c27  mov     rdi, qword [rdi]\n  0x407c2a  jmp     strcmp",
        "hlil": "return strcmp(*arg1, *arg2) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_string_compare",
          "confidence": 0.96,
          "rationale": "The function directly forwards its arguments to the imported strcmp, acting as a thin wrapper for string comparison.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_strcmp_wrapper",
            "ai_compare_strings"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper that dereferences two pointer arguments to obtain string pointers and then calls strcmp to compare the strings, returning the comparison result.",
          "details": [
            "It loads a 64-bit value from each argument (treating them as pointers to string pointers) and passes those values to the imported strcmp function.",
            "The function performs a tail call to strcmp, effectively acting as a wrapper or adapter for string comparison."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "The original context or callers of this wrapper function are not identified."
          ],
          "confidence": 0.97
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x407c30",
      "original_name": "sub_407c30",
      "final_name": "ai_reverse_strcmp",
      "score": 9.5,
      "bb_count": 1,
      "insn_est": 5,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407c30  endbr64 \n  0x407c34  mov     rax, rsi\n  0x407c37  mov     rsi, qword [rdi]\n  0x407c3a  mov     rdi, qword [rax]\n  0x407c3d  jmp     strcmp",
        "hlil": "return strcmp(*arg2, *arg1) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return strcmp(*(uint64_t*)arg2, *(uint64_t*)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_reverse_strcmp",
          "confidence": 0.92,
          "rationale": "Function simply forwards to strcmp with arguments swapped, acting as a reverse string comparison wrapper.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_strcmp_swapped",
            "ai_descending_strcmp"
          ]
        },
        "explain": {
          "summary": "sub_407c30 is a thin wrapper that dereferences its two arguments as pointers to strings and forwards them to strcmp, returning the lexical comparison result.",
          "details": [
            "The function takes two arguments (arg1, arg2) which are pointers to pointers; it loads the 64-bit values at those addresses and passes them to strcmp.",
            "It performs a tail call to the imported strcmp function, effectively acting as a comparator (e.g., for qsort) that compares the referenced strings."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "The reason for swapping arg order (if any) and the broader context in which this comparator is used."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x407c50",
      "original_name": "sub_407c50",
      "final_name": "ai_compare_struct_by_type_and_flag",
      "score": 31.4,
      "bb_count": 9,
      "insn_est": 38,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407c50  endbr64 \n  0x407c54  mov     rdx, rdi\n  0x407c57  mov     edi, dword [rsi+0xa8]\n  0x407c5d  mov     eax, dword [rdx+0xa8]\n  0x407c63  cmp     eax, 0x9\n  0x407c66  sete    cl\n  0x407c69  cmp     eax, 0x3\n  0x407c6c  sete    al\n  0x407c6f  or      ecx, eax\n  0x407c71  cmp     edi, 0x3\n  0x407c74  je      0x407ca0\n  0x407ca0  mov     eax, 0x1\n  0x407ca5  test    cl, cl\n  0x407ca7  je      0x407cb8\n  0x407c76  cmp     edi, 0x9\n  0x407c79  je      0x407ca0\n  0x407cb8  mov     ecx, dword [rdx+0xac]\n  0x407cbe  xor     edi, edi  {0x0}\n  0x407cc0  and     ecx, 0xf000\n  0x407cc6  cmp     ecx, 0x4000\n  0x407ccc  sete    dil\n  0x407cd0  sub     eax, edi\n  0x407cd2  jne     0x407c9e\n  0x407ca9  mov     rsi, qword [rsi]\n  0x407cac  mov     rdi, qword [rdx]\n  0x407caf  jmp     strcmp\n  0x407c7b  mov     eax, dword [rsi+0xac]\n  0x407c81  mov     edi, 0x1\n  0x407c86  and     eax, 0xf000\n  0x407c8b  cmp     eax, 0x4000\n  ... (129 bytes total, truncated)",
        "hlil": "int32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\nbool rcx = rax == 9\nrax.b = rax == 3\nchar rcx_1 = rcx | rax.b\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rcx_1 == 0)\nlabel_407ccc:\nint32_t rdi_3\nrdi_3.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rdi_3)\nreturn zx.q(rax_3 - rdi_3)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rcx_1 == 0)\ngoto label_407ccc\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn strcmp(*arg1, *arg2) __tailcall",
        "pseudoc": "{\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    bool rcx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rcx_1 = rcx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rcx_1)\n        {\n        label_407ccc:\n            int32_t rdi_3;\n            (uint8_t)rdi_3 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rdi_3)\n                return (uint64_t)(rax_3 - rdi_3);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rcx_1)\n            goto label_407ccc;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_flag",
          "confidence": 0.78,
          "rationale": "The function compares two objects based on a type field (values 3 or 9) and a masked flag at offset 0xac, then falls back to a string comparison using strcmp, indicating a comparator for sorting or matching entries.",
          "evidence_refs": [
            "imports:strcmp",
            "constants:0xf000",
            "constants:0x4000",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_type_flag_string_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two objects by checking a type field at offset 0x15 and a flag at offset 0xac, returning a numeric difference if they differ, otherwise falling back to a lexical string comparison of their name fields.",
          "details": [
            "It reads a byte at offset 0x15 from each argument and checks if the value is 3 or 9, using this to set a boolean flag.",
            "It examines the 32bit value at offset 0xac, masks it with 0xf000, and tests for the constant 0x4000, using the result to influence the return value.",
            "If the earlier checks indicate a mismatch, it returns the difference of the boolean flags; otherwise it tailcalls strcmp on the pointers stored at the start of each structure."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "constants:0xf000",
            "constants:0x4000",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact meaning of the structures pointed to by arg1 and arg2",
            "Purpose of the type values 3 and 9"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407ce0",
      "original_name": "sub_407ce0",
      "final_name": "ai_struct_compare_by_type_and_flag",
      "score": 31.4,
      "bb_count": 9,
      "insn_est": 38,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407ce0  endbr64 \n  0x407ce4  mov     eax, dword [rdi+0xa8]\n  0x407cea  mov     ecx, dword [rsi+0xa8]\n  0x407cf0  cmp     eax, 0x9\n  0x407cf3  sete    dl\n  0x407cf6  cmp     eax, 0x3\n  0x407cf9  sete    al\n  0x407cfc  or      edx, eax\n  0x407cfe  cmp     ecx, 0x3\n  0x407d01  je      0x407d30\n  0x407d30  mov     eax, 0x1\n  0x407d35  test    dl, dl\n  0x407d37  je      0x407d50\n  0x407d03  cmp     ecx, 0x9\n  0x407d06  je      0x407d30\n  0x407d50  mov     edx, dword [rdi+0xac]\n  0x407d56  xor     ecx, ecx  {0x0}\n  0x407d58  and     edx, 0xf000\n  0x407d5e  cmp     edx, 0x4000\n  0x407d64  sete    cl\n  0x407d67  sub     eax, ecx\n  0x407d69  jne     0x407d2b\n  0x407d39  mov     rax, qword [rdi]\n  0x407d3c  mov     rdi, qword [rsi]\n  0x407d3f  mov     rsi, rax\n  0x407d42  jmp     strcmp\n  0x407d08  mov     eax, dword [rsi+0xac]\n  0x407d0e  mov     ecx, 0x1\n  0x407d13  and     eax, 0xf000\n  0x407d18  cmp     eax, 0x4000\n  ... (128 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_407d64:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_407d64\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn strcmp(*arg2, *arg1) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_407d64:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_407d64;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return strcmp(*(uint64_t*)arg2, *(uint64_t*)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_by_type_and_flag",
          "confidence": 0.86,
          "rationale": "The function compares two structures based on a type field at offset 0x15, checks a flag mask (0xf000) against 0x4000, and falls back to strcmp on embedded strings, indicating a custom comparator for sorting or matching objects.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_type_flag_string_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two structures based on specific fields and flags, returning a numeric ordering or delegating to a string comparison. It checks a type code at offset 0x15 for values 3 or 9, examines a masked flag at offset 0xac for the 0x4000 pattern, and uses these checks to compute a result before falling back to strcmp on the structures' string pointers.",
          "details": [
            "Reads a byte at offset 0x15 from each argument and sets flags if the values equal 3 or 9.",
            "Masks a 32-bit field at offset 0xac with 0xf000 and compares it to 0x4000 to derive a boolean flag.",
            "If the type codes match certain conditions, it returns the difference of the derived flags; otherwise it calls strcmp on the pointers stored at the start of each structure.",
            "The function ultimately returns either an integer indicating ordering based on the flags or the lexical comparison result from strcmp."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantic meaning of the structures pointed to by arg1 and arg2",
            "Purpose of the specific type codes (3 and 9) and the 0x4000 flag in the broader application"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407d70",
      "original_name": "sub_407d70",
      "final_name": "ai_strnicmp",
      "score": 23.3,
      "bb_count": 9,
      "insn_est": 26,
      "callers": 2,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x407d70  sub     rdx, 0x1\n  0x407d74  xor     ecx, ecx  {0x0}\n  0x407d76  jmp     0x407d8d\n  0x407d8d  movzx   eax, byte [rdi+rcx]\n  0x407d91  lea     r8d, [rax-0x41]\n  0x407d95  mov     r9d, eax\n  0x407d98  cmp     r8d, 0x19\n  0x407d9c  ja      0x407da5\n  0x407da5  movzx   r10d, byte [rsi+rcx]\n  0x407daa  lea     r11d, [r10-0x41]\n  0x407dae  mov     r8d, r10d\n  0x407db1  cmp     r11d, 0x19\n  0x407db5  ja      0x407dbf\n  0x407d9e  add     eax, 0x20\n  0x407da1  add     r9d, 0x20\n  0x407dbf  cmp     rcx, rdx\n  0x407dc2  jne     0x407d80\n  0x407db7  add     r10d, 0x20\n  0x407dbb  add     r8d, 0x20\n  0x407d80  test    eax, eax\n  0x407d82  je      0x407dc4\n  0x407dc4  sub     eax, r10d\n  0x407dc7  retn     {__return_addr}\n  0x407d84  add     rcx, 0x1\n  0x407d88  cmp     r9b, r8b\n  0x407d8b  jne     0x407dc4",
        "hlil": "int64_t rcx = 0\nuint32_t rax_1\nuint32_t r10_1\nuint32_t r8_2\nuint32_t r9_1\nrax_1 = zx.d(*(arg1 + rcx))\nr9_1 = rax_1\nif (rax_1 - 0x41 u<= 0x19)\nrax_1 += 0x20\nr9_1 += 0x20\nr10_1 = zx.d(*(arg2 + rcx))\nr8_2 = r10_1\nif (r10_1 - 0x41 u<= 0x19)\nr10_1 += 0x20\nr8_2 += 0x20\nif (rcx == arg3 - 1)\nbreak\nif (rax_1 == 0)\nbreak\nrcx += 1\ndo while (r9_1.b == r8_2.b)\nreturn zx.q(rax_1 - r10_1)",
        "pseudoc": "{\n    int64_t rcx = 0;\n    uint32_t rax_1;\n    uint32_t r10_1;\n    uint32_t r8_2;\n    uint32_t r9_1;\n    \n    do\n    {\n        rax_1 = (uint32_t)*(uint8_t*)((char*)arg1 + rcx);\n        r9_1 = rax_1;\n        \n        if (rax_1 - 0x41 <= 0x19)\n        {\n            rax_1 += 0x20;\n            r9_1 += 0x20;\n        }\n        \n        r10_1 = (uint32_t)*(uint8_t*)((char*)arg2 + rcx);\n        r8_2 = r10_1;\n        \n        if (r10_1 - 0x41 <= 0x19)\n        {\n            r10_1 += 0x20;\n            r8_2 += 0x20;\n        }\n        \n        if (rcx == arg3 - 1)\n            break;\n        \n        if (!rax_1)\n            break;\n        \n        rcx += 1;\n    } while ((uint8_t)r9_1 == (uint8_t)r8_2);\n    return (uint64_t)(rax_1 - r10_1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_strnicmp",
          "confidence": 0.96,
          "rationale": "The function iterates over two buffers up to a given length, normalizes uppercase ASCII letters to lowercase, compares characters case-insensitively, and returns the difference of the first mismatched characters, matching the behavior of a caseinsensitive string compare (strncasecmp).",
          "evidence_refs": [],
          "tags": [],
          "alt_names": [
            "ai_case_insensitive_compare",
            "ai_strncasecmp"
          ]
        },
        "explain": {
          "summary": "The function performs a caseinsensitive comparison of two byte buffers (likely strings) up to a given length, returning the difference of the first mismatched characters (or zero if they match).",
          "details": [
            "Iterates bytebybyte using rcx as an index, reading from arg1 and arg2.",
            "Converts any uppercase ASCII letters (AZ) to lowercase by adding 0x20 before comparison.",
            "Stops when the end of the specified length (arg3), a null byte, or a mismatch is encountered.",
            "Returns the signed difference between the two characters at the point of divergence."
          ],
          "evidence_refs": [],
          "unknowns": [
            "Exact types of arg1, arg2 (e.g., char* vs. other buffers) and handling of nonASCII characters",
            "Whether arg3 is a length limit or includes the terminating null"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407dd0",
      "original_name": "sub_407dd0",
      "final_name": "ai_rot_mod_hash",
      "score": 3.6,
      "bb_count": 1,
      "insn_est": 7,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x407dd0  endbr64 \n  0x407dd4  mov     rax, rdi\n  0x407dd7  xor     edx, edx  {0x0}\n  0x407dd9  ror     rax, 0x3\n  0x407ddd  div     rsi\n  0x407de0  mov     rax, rdx\n  0x407de3  retn     {__return_addr}",
        "hlil": "return modu.dp.q(0:(ror.q(arg1, 3)), arg2)",
        "pseudoc": "{\n    return COMBINE(0, RORQ(arg1, 3)) % arg2;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_rot_mod_hash",
          "confidence": 0.73,
          "rationale": "The function rotates the input value right by 3 bits and returns the result modulo a divisor, typical of a simple hash or indexing routine.",
          "evidence_refs": [],
          "tags": [
            "crypto"
          ],
          "alt_names": [
            "ai_rot_mod",
            "ai_hash_mod"
          ]
        },
        "explain": {
          "summary": "The function rotates the first argument right by 3 bits, forms a 64-bit value with a zero high part, and returns the remainder of dividing that value by the second argument.",
          "details": [
            "Uses RORQ to rotate arg1 right by 3 bits.",
            "Combines the rotated result with a zero high word (effectively a 64-bit value).",
            "Applies a modulo operation with arg2 and returns the result."
          ],
          "evidence_refs": [
            "call:0x407dd0"
          ],
          "unknowns": [
            "Exact definition of COMBINE macro and whether it creates a 64-bit value or performs other packing."
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": [
        "crypto"
      ]
    },
    {
      "addr": "0x407df0",
      "original_name": "sub_407df0",
      "final_name": "ai_check_equality",
      "score": 2.7,
      "bb_count": 1,
      "insn_est": 4,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x407df0  endbr64 \n  0x407df4  cmp     rsi, rdi\n  0x407df7  sete    al\n  0x407dfa  retn     {__return_addr}",
        "hlil": "int64_t result\nresult.b = arg2 == arg1\nreturn result",
        "pseudoc": "{\n    int64_t result;\n    (uint8_t)result = arg2 == arg1;\n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_check_equality",
          "confidence": 0.96,
          "rationale": "Function returns result of arg2 == arg1, indicating a basic equality comparison between two arguments.",
          "evidence_refs": [],
          "tags": [],
          "alt_names": [
            "ai_is_equal",
            "ai_compare_args"
          ]
        },
        "explain": {
          "summary": "The function checks whether arg2 equals arg1 and returns a boolean result (1 for equal, 0 for not equal) as a 64bit integer.",
          "details": [
            "It evaluates the equality expression arg2 == arg1, casts the result to a uint8_t, and stores it in result.",
            "The function contains no imports, strings, or calls to other functions."
          ],
          "evidence_refs": [],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407e00",
      "original_name": "sub_407e00",
      "final_name": "ai_string_hash_mod",
      "score": 15.9,
      "bb_count": 5,
      "insn_est": 28,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x407e00  endbr64 \n  0x407e04  mov     rcx, qword [rdi]\n  0x407e07  movsx   rdx, byte [rcx]\n  0x407e0b  test    dl, dl\n  0x407e0d  je      0x407e40\n  0x407e40  mov     rax, qword [rdi+0x8]\n  0x407e44  xor     edx, edx  {0x0}\n  0x407e46  xor     rax, rdx\n  0x407e49  xor     edx, edx  {0x0}\n  0x407e4b  div     rsi\n  0x407e4e  mov     rax, rdx\n  0x407e51  retn     {__return_addr}\n  0x407e0f  xor     eax, eax  {0x0}\n  0x407e11  nop     dword [rax]\n  0x407e18  rol     rax, 0x9\n  0x407e1c  add     rcx, 0x1\n  0x407e20  add     rax, rdx\n  0x407e23  movsx   rdx, byte [rcx]\n  0x407e27  test    dl, dl\n  0x407e29  jne     0x407e18\n  0x407e2b  xor     edx, edx  {0x0}\n  0x407e2d  div     rsi\n  0x407e30  mov     rax, qword [rdi+0x8]\n  0x407e34  xor     rax, rdx\n  0x407e37  xor     edx, edx  {0x0}\n  0x407e39  div     rsi\n  0x407e3c  mov     rax, rdx\n  0x407e3f  retn     {__return_addr}",
        "hlil": "char* rcx = *arg1\nint64_t rdx = sx.q(*rcx)\nif (rdx.b == 0)\nreturn modu.dp.q(0:(arg1[1]), arg2)\nint64_t rax = 0\nrcx = &rcx[1]\nrax = rol.q(rax, 9) + rdx\nrdx = sx.q(*rcx)\ndo while (rdx.b != 0)\nreturn modu.dp.q(0:(arg1[1] ^ modu.dp.q(0:rax, arg2)), arg2)",
        "pseudoc": "{\n    char* rcx = *(uint64_t*)arg1;\n    int64_t rdx = (int64_t)*(uint8_t*)rcx;\n    \n    if (!(uint8_t)rdx)\n        return COMBINE(0, arg1[1]) % arg2;\n    \n    int64_t rax = 0;\n    \n    do\n    {\n        rcx = &rcx[1];\n        rax = ROLQ(rax, 9) + rdx;\n        rdx = (int64_t)*(uint8_t*)rcx;\n    } while ((uint8_t)rdx);\n    \n    return COMBINE(0, arg1[1] ^ (COMBINE(0, rax) % arg2)) % arg2;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_string_hash_mod",
          "confidence": 0.86,
          "rationale": "The function iterates over a nullterminated byte sequence, rotating an accumulator and adding each byte, then applies a modulus operation, which matches a custom string hashing routine.",
          "evidence_refs": [
            "strings:none",
            "imports:none",
            "call:0x407e00"
          ],
          "tags": [
            "crypto",
            "hash",
            "string_processing"
          ],
          "alt_names": [
            "ai_custom_string_hash",
            "ai_rol_based_hash"
          ]
        },
        "explain": {
          "summary": "The function computes a simple rolling hash over a nullterminated byte sequence pointed to by the first argument, then mixes the result with a secondary value from arg1 and reduces it modulo arg2.",
          "details": [
            "It dereferences arg1 to obtain a pointer to the data buffer and reads bytes until a zero terminator is encountered.",
            "During the loop it rotates the accumulator left by 9 bits (ROLQ) and adds each byte value, forming a rolling hash.",
            "If the first byte is zero, it returns a fallback value based on arg1[1] modulo arg2.",
            "Otherwise, after processing all bytes, it XORs the hash with arg1[1], applies COMBINE and a final modulo arg2 before returning."
          ],
          "evidence_refs": [],
          "unknowns": [
            "Exact definition of the COMBINE macro and the layout of arg1 (what arg1[1] represents).",
            "Purpose of the returned value in the broader program context."
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": [
        "crypto",
        "hash",
        "string_processing"
      ]
    },
    {
      "addr": "0x407e60",
      "original_name": "sub_407e60",
      "final_name": "ai_struct_compare",
      "score": 17.9,
      "bb_count": 4,
      "insn_est": 18,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x407e60  endbr64 \n  0x407e64  mov     rdx, qword [rsi+0x8]\n  0x407e68  xor     eax, eax  {0x0}\n  0x407e6a  cmp     qword [rdi+0x8], rdx\n  0x407e6e  je      0x407e78\n  0x407e78  mov     rcx, qword [rsi+0x10]\n  0x407e7c  cmp     qword [rdi+0x10], rcx\n  0x407e80  jne     0x407e70\n  0x407e70  retn     {__return_addr}\n  0x407e82  push    rbp {__saved_rbp}\n  0x407e83  mov     rsi, qword [rsi]\n  0x407e86  mov     rdi, qword [rdi]\n  0x407e89  mov     rbp, rsp {__saved_rbp}\n  0x407e8c  call    strcmp\n  0x407e91  pop     rbp {__saved_rbp}\n  0x407e92  test    eax, eax\n  0x407e94  sete    al\n  0x407e97  retn     {__return_addr}",
        "hlil": "if (arg1[1] != arg2[1] || arg1[2] != arg2[2])\nreturn 0\nint32_t result\nresult.b = strcmp(*arg1, *arg2) == 0\nreturn result",
        "pseudoc": "{\n    if (arg1[1] != arg2[1] || arg1[2] != arg2[2])\n        return 0;\n    \n    int32_t result;\n    (uint8_t)result = !strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare",
          "confidence": 0.86,
          "rationale": "Function checks equality of two structures by comparing two integer fields and then performing a string comparison via strcmp, returning a boolean result.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_entry_eq",
            "ai_compare_strings"
          ]
        },
        "explain": {
          "summary": "The function compares two data structures: it first checks that the second and third fields of both structures are equal, then performs a string comparison on the first field using strcmp, returning 1 if all checks match and 0 otherwise.",
          "details": [
            "If arg1[1] != arg2[1] or arg1[2] != arg2[2], the function immediately returns 0.",
            "Otherwise it calls strcmp on the pointers stored at arg1[0] and arg2[0] and returns the boolean result of that comparison."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact data types and meaning of the fields at offsets 1 and 2 in the structures",
            "What higher-level logic invokes this comparison"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x407ea0",
      "original_name": "sub_407ea0",
      "final_name": "ai_free_nested_pointer",
      "score": 16.1,
      "bb_count": 1,
      "insn_est": 12,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        }
      ],
      "import_refs": [
        "free",
        "free"
      ],
      "string_refs": [],
      "constants": [
        "0x4046b0"
      ],
      "snippets": {
        "asm": "  0x407ea0  endbr64 \n  0x407ea4  push    rbp {__saved_rbp}\n  0x407ea5  mov     rbp, rsp {__saved_rbp}\n  0x407ea8  push    rbx {__saved_rbx}\n  0x407ea9  mov     rbx, rdi\n  0x407eac  sub     rsp, 0x8\n  0x407eb0  mov     rdi, qword [rdi]\n  0x407eb3  call    free\n  0x407eb8  mov     rdi, rbx\n  0x407ebb  mov     rbx, qword [rbp-0x8 {__saved_rbx}]\n  0x407ebf  leave    {__saved_rbp}\n  0x407ec0  jmp     free",
        "hlil": "free(*arg1)\nreturn free(arg1) __tailcall",
        "pseudoc": "{\n    free(*(uint64_t*)arg1);\n    /* tailcall */\n    return free(arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_free_nested_pointer",
          "confidence": 0.92,
          "rationale": "The function frees a pointer stored at the given address and then frees the address itself, acting as a cleanup helper for nested allocations.",
          "evidence_refs": [
            "imports:free",
            "call:0x4046b0"
          ],
          "tags": [],
          "alt_names": [
            "ai_cleanup_structure",
            "ai_free_pointer_and_contents"
          ]
        },
        "explain": {
          "summary": "The function frees a heap allocation referenced by the pointer stored at its argument, then frees the argument itself. It serves as a cleanup wrapper that releases both a nested allocation and its container.",
          "details": [
            "Dereferences arg1 to obtain a pointer and calls free on that pointer.",
            "Tail-calls free on arg1 itself, releasing the outer allocation.",
            "Both free calls resolve to the imported free routine at address 0x4046b0."
          ],
          "evidence_refs": [
            "imports:free",
            "call:0x4046b0"
          ],
          "unknowns": [
            "Exact type and layout of the data referenced by arg1",
            "Whether arg1 may be NULL or already freed in some contexts"
          ],
          "confidence": 0.98
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407ed0",
      "original_name": "sub_407ed0",
      "final_name": "ai_obstack_new_chunk",
      "score": 36.6,
      "bb_count": 9,
      "insn_est": 52,
      "callers": 2,
      "callees": [
        {
          "addr": "0x407f90",
          "name": "ai_case_insensitive_two_char_match",
          "original_name": "sub_407f90"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xfe0",
        "0x4230a0",
        "0x407f90"
      ],
      "snippets": {
        "asm": "  0x407ed0  push    rbp {__saved_rbp}\n  0x407ed1  mov     rbp, rsp {__saved_rbp}\n  0x407ed4  push    r13 {__saved_r13}\n  0x407ed6  push    r12 {__saved_r12}\n  0x407ed8  push    rbx {__saved_rbx}\n  0x407ed9  mov     rbx, rdi\n  0x407edc  sub     rsp, 0x8\n  0x407ee0  test    rdx, rdx\n  0x407ee3  je      0x407f60\n  0x407f60  mov     r13d, 0xf\n  0x407f66  mov     r12d, 0x10\n  0x407f6c  jmp     0x407eec\n  0x407ee5  mov     r12, rdx\n  0x407ee8  lea     r13, [rdx-0x1]\n  0x407eec  mov     eax, 0xfe0\n  0x407ef1  test    rsi, rsi\n  0x407ef4  mov     qword [rbx+0x30], r13\n  0x407ef8  cmove   rsi, rax  {0xfe0}\n  0x407efc  mov     rax, qword [rbx+0x38]\n  0x407f00  mov     qword [rbx], rsi\n  0x407f03  test    byte [rbx+0x50], 0x1\n  0x407f07  je      0x407f78\n  0x407f78  mov     rdi, rsi\n  0x407f7b  call    rax\n  0x407f7d  jmp     0x407f0f\n  0x407f09  mov     rdi, qword [rbx+0x48]\n  0x407f0d  call    rax\n  0x407f0f  mov     qword [rbx+0x8], rax\n  0x407f13  test    rax, rax\n  0x407f16  je      0x407f7f\n  ... (178 bytes total, truncated)",
        "hlil": "int64_t r12\nint64_t r13\nif (arg3 == 0)\nr13 = 0xf\nr12 = 0x10\nr12 = arg3\nr13 = arg3 - 1\narg1[6] = r13\nif (arg2 == 0)\narg2 = 0xfe0\nint64_t rax = arg1[7]\n*arg1 = arg2\nint64_t* rax_1\nif ((arg1[0xa].b & 1) == 0)\nrax_1 = rax(arg2)\nrax_1 = rax(arg1[9])\narg1[1] = rax_1\nif (rax_1 == 0)\nchar rcx\nchar rdx_4\nvoid* rsi\nvoid* rdi_2\nrcx, rdx_4, rsi, rdi_2 = obstack_alloc_failed_handler()\nreturn sub_407f90(rdi_2, rsi, rdx_4, rcx) __tailcall\nuint128_t zmm0 = zx.o(rax_1 + r13 + 0x10) & zx.o(neg.q(r12))\nvoid* rdx_3 = *arg1 + rax_1\n*(arg1 + 0x10) = _mm_unpacklo_epi64(zmm0, zmm0.q)\n*rax_1 = rdx_3\narg1[4] = rdx_3\nrax_1[1] = 0\narg1[0xa].b &= 0xf9\nreturn 1",
        "pseudoc": "{\n    int64_t r12;\n    int64_t r13;\n    \n    if (!arg3)\n    {\n        r13 = 0xf;\n        r12 = 0x10;\n    }\n    else\n    {\n        r12 = arg3;\n        r13 = arg3 - 1;\n    }\n    \n    arg1[6] = r13;\n    \n    if (!arg2)\n        arg2 = 0xfe0;\n    \n    int64_t rax = arg1[7];\n    *(uint64_t*)arg1 = arg2;\n    int64_t* rax_1;\n    \n    if (!(arg1[0xa] & 1))\n        rax_1 = rax(arg2);\n    else\n        rax_1 = rax(arg1[9]);\n    \n    arg1[1] = rax_1;\n    \n    if (!rax_1)\n    {\n        char rcx;\n        char rdx_4;\n        void* rsi;\n        void* rdi_2;\n        rcx = obstack_alloc_failed_handler();\n        /* tailcall */\n        return sub_407f90(rdi_2, rsi, rdx_4, rcx);\n    }\n    \n    uint128_t zmm0 = (uint128_t)((char*)rax_1 + r13 + 0x10) & (uint128_t)-(r12);\n    void* rdx_3 = *(uint64_t*)arg1 + rax_1;\n    *(uint128_t*)((char*)arg1 + 0x10) = _mm_unpacklo_epi64(zmm0, (uint64_t)zmm0);\n    *(uint64_t*)rax_1 = rdx_3;\n    arg1[4] = rdx_3;\n    rax_1[1] = 0;\n    arg1[0xa] &= 0xf9;\n    return 1;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_obstack_new_chunk",
          "confidence": 0.92,
          "rationale": "The function initializes or allocates a new memory chunk for an obstack structure, handling default sizes, alignment, and allocation failure via a tailcall to an error handler.",
          "evidence_refs": [
            "call:0x407f90",
            "strings:",
            "imports:"
          ],
          "tags": [],
          "alt_names": [
            "ai_obstack_allocate",
            "ai_obstack_init_chunk"
          ]
        },
        "explain": {
          "summary": "sub_407ed0 implements an obstack chunk allocation routine: it determines the chunk size, selects an allocation function based on a flag, attempts to allocate memory, aligns the returned block, updates the obstack structure, and falls back to an error handler on failure.",
          "details": [
            "If arg3 (requested chunk size) is zero, defaults to 0x10 bytes with a header of 0xf; otherwise uses arg3 and arg3-1 for alignment calculations.",
            "If arg2 (initial chunk size) is zero, defaults to 0xfe0 (a typical obstack default).",
            "Selects the allocation function stored at arg1[7] or arg1[9] depending on the low bit of arg1[0xa] and calls it with the chosen size.",
            "On allocation failure, calls sub_407f90 (the obstack allocation failure handler) and returns its result.",
            "When allocation succeeds, aligns the returned pointer using a mask derived from r12, stores the aligned pointer in the obstack, updates bookkeeping fields (arg1[1], arg1[4], arg1[6], arg1[0xa]), and returns 1."
          ],
          "evidence_refs": [
            "constants:0xfe0",
            "constants:0x4230a0",
            "constants:0x407f90",
            "call:0x407f90",
            "strings:none",
            "imports:none"
          ],
          "unknowns": [
            "Exact meaning of each arg1 index (e.g., arg1[6] vs arg1[4]) without full struct definition",
            "Purpose of the constant 0x4230a0 which is not directly referenced in the shown code"
          ],
          "confidence": 0.94
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x407f90",
      "original_name": "sub_407f90",
      "final_name": "ai_case_insensitive_two_char_match",
      "score": 57.7,
      "bb_count": 22,
      "insn_est": 69,
      "callers": 2,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xffffffdf"
      ],
      "snippets": {
        "asm": "  0x407f90  mov     rax, rdi\n  0x407f93  mov     rdi, rsi\n  0x407f96  movsx   esi, dl\n  0x407f99  sub     esi, 0x41\n  0x407f9c  movzx   r8d, byte [rax+0x7]\n  0x407fa1  cmp     esi, 0x19\n  0x407fa4  ja      0x408050\n  0x408050  xor     esi, esi  {0x0}\n  0x408052  cmp     dl, r8b\n  0x408055  jne     0x408046\n  0x407faa  and     r8d, 0xffffffdf\n  0x407fae  cmp     r8b, dl\n  0x407fb1  jne     0x408070\n  0x408046  mov     eax, esi\n  0x408048  retn     {__return_addr}\n  0x408057  mov     esi, 0x1\n  0x40805c  test    dl, dl\n  0x40805e  jne     0x407fb7\n  0x408070  xor     esi, esi\n  0x408072  mov     eax, esi  {0x0}\n  0x408074  retn     {__return_addr}\n  0x407fb7  movsx   edx, cl\n  0x407fba  movzx   r8d, byte [rax+0x8]\n  0x407fbf  sub     edx, 0x41\n  0x407fc2  cmp     edx, 0x19\n  0x407fc5  ja      0x408078\n  0x408064  mov     eax, esi  {0x1}\n  0x408066  retn     {__return_addr}\n  0x408078  xor     esi, esi  {0x0}\n  0x40807a  cmp     cl, r8b\n  ... (227 bytes total, truncated)",
        "hlil": "char r8 = *(arg1 + 7)\nint32_t rsi_3\nif (sx.d(arg3) - 0x41 u> 0x19)\nrsi_3 = 0\nif (arg3 == r8)\nif (arg3 == 0)\nreturn 1\ngoto label_407fba\nif ((r8 & 0xdf) != arg3)\nreturn 0\nlabel_407fba:\nchar r8_2 = *(arg1 + 8)\nif (sx.d(arg4) - 0x41 u> 0x19)\nrsi_3 = 0\nif (arg4 == r8_2)\nrsi_3 = 1\nif (arg4 != 0)\ngoto label_407fd8\nif (arg4 != (r8_2 & 0xdf))\nreturn 0\nlabel_407fd8:\nrsi_3 = 1\nif (arg1 != arg2)\nint64_t rdx_2 = 9\nuint32_t r8_4\nuint32_t r9_1\nuint32_t rcx\nuint32_t rsi_2\nr8_4 = zx.d(*(arg1 + rdx_2))\nr9_1 = zx.d(*(arg2 + rdx_2))\nrsi_2 = r8_4\nrcx = r9_1\nif (r8_4 - 0x41 u<= 0x19)\nr8_4 += 0x20\nrsi_2 += 0x20\nif (r9_1 - 0x41 u<= 0x19)\nr9_1 += 0x20\nrcx += 0x20\nif (r9_1 - 0x41 u<= 0x19)\nr9_1 += 0x20\n// ... truncated",
        "pseudoc": "{\n    char r8 = *(uint8_t*)((char*)arg1 + 7);\n    int32_t rsi_3;\n    \n    if ((int32_t)arg3 - 0x41 > 0x19)\n    {\n        rsi_3 = 0;\n        \n        if (arg3 == r8)\n        {\n            if (!arg3)\n                return 1;\n            \n            goto label_407fba;\n        }\n    }\n    else\n    {\n        if ((r8 & 0xdf) != arg3)\n            return 0;\n        \n    label_407fba:\n        char r8_2 = *(uint8_t*)((char*)arg1 + 8);\n        \n        if ((int32_t)arg4 - 0x41 > 0x19)\n        {\n            rsi_3 = 0;\n            \n            if (arg4 == r8_2)\n            {\n                rsi_3 = 1;\n                \n                if (arg4)\n                    goto label_407fd8;\n            }\n        }\n        else\n        {\n            if (arg4 != (r8_2 & 0xdf))\n                return 0;\n            \n        label_407fd8:\n            rsi_3 = 1;\n            \n            if (arg1 != arg2)\n            {\n                int64_t rdx_2 = 9;\n                uint32_t r8_4;\n                uint32_t r9_1;\n                uint32_t rcx;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_case_insensitive_two_char_match",
          "confidence": 0.78,
          "rationale": "The function reads two bytes from a structure at offsets 7 and 8, applies a caseinsensitive mask (0xDF) and compares them against provided characters, returning a boolean. This matches a caseinsensitive twocharacter comparison routine.",
          "evidence_refs": [
            "constants:0xffffffdf",
            "call:0x40df40"
          ],
          "tags": [],
          "alt_names": [
            "ai_char_pair_ci_compare",
            "ai_two_byte_case_insensitive_check"
          ]
        },
        "explain": {
          "summary": "sub_407f90 checks two characters stored at offsets 7 and 8 of a data buffer against supplied characters, performing caseinsensitive comparison for alphabetic values and handling zero/null specially, returning a boolean indicating a match.",
          "details": [
            "It reads a byte at arg1+7 (r8) and compares it to arg3; if arg3 is a letter (0x410x5A) it masks the stored byte with 0xDF to ignore case before comparing, otherwise it checks for exact equality, returning 0 on mismatch.",
            "If the first check succeeds, it reads a byte at arg1+8 and similarly compares it to arg4 with caseinsensitive logic, setting a success flag (rsi_3) and returning 1 when both checks pass; zero values are treated as immediate matches.",
            "The function includes early returns for mismatches and a special case where arg3 is zero, directly returning 1."
          ],
          "evidence_refs": [
            "strings:none",
            "imports:none",
            "call:0x407f90"
          ],
          "unknowns": [
            "The exact role of the later truncated code block and how arg2 is used",
            "The broader context of the data structure pointed to by arg1"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x408090",
      "original_name": "sub_408090",
      "final_name": "ai_write_padding_spaces_tabs",
      "score": 59.9,
      "bb_count": 14,
      "insn_est": 63,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        }
      ],
      "import_refs": [
        "__overflow",
        "__overflow"
      ],
      "string_refs": [
        "[A\\A]A^]"
      ],
      "constants": [
        "0x422fa8",
        "0x423708",
        "0x404960"
      ],
      "snippets": {
        "asm": "  0x408090  cmp     rdi, rsi\n  0x408093  jae     0x408160\n  0x408160  retn     {__return_addr}\n  0x408099  push    rbp {__saved_rbp}\n  0x40809a  mov     rbp, rsp {__saved_rbp}\n  0x40809d  push    r14 {__saved_r14}\n  0x40809f  mov     r14, qword [rel stdout]\n  0x4080a6  push    r13 {__saved_r13}\n  0x4080a8  mov     r13, rsi\n  0x4080ab  push    r12 {__saved_r12}\n  0x4080ad  push    rbx {__saved_rbx}\n  0x4080ae  mov     rbx, rdi\n  0x4080b1  jmp     0x4080f6\n  0x4080f6  mov     rdi, qword [r14]\n  0x4080f9  mov     rcx, qword [rel data_423708]\n  0x408100  lea     r12, [rbx+0x1]\n  0x408104  mov     rsi, qword [rdi+0x28]\n  0x408108  mov     r8, qword [rdi+0x30]\n  0x40810c  test    rcx, rcx\n  0x40810f  jne     0x4080b8\n  0x4080b8  mov     rax, r13\n  0x4080bb  xor     edx, edx  {0x0}\n  0x4080bd  div     rcx\n  0x4080c0  xor     edx, edx  {0x0}\n  0x4080c2  mov     r9, rax\n  0x4080c5  mov     rax, r12\n  0x4080c8  div     rcx\n  0x4080cb  cmp     rax, r9\n  0x4080ce  jae     0x408111\n  0x408111  cmp     rsi, r8\n  ... (189 bytes total, truncated)",
        "hlil": "if (arg1 u>= arg2)\nreturn \nint64_t rbx = arg1\nwhile (true)\nFILE* f = *stdout\nint64_t rcx_1 = data_423708\nchar* _IO_write_ptr = f->_IO_write_ptr\nchar* _IO_write_end = f->_IO_write_end\nif (rcx_1 != 0 && divu.dp.q(0:(rbx + 1), rcx_1) u< divu.dp.q(0:arg2, rcx_1))\nif (_IO_write_ptr u>= _IO_write_end)\n__overflow(f, 9)\nrcx_1 = data_423708\nf->_IO_write_ptr = &_IO_write_ptr[1]\n*_IO_write_ptr = 9\nrbx = rcx_1 + rbx - modu.dp.q(0:rbx, rcx_1)\nif (rbx u>= arg2)\nbreak\ncontinue\nif (_IO_write_ptr u>= _IO_write_end)\n__overflow(f, 0x20)\nf->_IO_write_ptr = &_IO_write_ptr[1]\n*_IO_write_ptr = 0x20\nrbx += 1\nif (rbx u>= arg2)\nbreak\nreturn ",
        "pseudoc": "{\n    if (arg1 >= arg2)\n        return;\n    \n    int64_t rbx = arg1;\n    \n    while (true)\n    {\n        FILE* f = *(uint64_t*)stdout;\n        int64_t rcx_1 = data_423708;\n        char* _IO_write_ptr = f->_IO_write_ptr;\n        char* _IO_write_end = f->_IO_write_end;\n        \n        if (rcx_1 && COMBINE(0, rbx + 1) / rcx_1 < COMBINE(0, arg2) / rcx_1)\n        {\n            if (_IO_write_ptr >= _IO_write_end)\n            {\n                __overflow(f, 9);\n                rcx_1 = data_423708;\n            }\n            else\n            {\n                f->_IO_write_ptr = &_IO_write_ptr[1];\n                *(uint8_t*)_IO_write_ptr = 9;\n            }\n            \n            rbx = rcx_1 + rbx - COMBINE(0, rbx) % rcx_1;\n            \n            if (rbx >= arg2)\n                break;\n            \n            continue;\n        }\n        \n        if (_IO_write_ptr >= _IO_write_end)\n            __overflow(f, 0x20);\n        else\n        {\n            f->_IO_write_ptr = &_IO_write_ptr[1];\n            *(uint8_t*)_IO_write_ptr = 0x20;\n        }\n        \n        rbx += 1;\n        \n        if (rbx >= arg2)\n            break;\n    }\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_write_padding_spaces_tabs",
          "confidence": 0.78,
          "rationale": "The function iterates from arg1 to arg2, writing space (0x20) or tab (0x09) characters to stdout, handling buffer overflow via __overflow. It appears to generate formatted padding/indentation.",
          "evidence_refs": [
            "imports:__overflow",
            "strings:'[A\\A]A^]'",
            "constants:0x423708"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_print_indent",
            "ai_output_padding"
          ]
        },
        "explain": {
          "summary": "The function writes whitespace characters to stdout between two indices, emitting a tab (0x09) at regular intervals defined by a global value (data_423708) and spaces (0x20) otherwise, handling buffer overflow via __overflow.",
          "details": [
            "If arg1 >= arg2 the function returns immediately; otherwise it iterates from arg1 to arg2.",
            "When the current position aligns with the next multiple of the global interval (data_423708), it writes a tab character, otherwise it writes a space.",
            "Writes are performed directly into the FILE* stdout buffer, falling back to __overflow when the buffer is full.",
            "After writing a tab, the index is advanced to the next interval boundary; after writing a space, the index increments by one."
          ],
          "evidence_refs": [
            "imports:__overflow",
            "call:0x404960",
            "constants:0x423708",
            "strings:'[A\\A]A^]'"
          ],
          "unknowns": [
            "Exact purpose of the constant at 0x422fa8 which is not referenced in the shown code",
            "Why the string '[A\\A]A^]' appears in the evidence but is not used in the logic"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x408170",
      "original_name": "sub_408170",
      "final_name": "ai_write_stdout",
      "score": 23.8,
      "bb_count": 1,
      "insn_est": 6,
      "callers": 10,
      "callees": [
        {
          "addr": "0x404b90",
          "name": "ai_write_buffer_to_file",
          "original_name": "fwrite_unlocked"
        }
      ],
      "import_refs": [
        "fwrite_unlocked"
      ],
      "string_refs": [],
      "constants": [
        "0x423350",
        "0x422fa8",
        "0x404b90"
      ],
      "snippets": {
        "asm": "  0x408170  add     qword [rel data_423350], rsi\n  0x408177  mov     rax, qword [rel stdout]\n  0x40817e  mov     rdx, rsi\n  0x408181  mov     esi, 0x1\n  0x408186  mov     rcx, qword [rax]\n  0x408189  jmp     fwrite_unlocked",
        "hlil": "data_423350 += arg2\nreturn fwrite_unlocked(arg1, 1, arg2, *stdout) __tailcall",
        "pseudoc": "{\n    data_423350 += arg2;\n    /* tailcall */\n    return fwrite_unlocked(arg1, 1, arg2, *(uint64_t*)stdout);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_write_stdout",
          "confidence": 0.93,
          "rationale": "The function increments a global byte counter and forwards data to fwrite_unlocked on stdout, acting as a wrapper for writing output to the console.",
          "evidence_refs": [
            "imports:fwrite_unlocked",
            "constants:0x423350",
            "call:0x404b90"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_stdout_write",
            "ai_fwrite_wrapper"
          ]
        },
        "explain": {
          "summary": "sub_408170 updates a global byte counter and forwards its arguments to fwrite_unlocked to write data to stdout.",
          "details": [
            "Adds the length argument (arg2) to the global variable data_423350, likely tracking total bytes written.",
            "Calls fwrite_unlocked(arg1, 1, arg2, *(uint64_t*)stdout) to write arg2 bytes from the buffer arg1 directly to the standard output."
          ],
          "evidence_refs": [
            "imports:fwrite_unlocked",
            "call:0x404b90",
            "strings:none"
          ],
          "unknowns": [
            "Exact purpose of the global counter beyond byte tracking",
            "Potential side effects of the caller's context"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x408190",
      "original_name": "sub_408190",
      "final_name": "ai_print_long_array",
      "score": 65.6,
      "bb_count": 9,
      "insn_est": 72,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        }
      ],
      "import_refs": [
        "fputs_unlocked",
        "__printf_chk",
        "__overflow"
      ],
      "string_refs": [
        " %ld"
      ],
      "constants": [
        "0x41adc0",
        "0x422fa8",
        "0x404a30",
        "0x404bd0",
        "0x404960"
      ],
      "snippets": {
        "asm": "  0x408190  push    rbp {__saved_rbp}\n  0x408191  mov     rbp, rsp {__saved_rbp}\n  0x408194  push    r15 {__saved_r15}\n  0x408196  push    r14 {__saved_r14}\n  0x408198  push    r13 {__saved_r13}\n  0x40819a  push    r12 {__saved_r12}\n  0x40819c  push    rbx {__saved_rbx}\n  0x40819d  sub     rsp, 0x8\n  0x4081a1  mov     rax, qword [rsi+0x18]\n  0x4081a5  mov     r13, qword [rsi+0x10]\n  0x4081a9  mov     r12, rax\n  0x4081ac  sub     r12, r13\n  0x4081af  cmp     r12, 0x7\n  0x4081b3  jbe     0x40824d\n  0x40824d  add     rsp, 0x8\n  0x408251  pop     rbx {__saved_rbx}\n  0x408252  pop     r12 {__saved_r12}\n  0x408254  pop     r13 {__saved_r13}\n  0x408256  pop     r14 {__saved_r14}\n  0x408258  pop     r15 {__saved_r15}\n  0x40825a  pop     rbp {__saved_rbp}\n  0x40825b  retn     {__return_addr}\n  0x4081b9  cmp     rax, r13\n  0x4081bc  je      0x40825c\n  0x40825c  or      byte [rsi+0x50], 0x2\n  0x408260  jmp     0x4081c2\n  0x4081c2  mov     rdx, qword [rsi+0x30]\n  0x4081c6  mov     rcx, qword [rsi+0x8]\n  0x4081ca  lea     r14, [rel data_41adc0]\n  0x4081d1  mov     r15, qword [rel stdout]\n  ... (234 bytes total, truncated)",
        "hlil": "char* _IO_write_ptr = *(arg2 + 0x18)\nint64_t r13 = *(arg2 + 0x10)\nvoid* r12_1 = _IO_write_ptr - r13\nif (r12_1 u> 7)\nif (_IO_write_ptr == r13)\n*(arg2 + 0x50) |= 2\nint64_t rdx_1 = *(arg2 + 0x30)\nint64_t rcx_1 = *(arg2 + 8)\nvoid* rax_1 = &_IO_write_ptr[rdx_1] & not.q(rdx_1)\nvoid* rdx_3 = *(arg2 + 0x20)\nif (rdx_3 - rcx_1 u< rax_1 - rcx_1)\nrax_1 = rdx_3\nint64_t i = 0\nuint128_t zmm0 = zx.o(rax_1)\n*(arg2 + 0x10) = _mm_unpacklo_epi64(zmm0, zmm0.q)\nfputs_unlocked(arg1, *stdout)\nint64_t rdx_4 = *(r13 + (i << 3))\ni += 1\n__printf_chk(2, \" %ld\", rdx_4)\ndo while (i u< r12_1 u>> 3)\nFILE* rdi = *stdout\n_IO_write_ptr = rdi->_IO_write_ptr\nif (_IO_write_ptr u>= rdi->_IO_write_end)\nreturn __overflow(rdi, 0xa) __tailcall\nrdi->_IO_write_ptr = &_IO_write_ptr[1]\n*_IO_write_ptr = 0xa\nreturn _IO_write_ptr",
        "pseudoc": "{\n    char* _IO_write_ptr = *(uint64_t*)((char*)arg2 + 0x18);\n    int64_t r13 = *(uint64_t*)((char*)arg2 + 0x10);\n    void* r12_1 = _IO_write_ptr - r13;\n    \n    if (r12_1 > 7)\n    {\n        if (_IO_write_ptr == r13)\n            *(uint8_t*)((char*)arg2 + 0x50) |= 2;\n        \n        int64_t rdx_1 = *(uint64_t*)((char*)arg2 + 0x30);\n        int64_t rcx_1 = *(uint64_t*)((char*)arg2 + 8);\n        void* rax_1 = &_IO_write_ptr[rdx_1] & ~rdx_1;\n        void* rdx_3 = *(uint64_t*)((char*)arg2 + 0x20);\n        \n        if ((char*)rdx_3 - rcx_1 < (char*)rax_1 - rcx_1)\n            rax_1 = rdx_3;\n        \n        int64_t i = 0;\n        uint128_t zmm0 = (uint128_t)rax_1;\n        *(uint128_t*)((char*)arg2 + 0x10) = _mm_unpacklo_epi64(zmm0, (uint64_t)zmm0);\n        fputs_unlocked(arg1, *(uint64_t*)stdout);\n        \n        do\n        {\n            int64_t rdx_4 = *(uint64_t*)(r13 + (i << 3));\n            i += 1;\n            __printf_chk(2, \" %ld\", rdx_4);\n        } while (i < r12_1 >> 3);\n        \n        FILE* rdi = *(uint64_t*)stdout;\n        _IO_write_ptr = rdi->_IO_write_ptr;\n        \n        if (_IO_write_ptr >= rdi->_IO_write_end)\n            /* tailcall */\n            return __overflow(rdi, 0xa);\n        \n        rdi->_IO_write_ptr = &_IO_write_ptr[1];\n        *(uint8_t*)_IO_write_ptr = 0xa;\n    }\n    \n    return _IO_write_ptr;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_long_array",
          "confidence": 0.88,
          "rationale": "The function iterates over a buffer of 64-bit integers, printing each with the format \" %ld\" to stdout using fputs_unlocked and __printf_chk, then writes a newline, indicating it dumps an array of long values to the console.",
          "evidence_refs": [
            "strings: %ld",
            "imports:fputs_unlocked",
            "imports:__printf_chk",
            "imports:__overflow",
            "call:0x404a30",
            "call:0x404bd0",
            "call:0x404960"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_dump_long_values",
            "ai_log_int64_array"
          ]
        },
        "explain": {
          "summary": "The function prints a prefix string followed by a spaceseparated list of 64bit integers stored in a buffer to stdout, then appends a newline. It checks the buffer length, updates the FILE object's internal write pointers, and uses __overflow if the output buffer is full.",
          "details": [
            "Computes the number of 8byte entries in the buffer pointed to by arg2 and only proceeds if more than 7 bytes are present.",
            "Writes the initial string (arg1) to stdout using fputs_unlocked.",
            "Iterates over each 64bit value in the buffer, printing it with __printf_chk using the format \" %ld\".",
            "After printing all values, writes a newline character, handling buffer overflow via __overflow if needed.",
            "Updates the FILE structure's _IO_write_ptr and sets a flag when the buffer is empty."
          ],
          "evidence_refs": [
            "strings:' %ld'",
            "imports:fputs_unlocked",
            "imports:__printf_chk",
            "imports:__overflow",
            "call:0x404a30",
            "call:0x404bd0",
            "call:0x404960"
          ],
          "unknowns": [
            "Exact semantics of arg1 and arg2 beyond being a string and a FILElike buffer",
            "Purpose of the flag bit set at *(char*)arg2+0x50",
            "Reason for the initial r12_1 > 7 check"
          ],
          "confidence": 0.94
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x408280",
      "original_name": "sub_408280",
      "final_name": "ai_parse_format_placeholders",
      "score": 400.7,
      "bb_count": 89,
      "insn_est": 434,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404740",
          "name": "ai_safe_memcpy",
          "original_name": "__mempcpy_chk"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404b50",
          "name": "ai_get_locale_info",
          "original_name": "nl_langinfo"
        },
        {
          "addr": "0x404930",
          "name": "ai_strchr_wrapper",
          "original_name": "strchr"
        },
        {
          "addr": "0x404d50",
          "name": "ai_get_ctype_table",
          "original_name": "__ctype_b_loc"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048d0",
          "name": "ai_get_mb_cur_max",
          "original_name": "__ctype_get_mb_cur_max"
        },
        {
          "addr": "0x404820",
          "name": "ai_mbstowcs_wrapper",
          "original_name": "mbstowcs"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x4047a0",
          "name": "ai_mbstowcs_convert_chk",
          "original_name": "__mbstowcs_chk"
        },
        {
          "addr": "0x404d20",
          "name": "ai_is_wide_printable",
          "original_name": "iswprint"
        },
        {
          "addr": "0x404800",
          "name": "ai_wcswidth_wrapper",
          "original_name": "wcswidth"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404b30",
          "name": "ai_wcwidth_wrapper",
          "original_name": "wcwidth"
        },
        {
          "addr": "0x404c70",
          "name": "ai_wide_to_multibyte",
          "original_name": "wcstombs"
        },
        {
          "addr": "0x4248e0"
        },
        {
          "addr": "0x404c70",
          "name": "ai_wide_to_multibyte",
          "original_name": "wcstombs"
        },
        {
          "addr": "0x404800",
          "name": "ai_wcswidth_wrapper",
          "original_name": "wcswidth"
        },
        {
          "addr": "0x404720",
          "name": "ai_safe_snprintf_wrapper",
          "original_name": "__snprintf_chk"
        },
        {
          "addr": "0x404950",
          "name": "ai_snprintf_wrapper",
          "original_name": "snprintf"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__mempcpy_chk",
        "free",
        "free",
        "nl_langinfo",
        "strchr",
        "__ctype_b_loc",
        "strlen",
        "__ctype_get_mb_cur_max",
        "mbstowcs",
        "malloc",
        "__mbstowcs_chk",
        "iswprint",
        "wcswidth",
        "malloc",
        "wcwidth",
        "wcstombs",
        "wcstombs",
        "wcswidth",
        "__snprintf_chk",
        "snprintf",
        "free",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "%.*s%s%s"
      ],
      "constants": [
        "0xfffffffffffff9b0",
        "0x698",
        "0x423240",
        "0xfffffffffffff9b8",
        "0xfffffffffffff9c0",
        "0xfffffffffffffa3f",
        "0xfffffffffffff998",
        "0xfffffffffffff958",
        "0xfffffffffffff978",
        "0xfffffffffffff940",
        "0xfffffffffffff960",
        "0xfffffffffffff984",
        "0x404b50",
        "0x404930",
        "0xfffffffffffff990",
        "0x404d50",
        "0xfffffffffffff9a8",
        "0xfffffffffffff970",
        "0x800",
        "0xfffffffffffff982",
        "0x4048e0",
        "0x4048d0",
        "0xfffffffffffff9a0",
        "0x4048f0",
        "0xfffffffffffff968",
        "0x404820",
        "0xfffffffffffff948",
        "0xfffffffffffff950",
        "0x4046d0",
        "0x404740"
      ],
      "snippets": {
        "asm": "  0x408280  push    rbp {__saved_rbp}\n  0x408281  xor     esi, esi  {0x0}\n  0x408283  mov     rbp, rsp {__saved_rbp}\n  0x408286  push    r15 {__saved_r15}\n  0x408288  push    r14 {__saved_r14}\n  0x40828a  lea     r8, [rbp-0x650 {var_658}]\n  0x408291  push    r13 {__saved_r13}\n  0x408293  push    r12 {__saved_r12}\n  0x408295  push    rbx {__saved_rbx}\n  0x408296  sub     rsp, 0x698\n  0x40829d  mov     rax, qword [fs:0x28]\n  0x4082a6  mov     qword [rbp-0x38 {var_40}], rax\n  0x4082aa  xor     eax, eax  {0x0}\n  0x4082d7  xor     eax, eax  {0x0}\n  0x4082d9  mov     qword [r8+rsi], rax {var_658}  {0x0}\n  0x4082dd  cmp     rsi, 0x8\n  0x4082e1  jne     0x40878c\n  0x4082be  nop     \n  0x40878c  mov     esi, 0x8\n  0x408791  jmp     0x4082ac\n  0x4082e7  cmp     qword [rbp-0x650 {var_658}], 0x0\n  0x4082ef  mov     r10d, 0xc\n  0x4082f5  je      0x4088fc\n  0x408770  cmp     cl, 0x25\n  0x408773  je      0x4087a0\n  0x4082cd  mov     edx, ecx\n  0x4082ac  lea     rax, [rel data_423240]\n  0x4082b3  mov     rax, qword [rax+rsi]\n  0x4082b7  movzx   edx, byte [rax]\n  0x4082ba  test    dl, dl\n  ... (1942 bytes total, truncated)",
        "hlil": "int64_t rsi = 0\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nint64_t var_658\nwhile (true)\nchar* rax_2 = *(&data_423240 + rsi)\nchar rdx_1 = *rax_2\nif (rdx_1 == 0)\nlabel_4082d9:\n*(&var_658 + rsi) = 0\nif (rsi == 8)\nbreak\nwhile (true)\nchar rcx_1 = rax_2[1]\nif (rdx_1 != 0x25)\nrdx_1 = rcx_1\nif (rcx_1 == 0x25)\nrdx_1 = rax_2[2]\nrax_2 = &rax_2[1]\nif (rcx_1 == 0x62)\nbreak\nrdx_1 = rcx_1\nrax_2 = &rax_2[1]\nif (rdx_1 == 0)\ngoto label_4082d9\n*(&var_658 + rsi) = rax_2\nif (rsi == 8)\nbreak\nrsi = 8\nint64_t var_650\nif (var_658 != 0 || var_650 != 0)\nuint64_t var_670_1 = 0xc\nvoid arg_37\nvoid* var_690_1 = &arg_37\nvoid var_648\nchar* var_6a8_1 = &var_648\nlabel_408341:\nnl_item item = 0x2000e\nuint64_t var_680_1 = 0\nchar* var_660_1 = var_6a8_1\n// ... truncated",
        "pseudoc": "{\n    int64_t rsi = 0;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int64_t var_658;\n    \n    while (true)\n    {\n        char* rax_2 = *(uint64_t*)(&data_423240 + rsi);\n        char rdx_1 = *(uint8_t*)rax_2;\n        \n        if (!rdx_1)\n        {\n        label_4082d9:\n            *(uint64_t*)(&var_658 + rsi) = 0;\n            \n            if (rsi == 8)\n                break;\n        }\n        else\n        {\n            while (true)\n            {\n                char rcx_1 = rax_2[1];\n                \n                if (rdx_1 != 0x25)\n                    rdx_1 = rcx_1;\n                else if (rcx_1 == 0x25)\n                {\n                    rdx_1 = rax_2[2];\n                    rax_2 = &rax_2[1];\n                }\n                else\n                {\n                    if (rcx_1 == 0x62)\n                        break;\n                    \n                    rdx_1 = rcx_1;\n                }\n                \n                rax_2 = &rax_2[1];\n                \n                if (!rdx_1)\n                    goto label_4082d9;\n            }\n            \n            *(uint64_t*)(&var_658 + rsi) = rax_2;\n            \n            if (rsi == 8)\n                break;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_parse_format_placeholders",
          "confidence": 0.78,
          "rationale": "The function iterates over a table of strings, scans for '%' format markers, handles escaped '%%', stops at a specific specifier ('b'), and stores pointers or zero values. This behavior matches parsing and extracting format placeholders for later formatting.",
          "evidence_refs": [
            "strings:%.*s%s%s",
            "imports:__mempcpy_chk",
            "imports:free",
            "call:0x404740",
            "call:0x4046b0"
          ],
          "tags": [
            "config",
            "process",
            "file_io"
          ],
          "alt_names": [
            "ai_extract_format_specifiers",
            "ai_scan_format_strings"
          ]
        },
        "explain": {
          "summary": "The function iterates over a fixed-size array of string pointers, scanning each string for a \"%b\" format specifier. For each entry it records either the address of the \"%b\" occurrence or zero if not found, storing the result in a parallel array. This appears to prepare format strings for later processing, likely related to color or formatting output in the dircolors utility.",
          "details": [
            "Loops over up to nine entries (rsi from 0 to 8) reading pointers from data_423240.",
            "Scans each string character by character, looking for a '%' followed by 'b'; on finding it stores the pointer to that position in var_658 + rsi, otherwise stores zero.",
            "Handles escaped '%%' sequences by skipping the second '%' before checking for 'b'.",
            "The function uses standard C library imports (e.g., strchr, malloc) elsewhere, suggesting further processing of the captured pointers."
          ],
          "evidence_refs": [
            "strings:%.*s%s%s",
            "imports:strchr",
            "imports:malloc",
            "call:0x404740"
          ],
          "unknowns": [
            "Exact downstream use of the stored pointers in var_658",
            "Why the function limits to nine entries and the meaning of the constants listed"
          ],
          "confidence": 0.82
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "process",
        "file_io"
      ]
    },
    {
      "addr": "0x408a60",
      "original_name": "sub_408a60",
      "final_name": "ai_signal_handler_setup",
      "score": 131.5,
      "bb_count": 17,
      "insn_est": 100,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404ca0",
          "name": "ai_check_signal_membership",
          "original_name": "sigismember"
        },
        {
          "addr": "0x404a70",
          "name": "ai_set_signal_handler",
          "original_name": "signal"
        },
        {
          "addr": "0x404ab0",
          "name": "ai_sigemptyset_wrapper",
          "original_name": "sigemptyset"
        },
        {
          "addr": "0x4047d0",
          "name": "ai_set_signal_handler",
          "original_name": "sigaction"
        },
        {
          "addr": "0x404d30",
          "name": "ai_add_signal_to_set",
          "original_name": "sigaddset"
        },
        {
          "addr": "0x404ca0",
          "name": "ai_check_signal_membership",
          "original_name": "sigismember"
        },
        {
          "addr": "0x4047d0",
          "name": "ai_set_signal_handler",
          "original_name": "sigaction"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "sigismember",
        "signal",
        "sigemptyset",
        "sigaction",
        "sigaddset",
        "sigismember",
        "sigaction",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x423740",
        "0x41ad80",
        "0x41adb0",
        "0x404ca0",
        "0x404a70",
        "0x404ab0",
        "0x404d30",
        "0x4048f0",
        "0x4047d0",
        "0x423750",
        "0x10000000",
        "0x406e50",
        "0x423760",
        "0x423770",
        "0x423780",
        "0x423790",
        "0x4237a0",
        "0x4237b0",
        "0x406e70"
      ],
      "snippets": {
        "asm": "  0x408a60  push    rbp {__saved_rbp}\n  0x408a61  mov     rbp, rsp {__saved_rbp}\n  0x408a64  push    r15 {__saved_r15}\n  0x408a66  push    r14 {__saved_r14}\n  0x408a68  push    r13 {__saved_r13}\n  0x408a6a  lea     r13, [rel data_423740]\n  0x408a71  push    r12 {__saved_r12}\n  0x408a73  push    rbx {__saved_rbx}\n  0x408a74  lea     rbx, [rel data_41ad80]\n  0x408a7b  lea     r12, [rbx+0x30]  {data_41adb0}\n  0x408a7f  sub     rsp, 0xb8\n  0x408a86  mov     rax, qword [fs:0x28]\n  0x408a8f  mov     qword [rbp-0x38 {var_40}], rax\n  0x408a93  xor     eax, eax  {0x0}\n  0x408a95  test    dil, dil\n  0x408a98  je      0x408aa9\n  0x408aa9  mov     r14d, dword [rbx]\n  0x408aac  mov     rdi, r13  {data_423740}\n  0x408aaf  mov     esi, r14d\n  0x408ab2  call    sigismember\n  0x408ab7  test    eax, eax\n  0x408ab9  je      0x408aa0\n  0x408a9a  jmp     0x408af8\n  0x408aa0  add     rbx, 0x4\n  0x408aa4  cmp     rbx, r12\n  0x408aa7  je      0x408ace\n  0x408abb  xor     esi, esi  {0x0}\n  0x408abd  mov     edi, r14d\n  0x408ac0  add     rbx, 0x4\n  0x408ac4  call    signal\n  ... (435 bytes total, truncated)",
        "hlil": "int32_t* i_1 = &data_41ad80\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nif (arg1 == 0)\nwhile (true)\nint32_t r14_1 = *i_1\nif (sigismember(&data_423740, r14_1) == 0)\ni_1 = &i_1[1]\nif (i_1 == &data_41adb0)\nbreak\ni_1 = &i_1[1]\nsignal(r14_1, nullptr)\nif (i_1 == &data_41adb0)\nbreak\nint32_t* i = &data_41ad80\nsigemptyset(&data_423740)\nint64_t (* var_d8)()\nint64_t* var_e0_1 = &var_d8\nint32_t r14_2 = *i\nsigaction(r14_2, nullptr, var_e0_1)\nif (var_d8 != 1)\nsigaddset(&data_423740, r14_2)\ni = &i[1]\ndo while (i != &data_41adb0)\nint32_t var_50_1 = 0x10000000\nint128_t var_d0_1 = data_423740\nint128_t var_c0_1 = data_423750\nint128_t var_b0_1 = data_423760\nint128_t var_a0_1 = data_423770\nint128_t var_90_1 = data_423780\nint128_t var_80_1 = data_423790\nint128_t var_70_1 = data_4237a0\nint128_t var_60_1 = data_4237b0\nint32_t r15_1 = *i_1\nif (sigismember(&data_423740, r15_1) != 0)\nint64_t (* rax_6)() = sub_406e70\nif (r15_1 != 0x14)\nrax_6 = sub_406e50\nvar_d8 = rax_6\nsigaction(r15_1, var_e0_1, nullptr)\n// ... truncated",
        "pseudoc": "{\n    int32_t* i_1 = &data_41ad80;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (!arg1)\n    {\n        while (true)\n        {\n            int32_t r14_1 = *(uint32_t*)i_1;\n            \n            if (!sigismember(&data_423740, r14_1))\n            {\n                i_1 = &i_1[1];\n                \n                if (i_1 == &data_41adb0)\n                    break;\n            }\n            else\n            {\n                i_1 = &i_1[1];\n                signal(r14_1, nullptr);\n                \n                if (i_1 == &data_41adb0)\n                    break;\n            }\n        }\n    }\n    else\n    {\n        int32_t* i = &data_41ad80;\n        sigemptyset(&data_423740);\n        int64_t (* var_d8)();\n        int64_t* var_e0_1 = &var_d8;\n        \n        do\n        {\n            int32_t r14_2 = *(uint32_t*)i;\n            sigaction(r14_2, nullptr, var_e0_1);\n            \n            if (var_d8 != 1)\n                sigaddset(&data_423740, r14_2);\n            \n            i = &i[1];\n        } while (i != &data_41adb0);\n        \n        int32_t var_50_1 = 0x10000000;\n        int128_t var_d0_1 = data_423740;\n        int128_t var_c0_1 = data_423750;\n        int128_t var_b0_1 = data_423760;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_signal_handler_setup",
          "confidence": 0.88,
          "rationale": "The function iterates over a static list of signal numbers, checks membership in a signal set, clears or restores handlers using signal, sigaction, sigemptyset, sigaddset, indicating it configures or resets signal handling for the process.",
          "evidence_refs": [
            "imports:sigismember",
            "imports:signal",
            "imports:sigemptyset",
            "imports:sigaction",
            "imports:sigaddset"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_signal_mask_init",
            "ai_signal_handler_config"
          ]
        },
        "explain": {
          "summary": "sub_408a60 configures signal handling based on its argument: when called with a false argument it clears handlers for a predefined list of signals, and when called with a true argument it builds a signal mask of those signals that are not set to a specific action, storing the mask in global data structures.",
          "details": [
            "Iterates over a static array of signal numbers (data_41ad80 to data_41adb0) and checks membership in a signal set (data_423740) using sigismember.",
            "If arg1 is zero, it resets each listed signal's handler to the default by calling signal(sig, nullptr).",
            "If arg1 is non-zero, it initializes an empty signal set, queries each signal's current action with sigaction, adds signals not having a specific action (var_d8 != 1) to the set with sigaddset, and stores the resulting mask in global variables (data_423740, data_423750, data_423760)."
          ],
          "evidence_refs": [
            "imports:sigismember",
            "imports:signal",
            "imports:sigemptyset",
            "imports:sigaction",
            "imports:sigaddset",
            "call:0x404ca0",
            "call:0x404a70",
            "call:0x404ab0",
            "call:0x4047d0"
          ],
          "unknowns": [
            "Exact contents of the signal number array and the meaning of the constants stored in data_423750 and data_423760",
            "Purpose of the var_50_1 = 0x10000000 assignment and subsequent truncated code",
            "Return value of the function and how the built mask is later used"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x408c20",
      "original_name": "sub_408c20",
      "final_name": "ai_is_utf8_locale",
      "score": 71.9,
      "bb_count": 16,
      "insn_est": 63,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404b50",
          "name": "ai_get_locale_info",
          "original_name": "nl_langinfo"
        }
      ],
      "import_refs": [
        "dcgettext",
        "nl_langinfo"
      ],
      "string_refs": [
        "ASCII",
        "UTF-8"
      ],
      "constants": [
        "0x4048c0",
        "0x404b50",
        "0x41adce",
        "0x41add4"
      ],
      "snippets": {
        "asm": "  0x408c20  push    rbp {__saved_rbp}\n  0x408c21  mov     edx, 0x5\n  0x408c26  mov     rbp, rsp {__saved_rbp}\n  0x408c29  push    r13 {__saved_r13}\n  0x408c2b  mov     r13, rsi\n  0x408c2e  mov     rsi, rdi\n  0x408c31  push    r12 {__saved_r12}\n  0x408c33  mov     r12, rdi\n  0x408c36  xor     edi, edi  {0x0}\n  0x408c38  push    rbx {__saved_rbx}\n  0x408c39  sub     rsp, 0x8\n  0x408c3d  call    dcgettext\n  0x408c42  mov     rbx, rax\n  0x408c45  cmp     r12, rax\n  0x408c48  je      0x408c58\n  0x408c58  mov     edi, 0xe\n  0x408c5d  call    nl_langinfo\n  0x408c62  test    rax, rax\n  0x408c65  je      0x408c7d\n  0x408c4a  add     rsp, 0x8\n  0x408c4e  mov     rax, rbx\n  0x408c51  pop     rbx {__saved_rbx}\n  0x408c52  pop     r12 {__saved_r12}\n  0x408c54  pop     r13 {__saved_r13}\n  0x408c56  pop     rbp {__saved_rbp}\n  0x408c57  retn     {__return_addr}\n  0x408c7d  lea     rax, [rel data_41adce]  {\"ASCII\"}\n  0x408c67  cmp     byte [rax], 0x0\n  0x408c6a  je      0x408c7d\n  0x408cab  movzx   edi, byte [rax]\n  ... (190 bytes total, truncated)",
        "hlil": "char* rax = dcgettext(nullptr, arg1, 5)\nif (arg1 == rax)\nchar* rax_2 = nl_langinfo(0xe)\nif (rax_2 == 0 || *rax_2 == 0)\nrax_2 = \"ASCII\"\nif (rax_2 == \"UTF-8\")\nreturn arg2\nchar* r8_1 = \"UTF-8\"\nuint32_t rsi_1\nuint32_t rdi\nuint32_t rcx_1\nuint32_t rdx_1\nrdi = zx.d(*rax_2)\nrsi_1 = zx.d(*r8_1)\nrcx_1 = rdi\nrdx_1 = rsi_1\nif (rdi - 0x41 u<= 0x19)\nrdi += 0x20\nrcx_1 += 0x20\nif (rsi_1 - 0x41 u<= 0x19)\nrsi_1 += 0x20\nrdx_1 += 0x20\nif (rsi_1 - 0x41 u<= 0x19)\nrsi_1 += 0x20\nrdx_1 = rsi_1\nif (rdi == 0)\nbreak\nrax_2 = &rax_2[1]\nr8_1 = &r8_1[1]\ndo while (rcx_1.b == rdx_1.b)\nif (rdi == rsi_1)\nreturn arg2\nreturn rax",
        "pseudoc": "{\n    char* rax = dcgettext(nullptr, arg1, 5);\n    \n    if (arg1 == rax)\n    {\n        char* rax_2 = nl_langinfo(0xe);\n        \n        if (!rax_2 || !*(uint8_t*)rax_2)\n            rax_2 = \"ASCII\";\n        else if (rax_2 == \"UTF-8\")\n            return arg2;\n        \n        char* r8_1 = \"UTF-8\";\n        uint32_t rsi_1;\n        uint32_t rdi;\n        uint32_t rcx_1;\n        uint32_t rdx_1;\n        \n        do\n        {\n            rdi = (uint32_t)*(uint8_t*)rax_2;\n            rsi_1 = (uint32_t)*(uint8_t*)r8_1;\n            rcx_1 = rdi;\n            rdx_1 = rsi_1;\n            \n            if (rdi - 0x41 <= 0x19)\n            {\n                rdi += 0x20;\n                rcx_1 += 0x20;\n                \n                if (rsi_1 - 0x41 <= 0x19)\n                {\n                    rsi_1 += 0x20;\n                    rdx_1 += 0x20;\n                }\n            }\n            else\n            {\n                if (rsi_1 - 0x41 <= 0x19)\n                    rsi_1 += 0x20;\n                \n                rdx_1 = rsi_1;\n                \n                if (!rdi)\n                    break;\n            }\n            \n            rax_2 = &rax_2[1];\n            r8_1 = &r8_1[1];\n        } while ((uint8_t)rcx_1 == (uint8_t)rdx_1);\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_is_utf8_locale",
          "confidence": 0.86,
          "rationale": "The function retrieves the current locale's character set via nl_langinfo(CODESET) and performs a caseinsensitive comparison against \"UTF-8\", returning a value when it matches. This indicates a check for UTF8 locale support.",
          "evidence_refs": [
            "strings:ASCII",
            "strings:UTF-8",
            "imports:dcgettext",
            "imports:nl_langinfo",
            "call:0x4048c0",
            "call:0x404b50"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_check_utf8_locale",
            "ai_locale_is_utf8"
          ]
        },
        "explain": {
          "summary": "The function checks whether a given message string has a translation and then determines if the current locale uses UTF-8 encoding. If the locale encoding is UTF-8 (caseinsensitively), it returns the second argument; otherwise it falls back to a default handling path. It uses dcgettext to fetch a translation and nl_langinfo(CODESET) to query the character set.",
          "details": [
            "Calls dcgettext(nullptr, arg1, 5) and compares the returned pointer to arg1 to detect missing translation.",
            "Retrieves the current locale's character set via nl_langinfo(0xe) and defaults to \"ASCII\" if unavailable.",
            "Performs a caseinsensitive comparison of the locale string against \"UTF-8\" using a manual loop.",
            "If the locale is UTF-8, the function returns arg2; otherwise it proceeds to alternative logic (not shown)."
          ],
          "evidence_refs": [
            "imports:dcgettext",
            "imports:nl_langinfo",
            "strings:ASCII",
            "strings:UTF-8",
            "call:0x4048c0",
            "call:0x404b50"
          ],
          "unknowns": [
            "Exact behavior after the caseinsensitive comparison when the locale is not UTF-8",
            "Precise meaning of arg1 and arg2 in the broader program context"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x408ce0",
      "original_name": "sub_408ce0",
      "final_name": "ai_sort_array_by_comparator",
      "score": 130.4,
      "bb_count": 35,
      "insn_est": 188,
      "callers": 4,
      "callees": [
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x408ce0",
          "name": "ai_sort_array_by_comparator",
          "original_name": "sub_408ce0"
        },
        {
          "addr": "0x408ce0",
          "name": "ai_sort_array_by_comparator",
          "original_name": "sub_408ce0"
        },
        {
          "addr": "0x408ce0",
          "name": "ai_sort_array_by_comparator",
          "original_name": "sub_408ce0"
        }
      ],
      "import_refs": [
        "memcpy",
        "memcpy"
      ],
      "string_refs": [],
      "constants": [
        "0x408ce0",
        "0x404ad0"
      ],
      "snippets": {
        "asm": "  0x408ce0  push    rbp {__saved_rbp}\n  0x408ce1  mov     rax, rsi\n  0x408ce4  shr     rax, 0x1\n  0x408ce7  mov     rbp, rsp {__saved_rbp}\n  0x408cea  push    r15 {__saved_r15}\n  0x408cec  push    r14 {__saved_r14}\n  0x408cee  push    r13 {__saved_r13}\n  0x408cf0  push    r12 {__saved_r12}\n  0x408cf2  push    rbx {__saved_rbx}\n  0x408cf3  mov     rbx, rdi\n  0x408cf6  sub     rsp, 0x48\n  0x408cfa  mov     qword [rbp-0x58 {var_60}], rsi\n  0x408cfe  sub     rsi, rax\n  0x408d01  mov     qword [rbp-0x50 {var_58}], rax\n  0x408d05  lea     rax, [rdi+rax*8]\n  0x408d09  mov     qword [rbp-0x60 {var_68}], rdx\n  0x408d0d  mov     qword [rbp-0x48 {var_50}], rcx\n  0x408d11  mov     qword [rbp-0x70 {var_78}], rax\n  0x408d15  cmp     rsi, 0x2\n  0x408d19  ja      0x408f10\n  0x408f10  mov     rcx, qword [rbp-0x48 {var_50}]\n  0x408f14  mov     rdx, qword [rbp-0x60 {var_68}]\n  0x408f18  mov     rdi, qword [rbp-0x70 {var_78}]\n  0x408f1c  call    sub_408ce0\n  0x408f21  jmp     0x408d25\n  0x408d1f  je      0x408dd8\n  0x408d25  cmp     qword [rbp-0x58 {var_60}], 0x3\n  0x408d2a  jne     0x408e18\n  0x408dd8  movdqu  xmm0, xmmword [rax]\n  0x408ddc  mov     r14, rax\n  ... (692 bytes total, truncated)",
        "hlil": "uint64_t rax_1 = arg2 u>> 1\nint64_t rsi = arg2 - rax_1\nint64_t* rax_2 = &arg1[rax_1]\ndouble var_48[0x2]\ndouble zmm0[0x2]\nif (rsi u> 2)\nsub_408ce0(rax_2, rsi, arg3, arg4)\nif (rsi != 2)\ngoto label_408d25\nzmm0 = *rax_2\nvar_48 = zmm0\nif (arg4(zmm0[0], zmm0 u>> 0x40) s> 0)\n*rax_2 = _mm_shuffle_pd(var_48, var_48, 1)\nif (arg2 == 3)\ngoto label_408d30\ngoto label_408e20\nlabel_408d25:\nif (arg2 != 3)\nlabel_408e20:\nuint64_t rax_12 = arg2 u>> 2\nuint64_t rsi_6 = rax_1 - rax_12\nuint64_t var_70_1 = rax_12\nint64_t* r12_2 = &arg1[rax_12]\nif (rsi_6 u> 2)\nsub_408ce0(r12_2, rsi_6, arg3, arg4)\nif (rsi_6 == 2)\nzmm0 = *r12_2\nvar_48 = zmm0\nif (arg4(zmm0[0], zmm0 u>> 0x40) s> 0)\n*r12_2 = _mm_shuffle_pd(var_48, var_48, 1)\nif (var_70_1 u> 2)\nsub_408ce0(arg1, var_70_1, arg3, arg4)\nvar_48[0] = *arg1\nint64_t rax_13 = *arg1\nvar_48[0] = rax_13\nif (var_70_1 == 2)\nint64_t r13_3 = arg1[1]\nif (arg4(rax_13, r13_3) s<= 0)\nvar_48[0] = *arg1\nuint128_t zmm0_2 = r13_3 | var_48[0] << 0x40\n// ... truncated",
        "pseudoc": "{\n    uint64_t rax_1 = arg2 >> 1;\n    int64_t rsi = arg2 - rax_1;\n    int64_t* rax_2 = &arg1[rax_1];\n    double var_48[0x2];\n    double zmm0[0x2];\n    \n    if (rsi > 2)\n        sub_408ce0(rax_2, rsi, arg3, arg4);\n    else\n    {\n        if (rsi != 2)\n            goto label_408d25;\n        \n        zmm0 = *(uint128_t*)rax_2;\n        var_48 = zmm0;\n        \n        if (arg4(zmm0[0], zmm0 >> 0x40) > 0)\n        {\n            *(uint128_t*)rax_2 = _mm_shuffle_pd(var_48, var_48, 1);\n            \n            if (arg2 == 3)\n                goto label_408d30;\n            \n            goto label_408e20;\n        }\n    }\n    \nlabel_408d25:\n    \n    if (arg2 != 3)\n    {\n    label_408e20:\n        uint64_t rax_12 = arg2 >> 2;\n        uint64_t rsi_6 = rax_1 - rax_12;\n        uint64_t var_70_1 = rax_12;\n        int64_t* r12_2 = &arg1[rax_12];\n        \n        if (rsi_6 > 2)\n            sub_408ce0(r12_2, rsi_6, arg3, arg4);\n        else if (rsi_6 == 2)\n        {\n            zmm0 = *(uint128_t*)r12_2;\n            var_48 = zmm0;\n            \n            if (arg4(zmm0[0], zmm0 >> 0x40) > 0)\n                *(uint128_t*)r12_2 = _mm_shuffle_pd(var_48, var_48, 1);\n        }\n        \n        if (var_70_1 > 2)\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_sort_array_by_comparator",
          "confidence": 0.86,
          "rationale": "The function recursively partitions an array, compares pairs using a comparator callback, and swaps elements using SIMD shuffle, indicating a generic sorting routine.",
          "evidence_refs": [
            "imports:memcpy",
            "call:0x408ce0"
          ],
          "tags": [
            "packer"
          ],
          "alt_names": [
            "ai_quicksort",
            "ai_bitonic_sort"
          ]
        },
        "explain": {
          "summary": "sub_408ce0 recursively sorts an array of 128bit elements (two doubles) using a usersupplied comparator, swapping elements when out of order and handling small subarrays directly.",
          "details": [
            "The function splits the input range using bitshifts (>>1, >>2) and recursively calls itself on subranges.",
            "For subranges of size 2 it loads a 128bit value, calls the comparator arg4 on the two double components, and swaps them via _mm_shuffle_pd if needed.",
            "Base cases for sizes <=2 are handled directly; larger ranges trigger further recursion.",
            "The function imports memcpy but does not appear to use it in the shown code; it may be used in omitted sections for moving data."
          ],
          "evidence_refs": [
            "imports:memcpy",
            "call:0x408ce0",
            "call:0x404ad0"
          ],
          "unknowns": [
            "Exact sorting algorithm (quicksort, mergesort, or insertion sort) is not fully determined from the truncated code.",
            "Purpose of arg3 (unused in the visible snippet) and any additional data movement performed by omitted code."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "packer"
      ]
    },
    {
      "addr": "0x408fc0",
      "original_name": "sub_408fc0",
      "final_name": "ai_allocate_string_struct",
      "score": 52.9,
      "bb_count": 6,
      "insn_est": 53,
      "callers": 4,
      "callees": [
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404aa0",
          "name": "ai_safe_memory_copy",
          "original_name": "__memcpy_chk"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        }
      ],
      "import_refs": [
        "strlen",
        "malloc",
        "__memcpy_chk",
        "malloc"
      ],
      "string_refs": [],
      "constants": [
        "0x4046d0",
        "0x4048e0",
        "0x404aa0"
      ],
      "snippets": {
        "asm": "  0x408fc0  push    rbp {__saved_rbp}\n  0x408fc1  mov     rbp, rsp {__saved_rbp}\n  0x408fc4  push    r14 {__saved_r14}\n  0x408fc6  push    r13 {__saved_r13}\n  0x408fc8  push    r12 {__saved_r12}\n  0x408fca  push    rbx {__saved_rbx}\n  0x408fcb  test    rdi, rdi\n  0x408fce  je      0x409040\n  0x409040  mov     edi, 0x80\n  0x409045  call    malloc\n  0x40904a  mov     rbx, rax\n  0x40904d  test    rax, rax\n  0x409050  je      0x40902d\n  0x408fd0  mov     r13, rdi\n  0x408fd3  call    strlen\n  0x408fd8  lea     r14, [rax+0x1]\n  0x408fdc  mov     eax, 0x76\n  0x408fe1  cmp     r14, rax\n  0x408fe4  cmovae  rax, r14\n  0x408fe8  mov     r12, rax\n  0x408feb  add     r12, 0x11\n  0x408fef  and     r12, 0xfffffffffffffff8\n  0x408ff3  mov     rdi, r12\n  0x408ff6  call    malloc\n  0x408ffb  mov     rbx, rax\n  0x408ffe  test    rax, rax\n  0x409001  je      0x40902d\n  0x40902d  mov     rax, rbx\n  0x409030  pop     rbx {__saved_rbx}\n  0x409031  pop     r12 {__saved_r12}\n  ... (164 bytes total, truncated)",
        "hlil": "int64_t* result\nif (arg1 == 0)\nint64_t* result_2 = malloc(0x80)\nresult = result_2\nif (result_2 != 0)\n*result_2 = 0\nresult_2[1].w = 0\nuint64_t r14_1 = strlen(arg1) + 1\nuint64_t rax_1 = 0x76\nif (r14_1 u>= 0x76)\nrax_1 = r14_1\nsize_t n = (rax_1 + 0x11) & 0xfffffffffffffff8\nint64_t* result_1 = malloc(n)\nresult = result_1\nif (result_1 != 0)\n*result_1 = 0\nresult[1].w = 1\n__memcpy_chk(result + 9, arg1, r14_1, n - 9)\n*(result + r14_1 + 9) = 0\nreturn result",
        "pseudoc": "{\n    int64_t* result;\n    \n    if (!arg1)\n    {\n        int64_t* result_2 = malloc(0x80);\n        result = result_2;\n        \n        if (result_2)\n        {\n            *(uint64_t*)result_2 = 0;\n            result_2[1] = 0;\n        }\n    }\n    else\n    {\n        uint64_t r14_1 = strlen(arg1) + 1;\n        uint64_t rax_1 = 0x76;\n        \n        if (r14_1 >= 0x76)\n            rax_1 = r14_1;\n        \n        size_t n = (rax_1 + 0x11) & 0xfffffffffffffff8;\n        int64_t* result_1 = malloc(n);\n        result = result_1;\n        \n        if (result_1)\n        {\n            *(uint64_t*)result_1 = 0;\n            result[1] = 1;\n            __memcpy_chk((char*)result + 9, arg1, r14_1, n - 9);\n            *(uint8_t*)((char*)result + r14_1 + 9) = 0;\n        }\n    }\n    \n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_allocate_string_struct",
          "confidence": 0.78,
          "rationale": "The function allocates a memory block, initializes metadata fields, and copies an input string into the allocated buffer, acting as a generic string wrapper/struct creator used for environment variable handling.",
          "evidence_refs": [
            "imports:malloc",
            "imports:strlen",
            "imports:__memcpy_chk",
            "call:0x4046d0",
            "call:0x4048e0",
            "call:0x404aa0"
          ],
          "tags": [],
          "alt_names": [
            "ai_create_string_entry",
            "ai_init_string_node"
          ]
        },
        "explain": {
          "summary": "sub_408fc0 allocates and initializes a small structure that stores a string argument. If the argument is NULL it allocates a default 0x80byte block with zeroed fields; otherwise it allocates enough space for the string plus a header, sets a flag, copies the string, and ensures null termination. The function returns a pointer to this newly allocated structure.",
          "details": [
            "When arg1 is NULL, the function calls malloc(0x80) and initializes the first two 64bit fields to zero.",
            "When arg1 is nonNULL, it computes the string length with strlen, chooses a buffer size of max(0x76, length+1) rounded up to an 8byte boundary, allocates it, sets the first field to zero, the second field to 1, copies the string into the buffer at offset 9 using __memcpy_chk, and appends a terminating NUL.",
            "The allocated block is likely a custom struct where the first 8 bytes hold a status or pointer, the next byte is a flag, and the remaining bytes hold the string data."
          ],
          "evidence_refs": [
            "imports:strlen",
            "imports:malloc",
            "imports:__memcpy_chk",
            "call:0x4048e0",
            "call:0x4046d0",
            "call:0x404aa0"
          ],
          "unknowns": [
            "Exact purpose of the first two fields and the 9byte offset",
            "Why a fixed minimum allocation size of 0x76 is used"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x409070",
      "original_name": "sub_409070",
      "final_name": "ai_safe_strtoumax",
      "score": 31.1,
      "bb_count": 6,
      "insn_est": 27,
      "callers": 2,
      "callees": [
        {
          "addr": "0x411f60",
          "name": "ai_parse_uintmax",
          "original_name": "sub_411f60"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x41af54",
        "0x411f60",
        "0x4048f0"
      ],
      "snippets": {
        "asm": "  0x409070  push    rbp {__saved_rbp}\n  0x409071  xor     esi, esi  {0x0}\n  0x409073  lea     rcx, [rel data_41af54]\n  0x40907a  mov     rbp, rsp {__saved_rbp}\n  0x40907d  sub     rsp, 0x10\n  0x409081  mov     rax, qword [fs:0x28]\n  0x40908a  mov     qword [rbp-0x8 {var_10}], rax\n  0x40908e  xor     eax, eax  {0x0}\n  0x409090  lea     rdx, [rbp-0x10 {result_1}]\n  0x409094  call    sub_411f60\n  0x409099  test    eax, eax\n  0x40909b  je      0x4090c0\n  0x4090c0  mov     rax, qword [rbp-0x10 {result_1}]\n  0x4090c4  xor     edx, edx\n  0x4090c6  test    rax, rax\n  0x4090c9  cmovs   rax, rdx  {0x0}\n  0x4090cd  jmp     0x4090a9\n  0x40909d  cmp     eax, 0x1\n  0x4090a0  setne   al\n  0x4090a3  movzx   eax, al\n  0x4090a6  neg     rax\n  0x4090a9  mov     rdx, qword [rbp-0x8 {var_10}]\n  0x4090ad  sub     rdx, qword [fs:0x28]\n  0x4090b6  jne     0x4090cf\n  0x4090cf  call    __stack_chk_fail\n  0x4090cf  { Does not return }\n  0x4090b8  leave    {__saved_rbp}\n  0x4090b9  retn     {__return_addr}",
        "hlil": "void* fsbase\nint64_t rax = *(fsbase + 0x28)\nint64_t result_1\nint32_t rax_2 = sub_411f60(arg1, nullptr, &result_1, &data_41af54)\nint64_t result\nif (rax_2 == 0)\nresult = result_1\nif (result s< 0)\nresult = 0\nrax_2.b = rax_2 != 1\nresult = neg.q(zx.q(rax_2.b))\n*(fsbase + 0x28)\nif (rax == *(fsbase + 0x28))\nreturn result\n__stack_chk_fail()\nnoreturn",
        "pseudoc": "{\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int64_t result_1;\n    int32_t rax_2 = sub_411f60(arg1, nullptr, &result_1, &data_41af54);\n    int64_t result;\n    \n    if (!rax_2)\n    {\n        result = result_1;\n        \n        if (result < 0)\n            result = 0;\n    }\n    else\n    {\n        (uint8_t)rax_2 = rax_2 != 1;\n        result = -((uint64_t)(uint8_t)rax_2);\n    }\n    \n    *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n        return result;\n    \n    __stack_chk_fail();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_safe_strtoumax",
          "confidence": 0.78,
          "rationale": "The function wraps a string-to-unsigned integer conversion (sub_411f60) with error handling and stack canary verification, typical of a safe numeric parsing utility used for configuration values.",
          "evidence_refs": [
            "imports:__stack_chk_fail",
            "call:0x411f60"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_parse_uint64_safe",
            "ai_str_to_uint64"
          ]
        },
        "explain": {
          "summary": "sub_409070 acts as a wrapper around sub_411f60, invoking it to process an input argument and returning either the parsed result or an error code while enforcing stack canary protection.",
          "details": [
            "It reads the stack canary from the FS segment, calls sub_411f60 with the provided argument and a static data reference (0x41af54), and captures the result in result_1.",
            "If sub_411f60 returns 0, the function returns result_1 (clamped to zero if negative); otherwise it returns -1 for any non1 error code, and finally verifies the canary before returning."
          ],
          "evidence_refs": [
            "imports:__stack_chk_fail",
            "call:0x411f60",
            "call:0x4048f0"
          ],
          "unknowns": [
            "Exact semantics of the argument passed to sub_411f60 and the role of the constant at 0x41af54",
            "Why a specific error code of 1 is treated differently from other nonzero codes"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x4090e0",
      "original_name": "sub_4090e0",
      "final_name": "ai_print_usage_help",
      "score": 443.5,
      "bb_count": 17,
      "insn_est": 542,
      "callers": 3,
      "callees": [
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x404cb0",
          "name": "ai_exit_wrapper",
          "original_name": "exit"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x404bc0",
          "name": "ai_set_locale_wrapper",
          "original_name": "setlocale"
        },
        {
          "addr": "0x404770",
          "name": "ai_strncmp_wrapper",
          "original_name": "strncmp"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x404bc0",
          "name": "ai_set_locale_wrapper",
          "original_name": "setlocale"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        }
      ],
      "import_refs": [
        "dcgettext",
        "__fprintf_chk",
        "exit",
        "dcgettext",
        "__printf_chk",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "fputs_unlocked",
        "dcgettext",
        "__printf_chk",
        "setlocale",
        "strncmp",
        "dcgettext",
        "__printf_chk",
        "dcgettext",
        "__printf_chk",
        "dcgettext",
        "__printf_chk",
        "setlocale",
        "dcgettext",
        "__printf_chk",
        "dcgettext",
        "fputs_unlocked"
      ],
      "string_refs": [
        "sha2 utilities",
        "test invocation",
        "Multi-call invocation",
        "sha224sum",
        "sha256sum",
        "sha384sum",
        "sha512sum",
        "\n%s online help: <%s>\n",
        "GNU coreutils",
        "Full documentation <%s%s>\n",
        "Try '%s --help' for more information.\n",
        "Usage: %s [OPTION]... [FILE]...\n",
        "List information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n",
        "\nMandatory arguments to long options are mandatory for short options too.\n",
        "  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n",
        "      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;\n                             e.g., '--block-size=M'; see SIZE format below\n\n",
        "  -B, --ignore-backups       do not list implied entries ending with ~\n",
        "  -c                         with -lt: sort by, and show, ctime (time of last\n                             change of file status information);\n                             with -l: show ctime and sort by name;\n                             otherwise: sort by ctime, newest first\n\n",
        "  -C                         list entries by columns\n      --color[=WHEN]         color the output WHEN; more info below\n  -d, --directory            list directories themselves, not their contents\n  -D, --dired                generate output designed for Emacs' dired mode\n",
        "  -f                         list all entries in directory order\n  -F, --classify[=WHEN]      append indicator (one of */=>@|) to entries WHEN\n      --file-type            likewise, except do not append '*'\n"
      ],
      "constants": [
        "0x423460",
        "0x41b638",
        "0x4048c0",
        "0x404bd0",
        "0x422fa8",
        "0x41b660",
        "0x404a30",
        "0x41b6f0",
        "0x41b740",
        "0x41b850",
        "0x41b8f0",
        "0x41b938",
        "0x41ba50",
        "0x41bb68",
        "0x41bc38",
        "0x41bcd0",
        "0x41bd10",
        "0x41bd50",
        "0x41be48",
        "0x41be98",
        "0x41bf30",
        "0x41bfa0",
        "0x41c050",
        "0x41c0d8",
        "0x41c110",
        "0x41c200",
        "0x41c298",
        "0x41c338",
        "0x41c370",
        "0x41c450"
      ],
      "snippets": {
        "asm": "  0x4090e0  push    rbp {var_8}\n  0x4090e1  mov     edx, 0x5\n  0x4090e6  mov     rbp, rsp {var_8}\n  0x4090e9  push    r15 {var_10}\n  0x4090eb  push    r14 {var_18}\n  0x4090ed  push    r13 {var_20}\n  0x4090ef  push    r12 {var_28}\n  0x4090f1  mov     r12d, edi\n  0x4090f4  push    rbx {var_30}\n  0x4090f5  sub     rsp, 0x88\n  0x4090fc  mov     rbx, qword [rel data_423460]\n  0x409103  mov     rax, qword [fs:0x28]\n  0x40910c  mov     qword [rbp-0x38 {var_40}], rax\n  0x409110  xor     eax, eax  {0x0}\n  0x409112  test    edi, edi\n  0x409114  je      0x409148\n  0x409148  xor     edi, edi  {0x0}\n  0x40914a  lea     rsi, [rel data_41b638]  {\"Usage: %s [OPTION]... [FILE]...\\n\"}\n  0x409151  call    dcgettext\n  0x409156  mov     rdx, rbx\n  0x409159  mov     edi, 0x2\n  0x40915e  mov     rsi, rax\n  0x409161  xor     eax, eax  {0x0}\n  0x409163  call    __printf_chk\n  0x409168  mov     rbx, qword [rel stdout]\n  0x40916f  xor     edi, edi  {0x0}\n  0x409171  mov     edx, 0x5\n  0x409176  lea     rsi, [rel data_41b660]  {\"List information about the FILEs (the current directory by default).\\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\\n\"}\n  0x40917d  mov     r13, qword [rbx]\n  0x409180  call    dcgettext\n  ... (2294 bytes total, truncated)",
        "hlil": "int64_t rbx = data_423460\nvoid* fsbase\nint64_t var_40 = *(fsbase + 0x28)\nif (arg1 == 0)\n__printf_chk(2, dcgettext(nullptr, \"Usage: %s [OPTION]... [FILE]...\\n\", 5), rbx)\nfputs_unlocked(dcgettext(nullptr, \"List information about the FILEs (the current directory by default).\\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"\\nMandatory arguments to long options are mandatory for short options too.\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -a, --all                  do not ignore entries starting with .\\n  -A, --almost-all           do not list implied . and ..\\n      --author               with -l, print the author of each file\\n  -b, --escape               print C-style escapes for nongraphic characters\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;\\n                             e.g., '--block-size=M'; see SIZE format below\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -B, --ignore-backups       do not list implied entries ending with ~\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -c                         with -lt: sort by, and show, ctime (time of last\\n                             change of file status information);\\n                             with -l: show ctime and sort by name;\\n                             otherwise: sort by ctime, newest first\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -C                         list entries by columns\\n      --color[=WHEN]         color the output WHEN; more info below\\n  -d, --directory            list directories themselves, not their contents\\n  -D, --dired                generate output designed for Emacs' dired mode\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -f                         list all entries in directory order\\n  -F, --classify[=WHEN]      append indicator (one of */=>@|) to entries WHEN\\n      --file-type            likewise, except do not append '*'\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\\n                             single-column -1, verbose -l, vertical -C\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --full-time            like -l --time-style=full-iso\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -g                         like -l, but do not list owner\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --group-directories-first\\n                             group directories before files;\\n                             can be augmented with a --sort option, but any\\n                             use of --sort=none (-U) disables grouping\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -G, --no-group             in a long listing, don't print group names\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.\\n      --si                   likewise, but use powers of 1000 not 1024\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -H, --dereference-command-line\\n                             follow symbolic links listed on the command line\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --dereference-command-line-symlink-to-dir\\n                             follow each command line symbolic link\\n                             that points to a directory\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --hide=PATTERN         do not list implied entries matching shell PATTERN\\n                             (overridden by -a or -A)\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --hyperlink[=WHEN]     hyperlink file names WHEN\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --indicator-style=WORD\\n                             append indicator with style WORD to entry names:\\n                             none (default), slash (-p),\\n                             file-type (--file-type), classify (-F)\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -i, --inode                print the index number of each file\\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -k, --kibibytes            default to 1024-byte blocks for file system usage;\\n                             used only with -s and per directory totals\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -l                         use a long listing format\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -L, --dereference          when showing file information for a symbolic\\n                             link, show information for the file the link\\n                             references rather than for the link itself\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -m                         fill width with a comma separated list of entries\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\\n  -N, --literal              print entry names without quoting\\n  -o                         like -l, but do not list group information\\n  -p, --indicat\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -q, --hide-control-chars   print ? instead of nongraphic characters\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --show-control-chars   show nongraphic characters as-is (the default,\\n                             unless program is 'ls' and output is a terminal)\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -Q, --quote-name           enclose entry names in double quotes\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --quoting-style=WORD   use quoting style WORD for entry names:\\n                             literal, locale, shell, shell-always,\\n                             shell-escape, shell-escape-always, c, escape\\n                             (overrides QUOTING_STYLE environment variable)\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -r, --reverse              reverse order while sorting\\n  -R, --recursive            list subdirectories recursively\\n  -s, --size                 print the allocated size of each file, in blocks\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -S                         sort by file size, largest first\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\\n                             time (-t), version (-v), extension (-X), width\\n\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --time=WORD            select which timestamp used to display or sort;\\n                               access time (-u): atime, access, use;\\n                               metadat\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"      --time-style=TIME_STYLE\\n                             time/date format with -l; see TIME_STYLE below\\n\", 5), *stdout)\nfputs_unlocked(dcgettext(nullptr, \"  -t                         sort by time, newest first; see --time\\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\\n\", 5), *stdout)\n// ... truncated",
        "pseudoc": "{\n    int64_t rbx = data_423460;\n    void* fsbase;\n    int64_t var_40 = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (!arg1)\n    {\n        __printf_chk(2, dcgettext(nullptr, \"Usage: %s [OPTION]... [FILE]...\\n\", 5), rbx);\n        fputs_unlocked(\n            dcgettext(nullptr, \n                \"List information about the FILEs (the current directory by default).\\nSort entries \"\n        \"alphabetically if none of -cftuvSUX nor --sort is specified.\\n\", \n                5), \n            *(uint64_t*)stdout);\n        fputs_unlocked(\n            dcgettext(nullptr, \n                \"\\nMandatory arguments to long options are mandatory for short options too.\\n\", 5), \n            *(uint64_t*)stdout);\n        fputs_unlocked(\n            dcgettext(nullptr, \n                \"  -a, --all                  do not ignore entries starting with .\\n  -A, --almost-all           \"\n        \"do not list implied . and ..\\n      --author               with -l, print the author of \"\n        \"each file\\n  -b, --escape               print C-style escapes for nongraphic characters\"\n        \"\n                5), \n            *(uint64_t*)stdout);\n        fputs_unlocked(\n            dcgettext(nullptr, \n                \"      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;\\n                             \"\n        \"e.g., '--block-size=M'; see SIZE format below\\n\\n\", \n                5), \n            *(uint64_t*)stdout);\n        fputs_unlocked(\n            dcgettext(nullptr, \n                \"  -B, --ignore-backups       do not list implied entries ending with ~\\n\", 5), \n            *(uint64_t*)stdout);\n        fputs_unlocked(\n            dcgettext(nullptr, \n                \"  -c                         with -lt: sort by, and show, ctime (time of last\\n                             \"\n        \"change of file status information);\\n                             with -l: show ctime and \"\n        \"sort by name;\\n                             otherwise: sort by ctime, newest first\\n\\n\", \n                5), \n            *(uint64_t*)stdout);\n        fputs_unlocked(\n            dcgettext(nullptr, \n                \"  -C                         list entries by columns\\n      --color[=WHEN]         color \"\n        \"the output WHEN; more info below\\n  -d, --directory            list directories themselves, \"\n        \"not their contents\\n  -D, --dired                generate output designed for Emacs' dired \"\n        \"mode\\n\", \n                5), \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_usage_help",
          "confidence": 0.96,
          "rationale": "The function prints localized usage and help text for a command-line utility (sha2 utilities), indicating it implements a help/usage display routine.",
          "evidence_refs": [
            "strings:Usage: %s [OPTION]... [FILE]...",
            "strings:sha2 utilities",
            "imports:dcgettext",
            "imports:fputs_unlocked",
            "call:0x4048c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_display_help",
            "ai_show_usage"
          ]
        },
        "explain": {
          "summary": "sub_4090e0 prints the command-line usage/help text for a GNU coreutils utility (likely ls), using localized strings via dcgettext and writing to stdout, then may exit based on the argument flag.",
          "details": [
            "If the first argument is false (e.g., no arguments or error), it prints a formatted usage line with __printf_chk and a series of option descriptions with fputs_unlocked, all retrieved via dcgettext for localization.",
            "The function references many option strings typical of ls (e.g., -a, -A, --color) and includes usage and help messages, indicating it serves as the help routine for the utility."
          ],
          "evidence_refs": [
            "strings:Usage: %s [OPTION]... [FILE]...",
            "strings:List information about the FILEs (the current directory by default).",
            "strings:-a, --all                  do not ignore entries starting with .",
            "imports:dcgettext",
            "imports:__printf_chk",
            "imports:fputs_unlocked",
            "call:0x4048c0",
            "call:0x404cd0",
            "call:0x404cb0"
          ],
          "unknowns": [
            "Exact behavior when arg1 is true (e.g., version output or other messages not shown in the snippet)",
            "Potential additional branches handling other command-line flags"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x4099e0",
      "original_name": "sub_4099e0",
      "final_name": "ai_print_usage_and_exit",
      "score": 6.5,
      "bb_count": 1,
      "insn_est": 5,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4090e0",
          "name": "ai_print_usage_help",
          "original_name": "sub_4090e0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x4090e0"
      ],
      "snippets": {
        "asm": "  0x4099e0  endbr64 \n  0x4099e4  push    rbp {var_8}\n  0x4099e5  mov     edi, 0x1\n  0x4099ea  mov     rbp, rsp {var_8}\n  0x4099ed  call    sub_4090e0\n  0x4099ed  { Does not return }",
        "hlil": "sub_4090e0(1)\nnoreturn",
        "pseudoc": "{\n    sub_4090e0(1);\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_usage_and_exit",
          "confidence": 0.84,
          "rationale": "The function simply calls sub_4090e0 with argument 1, which prints usage/help text for a SHA2 utility and then exits, indicating a usage display wrapper.",
          "evidence_refs": [
            "call:0x4090e0",
            "strings:\"Usage: %s [OPTION]... [FILE]...\"",
            "strings:\"sha2 utilities\"",
            "imports:__printf_chk",
            "imports:fputs_unlocked"
          ],
          "tags": [
            "crypto",
            "process"
          ],
          "alt_names": [
            "ai_show_help",
            "ai_usage_exit"
          ]
        },
        "explain": {
          "summary": "sub_4099e0 is a thin wrapper that invokes sub_4090e0 with a constant argument (1) and never returns, causing the program to display usage/help information for the SHA2 utilities and then terminate.",
          "details": [
            "The function consists of a single call to sub_4090e0(1) and has no return statement.",
            "sub_4090e0 prints usage text (e.g., \"Usage: %s [OPTION]... [FILE]...\"), help messages about SHA2 utilities, and likely calls exit, as indicated by its imports."
          ],
          "evidence_refs": [
            "call:0x4090e0",
            "strings:'sha2 utilities'",
            "imports:__printf_chk",
            "imports:exit"
          ],
          "unknowns": [
            "Exact control flow after sub_4090e0 returns (if it ever does)",
            "The broader context in which sub_4099e0 is invoked"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": true,
      "tags": [
        "crypto",
        "process"
      ]
    },
    {
      "addr": "0x409a00",
      "original_name": "sub_409a00",
      "final_name": "ai_exit_on_memory_exhausted",
      "score": 38.8,
      "bb_count": 1,
      "insn_est": 16,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x404cb0",
          "name": "ai_exit_wrapper",
          "original_name": "exit"
        }
      ],
      "import_refs": [
        "dcgettext",
        "__fprintf_chk",
        "exit"
      ],
      "string_refs": [
        "memory exhausted"
      ],
      "constants": [
        "0x41ae7b",
        "0x4048c0",
        "0x41b4cb",
        "0x422ff8",
        "0x404cd0",
        "0x423088",
        "0x404cb0"
      ],
      "snippets": {
        "asm": "  0x409a00  endbr64 \n  0x409a04  push    rbp {var_8}\n  0x409a05  mov     edx, 0x5\n  0x409a0a  lea     rsi, [rel data_41ae7b]  {\"memory exhausted\"}\n  0x409a11  xor     edi, edi  {0x0}\n  0x409a13  mov     rbp, rsp {var_8}\n  0x409a16  call    dcgettext\n  0x409a1b  lea     rdx, [rel data_41b4c3[8]]  {\"%s\\n\"}\n  0x409a22  mov     esi, 0x2\n  0x409a27  mov     rcx, rax\n  0x409a2a  mov     rax, qword [rel stderr]\n  0x409a31  mov     rdi, qword [rax]\n  0x409a34  xor     eax, eax  {0x0}\n  0x409a36  call    __fprintf_chk\n  0x409a3b  mov     edi, dword [rel data_423088]\n  0x409a41  call    exit\n  0x409a41  { Does not return }",
        "hlil": "char* rax = dcgettext(nullptr, \"memory exhausted\", 5)\n__fprintf_chk(*stderr, 2, \"%s\\n\", rax)\nexit(data_423088)\nnoreturn",
        "pseudoc": "{\n    char* rax = dcgettext(nullptr, \"memory exhausted\", 5);\n    __fprintf_chk(*(uint64_t*)stderr, 2, \"%s\\n\", rax);\n    exit(data_423088);\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_exit_on_memory_exhausted",
          "confidence": 0.96,
          "rationale": "The function prints a localized 'memory exhausted' message to stderr and then calls exit, indicating a fatal out-of-memory handler.",
          "evidence_refs": [
            "strings:memory exhausted",
            "imports:dcgettext",
            "imports:__fprintf_chk",
            "imports:exit",
            "call:0x4048c0",
            "call:0x404cd0",
            "call:0x404cb0"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_fatal_memory_error",
            "ai_memory_exhausted_handler"
          ]
        },
        "explain": {
          "summary": "The function retrieves a localized \"memory exhausted\" message, prints it to standard error, and then terminates the process with a status code from data_423088.",
          "details": [
            "Calls dcgettext with a null domain and the string \"memory exhausted\" to obtain a possibly translated message.",
            "Uses __fprintf_chk to write the message followed by a newline to stderr.",
            "Invokes exit with a status value stored at data_423088, causing the program to terminate."
          ],
          "evidence_refs": [
            "strings:\"memory exhausted\"",
            "imports:dcgettext",
            "imports:__fprintf_chk",
            "imports:exit",
            "call:0x4048c0",
            "call:0x404cd0",
            "call:0x404cb0"
          ],
          "unknowns": [
            "The exact numeric value of data_423088 (exit status) is not determined."
          ],
          "confidence": 0.98
        }
      },
      "is_boring": false,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x409a50",
      "original_name": "sub_409a50",
      "final_name": "ai_hash_table_lookup",
      "score": 65.9,
      "bb_count": 19,
      "insn_est": 93,
      "callers": 3,
      "callees": [
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        }
      ],
      "import_refs": [
        "abort"
      ],
      "string_refs": [],
      "constants": [
        "0x404750"
      ],
      "snippets": {
        "asm": "  0x409a50  push    rbp {__saved_rbp}\n  0x409a51  mov     rbp, rsp {__saved_rbp}\n  0x409a54  push    r15 {__saved_r15}\n  0x409a56  mov     r15, rdx\n  0x409a59  push    r14 {__saved_r14}\n  0x409a5b  mov     r14d, ecx\n  0x409a5e  push    r13 {__saved_r13}\n  0x409a60  mov     r13, rdi\n  0x409a63  push    r12 {__saved_r12}\n  0x409a65  mov     r12, rsi\n  0x409a68  push    rbx {__saved_rbx}\n  0x409a69  sub     rsp, 0x8\n  0x409a6d  mov     rsi, qword [rdi+0x10]\n  0x409a71  mov     rdi, r12\n  0x409a74  call    qword [r13+0x30]\n  0x409a78  cmp     rax, qword [r13+0x10]\n  0x409a7c  jae     0x404d70\n  0x404d70  call    abort\n  0x404d70  { Does not return }\n  0x409a82  mov     rbx, rax\n  0x409a85  shl     rbx, 0x4\n  0x409a89  add     rbx, qword [r13]\n  0x409a8d  mov     qword [r15], rbx\n  0x409a90  mov     rsi, qword [rbx]\n  0x409a93  test    rsi, rsi\n  0x409a96  je      0x409af0\n  0x409af0  xor     eax, eax  {0x0}\n  0x409a98  cmp     rsi, r12\n  0x409a9b  je      0x409aab\n  0x409aab  test    r14b, r14b\n  ... (278 bytes total, truncated)",
        "hlil": "int64_t r12 = arg2\nint64_t rax = (*(arg1 + 0x30))(r12, *(arg1 + 0x10))\nif (rax u>= *(arg1 + 0x10))\nabort()\nnoreturn\nint64_t* rbx_2 = (rax << 4) + *arg1\n*arg3 = rbx_2\nint64_t rsi_1 = *rbx_2\nif (rsi_1 != 0)\nif (rsi_1 == r12)\ngoto label_409aae\nif ((*(arg1 + 0x38))(r12, rsi_1) != 0)\nr12 = *rbx_2\nlabel_409aae:\nif (arg4 != 0)\nint128_t* rax_6 = rbx_2[1]\nif (rax_6 == 0)\n*rbx_2 = 0\nint64_t rdx_1 = *(arg1 + 0x48)\n*rbx_2 = *rax_6\n*rax_6 = 0\n*(rax_6 + 8) = rdx_1\n*(arg1 + 0x48) = rax_6\nreturn r12\nwhile (true)\nint64_t* rax_4 = rbx_2[1]\nif (rax_4 == 0)\nbreak\nint64_t rsi_2 = *rax_4\nif (rsi_2 != r12 && (*(arg1 + 0x38))(r12, rsi_2) == 0)\nrbx_2 = rbx_2[1]\ncontinue\nint64_t* rdx = rbx_2[1]\nint64_t rax_5 = *rdx\nif (arg4 == 0)\nreturn rax_5\nrbx_2[1] = rdx[1]\nint64_t rcx_1 = *(arg1 + 0x48)\n*rdx = 0\nrdx[1] = rcx_1\n// ... truncated",
        "pseudoc": "{\n    int64_t r12 = arg2;\n    int64_t rax = (*(uint64_t*)((char*)arg1 + 0x30))(r12, *(uint64_t*)((char*)arg1 + 0x10));\n    \n    if (rax >= *(uint64_t*)((char*)arg1 + 0x10))\n    {\n        abort();\n        /* no return */\n    }\n    \n    int64_t* rbx_2 = (rax << 4) + *(uint64_t*)arg1;\n    *(uint64_t*)arg3 = rbx_2;\n    int64_t rsi_1 = *(uint64_t*)rbx_2;\n    \n    if (rsi_1)\n    {\n        if (rsi_1 == r12)\n            goto label_409aae;\n        \n        if ((*(uint64_t*)((char*)arg1 + 0x38))(r12, rsi_1))\n        {\n            r12 = *(uint64_t*)rbx_2;\n        label_409aae:\n            \n            if (arg4)\n            {\n                int128_t* rax_6 = rbx_2[1];\n                \n                if (!rax_6)\n                    *(uint64_t*)rbx_2 = 0;\n                else\n                {\n                    int64_t rdx_1 = *(uint64_t*)((char*)arg1 + 0x48);\n                    *(uint128_t*)rbx_2 = *(uint128_t*)rax_6;\n                    *(uint64_t*)rax_6 = 0;\n                    *(uint64_t*)((char*)rax_6 + 8) = rdx_1;\n                    *(uint64_t*)((char*)arg1 + 0x48) = rax_6;\n                }\n            }\n            \n            return r12;\n        }\n        \n        while (true)\n        {\n            int64_t* rax_4 = rbx_2[1];\n            \n            if (!rax_4)\n                break;\n            \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_hash_table_lookup",
          "confidence": 0.86,
          "rationale": "The function indexes into a table using a hash, checks for key equality via a comparator, optionally removes the entry, and returns the stored value, indicating hash table lookup/removal behavior.",
          "evidence_refs": [
            "imports:abort",
            "call:0x404750"
          ],
          "tags": [],
          "alt_names": [
            "ai_map_find_entry",
            "ai_hash_lookup"
          ]
        },
        "explain": {
          "summary": "sub_409a50 implements a hash-table lookup with optional removal or reordering of entries. It computes a bucket index via a function pointer, validates bounds, traverses a linked list in the bucket, and may adjust the list based on a flag before returning the found value.",
          "details": [
            "Calls a function pointer at arg1+0x30 to compute an index from arg2 and the table size stored at arg1+0x10; aborts if the index is out of range (imports:abort, call:0x404750).",
            "Calculates the bucket address using (index << 4) + base pointer from arg1, then walks the chain comparing stored keys with arg2 using a comparator at arg1+0x38.",
            "If a matching entry is found and arg4 is true, it may remove or move the entry by updating pointers and linking the old node into a free list stored at arg1+0x48.",
            "Returns the key/value (r12) of the matching entry or continues scanning the chain until the end."
          ],
          "evidence_refs": [
            "imports:abort",
            "call:0x404750"
          ],
          "unknowns": [
            "Exact structure layout of arg1 and meaning of each field (e.g., offsets 0x10, 0x30, 0x38, 0x48).",
            "Purpose of the arg4 flag beyond triggering the list manipulation.",
            "What the comparator function at arg1+0x38 specifically checks."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x409b80",
      "original_name": "sub_409b80",
      "final_name": "ai_hash_table_insert",
      "score": 82.9,
      "bb_count": 25,
      "insn_est": 98,
      "callers": 3,
      "callees": [
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        }
      ],
      "import_refs": [
        "abort",
        "malloc"
      ],
      "string_refs": [],
      "constants": [
        "0x404750",
        "0x4046d0"
      ],
      "snippets": {
        "asm": "  0x409b80  push    rbp {__saved_rbp}\n  0x409b81  mov     rbp, rsp {__saved_rbp}\n  0x409b84  push    r15 {__saved_r15}\n  0x409b86  push    r14 {__saved_r14}\n  0x409b88  mov     r14, rdi\n  0x409b8b  push    r13 {__saved_r13}\n  0x409b8d  mov     r13, rsi\n  0x409b90  push    r12 {__saved_r12}\n  0x409b92  push    rbx {__saved_rbx}\n  0x409b93  sub     rsp, 0x18\n  0x409b97  mov     byte [rbp-0x31 {var_39}], dl\n  0x409b9a  mov     r12, qword [rsi]\n  0x409b9d  cmp     r12, qword [rsi+0x8]\n  0x409ba1  jb      0x409bbe\n  0x409bbe  mov     rbx, qword [r12]\n  0x409bc2  test    rbx, rbx\n  0x409bc5  je      0x409bb0\n  0x409ba3  jmp     0x409cb5\n  0x409bb0  add     r12, 0x10\n  0x409bb4  cmp     r12, qword [r13+0x8]\n  0x409bb8  jae     0x409cb5\n  0x409bc7  mov     r15, qword [r12+0x8]\n  0x409bcc  test    r15, r15\n  0x409bcf  je      0x409c40\n  0x409cb5  mov     eax, 0x1\n  0x409c40  mov     qword [r12+0x8], 0x0\n  0x409c49  cmp     byte [rbp-0x31 {var_39}], 0x0\n  0x409c4d  jne     0x409bb0\n  0x409bd1  mov     rsi, qword [r14+0x10]\n  0x409bd5  jmp     0x409bf4\n  ... (346 bytes total, truncated)",
        "hlil": "int64_t* r12 = *arg2\nif (r12 u< arg2[1])\nwhile (true)\nint64_t rbx_2 = *r12\nif (rbx_2 != 0)\nint64_t* r15_1 = r12[1]\nif (r15_1 != 0)\nwhile (true)\nint64_t rbx_1 = *r15_1\nint64_t rax_1 = (*(arg1 + 0x30))(rbx_1)\nif (rax_1 u>= *(arg1 + 0x10))\ngoto label_404d75\nint64_t* rax_3 = (rax_1 << 4) + *arg1\nint64_t* rdx = r15_1[1]\nif (*rax_3 != 0)\nr15_1[1] = rax_3[1]\nrax_3[1] = r15_1\nif (rdx != 0)\nr15_1 = rdx\ncontinue\n*rax_3 = rbx_1\nint64_t rax_4 = *(arg1 + 0x48)\n*(arg1 + 0x18) += 1\n*r15_1 = 0\nr15_1[1] = rax_4\n*(arg1 + 0x48) = r15_1\nif (rdx != 0)\nr15_1 = rdx\ncontinue\nrbx_2 = *r12\nbreak\nr12[1] = 0\nif (arg3 == 0)\nint64_t rax_5 = (*(arg1 + 0x30))(rbx_2, *(arg1 + 0x10))\nif (rax_5 u>= *(arg1 + 0x10))\nlabel_404d75:\nabort()\nnoreturn\nint64_t* r15_4 = (rax_5 << 4) + *arg1\nif (*r15_4 == 0)\n// ... truncated",
        "pseudoc": "{\n    int64_t* r12 = *(uint64_t*)arg2;\n    \n    if (r12 < arg2[1])\n    {\n        while (true)\n        {\n            int64_t rbx_2 = *(uint64_t*)r12;\n            \n            if (rbx_2)\n            {\n                int64_t* r15_1 = r12[1];\n                \n                if (r15_1)\n                {\n                    while (true)\n                    {\n                        int64_t rbx_1 = *(uint64_t*)r15_1;\n                        int64_t rax_1 = (*(uint64_t*)((char*)arg1 + 0x30))(rbx_1);\n                        \n                        if (rax_1 >= *(uint64_t*)((char*)arg1 + 0x10))\n                            goto label_404d75;\n                        \n                        int64_t* rax_3 = (rax_1 << 4) + *(uint64_t*)arg1;\n                        int64_t* rdx = r15_1[1];\n                        \n                        if (*(uint64_t*)rax_3)\n                        {\n                            r15_1[1] = rax_3[1];\n                            rax_3[1] = r15_1;\n                            \n                            if (rdx)\n                            {\n                                r15_1 = rdx;\n                                continue;\n                            }\n                        }\n                        else\n                        {\n                            *(uint64_t*)rax_3 = rbx_1;\n                            int64_t rax_4 = *(uint64_t*)((char*)arg1 + 0x48);\n                            *(uint64_t*)((char*)arg1 + 0x18) += 1;\n                            *(uint64_t*)r15_1 = 0;\n                            r15_1[1] = rax_4;\n                            *(uint64_t*)((char*)arg1 + 0x48) = r15_1;\n                            \n                            if (rdx)\n                            {\n                                r15_1 = rdx;\n                                continue;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_hash_table_insert",
          "confidence": 0.78,
          "rationale": "The function iterates over a list of entries, computes a hash via a function pointer, and inserts each entry into a bucket array, updating linked list pointers and counters  typical of a hash table insertion routine.",
          "evidence_refs": [
            "imports:abort",
            "imports:malloc",
            "call:0x404750",
            "call:0x4046d0"
          ],
          "tags": [],
          "alt_names": [
            "ai_hash_insert",
            "ai_rehash_table"
          ]
        },
        "explain": {
          "summary": "sub_409b80 walks a list of entries, computes a hash for each using a callback stored at arg1+0x30, and inserts the entries into a hash table with chaining, updating the table's count and head pointer. It performs pointer manipulations to link nodes into buckets and handles empty bucket insertion.",
          "details": [
            "Iterates over a range defined by arg2[0] and arg2[1], processing each nonnull entry.",
            "For each entry, calls a function pointer at arg1+0x30 to obtain a hash value, checks it against the table size at arg1+0x10, and computes the bucket address using (hash<<4)+base.",
            "If the bucket is empty, inserts the node and updates the table's entry count at arg1+0x18 and head pointer at arg1+0x48; otherwise, relinks nodes to maintain a chain.",
            "Uses abort and malloc imports (though not directly shown in the snippet) for error handling or allocation in related code paths."
          ],
          "evidence_refs": [
            "imports:abort",
            "imports:malloc",
            "call:0x404750",
            "call:0x4046d0"
          ],
          "unknowns": [
            "Exact layout and purpose of the structures referenced by arg1 and arg2",
            "The role of the outer loop's r12 pointer beyond iteration",
            "Conditions that trigger abort or malloc calls within this function"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x409cf0",
      "original_name": "sub_409cf0",
      "final_name": "ai_dynamic_buffer_init",
      "score": 14.2,
      "bb_count": 1,
      "insn_est": 4,
      "callers": 6,
      "callees": [
        {
          "addr": "0x413ce0",
          "name": "ai_dynamic_array_ensure_and_process",
          "original_name": "sub_413ce0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x423040",
        "0x413ce0"
      ],
      "snippets": {
        "asm": "  0x409cf0  mov     rsi, rdi\n  0x409cf3  lea     rdx, [rel data_423040]\n  0x409cfa  xor     edi, edi  {0x0}\n  0x409cfc  jmp     sub_413ce0",
        "hlil": "return sub_413ce0(0, arg1, &data_423040) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sub_413ce0(0, arg1, &data_423040);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dynamic_buffer_init",
          "confidence": 0.73,
          "rationale": "The function is a thin wrapper that tail-calls sub_413ce0 with a pointer to a static data buffer, indicating it initializes or ensures capacity of a dynamic buffer structure.",
          "evidence_refs": [
            "call:0x413ce0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_buffer_init",
            "ai_ensure_buffer_capacity"
          ]
        },
        "explain": {
          "summary": "sub_409cf0 is a thin wrapper that forwards its second argument to sub_413ce0, passing a zero as the first argument and a pointer to a global data structure at 0x423040 as the third argument. The function performs a tail call, returning whatever sub_413ce0 returns.",
          "details": [
            "The function consists of a single tailcall instruction: return sub_413ce0(0, arg1, &data_423040);",
            "It does not import any external symbols or reference any string literals directly.",
            "The constant address 0x423040 likely points to a global buffer or configuration used by sub_413ce0."
          ],
          "evidence_refs": [
            "call:0x413ce0",
            "constants:0x423040"
          ],
          "unknowns": [
            "Exact semantics of the data at 0x423040",
            "Purpose of the first argument being zero",
            "Higher-level role of this wrapper within the program"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": true,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x409d10",
      "original_name": "sub_409d10",
      "final_name": "ai_compare_file_extensions",
      "score": 38.8,
      "bb_count": 3,
      "insn_est": 41,
      "callers": 4,
      "callees": [
        {
          "addr": "0x404970",
          "name": "ai_strrchr_wrapper",
          "original_name": "strrchr"
        },
        {
          "addr": "0x404970",
          "name": "ai_strrchr_wrapper",
          "original_name": "strrchr"
        }
      ],
      "import_refs": [
        "strrchr",
        "strrchr"
      ],
      "string_refs": [
        "[A\\A]A^]"
      ],
      "constants": [
        "0x404970",
        "0x41af54"
      ],
      "snippets": {
        "asm": "  0x409d10  push    rbp {__saved_rbp}\n  0x409d11  mov     rbp, rsp {__saved_rbp}\n  0x409d14  push    r14 {__saved_r14}\n  0x409d16  mov     r14, rdi\n  0x409d19  push    r13 {__saved_r13}\n  0x409d1b  mov     r13, rsi\n  0x409d1e  mov     esi, 0x2e\n  0x409d23  push    r12 {__saved_r12}\n  0x409d25  mov     r12, rdx\n  0x409d28  push    rbx {__saved_rbx}\n  0x409d29  mov     rdi, qword [rdi]\n  0x409d2c  call    strrchr\n  0x409d31  mov     rdi, qword [r13]\n  0x409d35  mov     esi, 0x2e\n  0x409d3a  mov     rbx, rax\n  0x409d3d  call    strrchr\n  0x409d42  mov     rsi, rax\n  0x409d45  lea     rax, [rel data_41af54]\n  0x409d4c  test    rsi, rsi\n  0x409d4f  cmove   rsi, rax  {data_41af54}\n  0x409d53  test    rbx, rbx\n  0x409d56  cmove   rbx, rax  {data_41af54}\n  0x409d5a  mov     rdi, rbx\n  0x409d5d  call    r12\n  0x409d60  test    eax, eax\n  0x409d62  jne     0x409d80\n  0x409d80  pop     rbx {__saved_rbx}\n  0x409d81  pop     r12 {__saved_r12}\n  0x409d83  pop     r13 {__saved_r13}\n  0x409d85  pop     r14 {__saved_r14}\n  ... (113 bytes total, truncated)",
        "hlil": "char* rbx = strrchr(*arg1, 0x2e)\nchar* rsi = strrchr(*arg2, 0x2e)\nif (rsi == 0)\nrsi = &data_41af54\nif (rbx == 0)\nrbx = &data_41af54\nint32_t rax_2\nint512_t result\nrax_2, result = arg3(rbx, rsi)\nif (rax_2 != 0)\nreturn result\n*arg2\n*arg1\njump(arg3)",
        "pseudoc": "{\n    char* rbx = strrchr(*(uint64_t*)arg1, 0x2e);\n    char* rsi = strrchr(*(uint64_t*)arg2, 0x2e);\n    \n    if (!rsi)\n        rsi = &data_41af54;\n    \n    if (!rbx)\n        rbx = &data_41af54;\n    \n    int32_t rax_2;\n    int512_t result;\n    rax_2 = arg3(rbx, rsi);\n    \n    if (rax_2)\n        return result;\n    \n    *(uint64_t*)arg2;\n    *(uint64_t*)arg1;\n    /* jump -> arg3 */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_file_extensions",
          "confidence": 0.87,
          "rationale": "The function extracts the substring after the last '.' in two input strings using strrchr, defaults to a placeholder if missing, then calls strcmp to compare the extensions, indicating a file extension comparison utility.",
          "evidence_refs": [
            "imports:strrchr",
            "imports:strcmp",
            "call:0x409d90",
            "call:0x409da0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_file_ext_compare",
            "ai_check_extension_match"
          ]
        },
        "explain": {
          "summary": "sub_409d10 extracts the file extensions from two input strings, substitutes a default placeholder when a dot is missing, and then compares the extensions using a supplied comparator (typically strcmp). The function returns the comparator's result, effectively checking if the two paths share the same extension.",
          "details": [
            "Uses strrchr to locate the last '.' character in each input string (arg1 and arg2).",
            "If an extension is not found, substitutes a static string at data_41af54 (likely a default or empty extension).",
            "Calls the function pointer passed as arg3 (observed to be strcmp in callers) with the two extension pointers.",
            "Returns the result of the comparison, propagating a non-zero result directly."
          ],
          "evidence_refs": [
            "imports:strrchr",
            "strings:\"[A\\\\A]A^]\"",
            "call:0x404970",
            "call:0x409d90",
            "call:0x409da0"
          ],
          "unknowns": [
            "Exact contents of data_41af54 and its role beyond a placeholder.",
            "The purpose of the final lines referencing *(uint64_t*)arg1/arg2 and the jump to arg3, which are not fully decompiled."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x409d90",
      "original_name": "sub_409d90",
      "final_name": "ai_compare_file_extension",
      "score": 7.9,
      "bb_count": 1,
      "insn_est": 3,
      "callers": 0,
      "callees": [
        {
          "addr": "0x409d10",
          "name": "ai_compare_file_extensions",
          "original_name": "sub_409d10"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x422fb8",
        "0x409d10"
      ],
      "snippets": {
        "asm": "  0x409d90  endbr64 \n  0x409d94  mov     rdx, qword [rel strcmp]\n  0x409d9b  jmp     sub_409d10",
        "hlil": "return sub_409d10(arg1, arg2, strcmp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sub_409d10(arg1, arg2, strcmp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_file_extension",
          "confidence": 0.88,
          "rationale": "The function forwards arguments to sub_409d10 which extracts file extensions using strrchr and compares them with strcmp, indicating a file extension comparison utility.",
          "evidence_refs": [
            "imports:strrchr",
            "call:0x409d10",
            "strings:'[A\\\\A]A^]'"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_file_ext_cmp",
            "ai_path_extension_compare"
          ]
        },
        "explain": {
          "summary": "sub_409d90 forwards its arguments to sub_409d10, using strcmp as a comparator, effectively comparing the file extensions of two strings.",
          "details": [
            "The function performs a tail call to sub_409d10 with the original two arguments and the strcmp function pointer.",
            "sub_409d10 extracts the substring after the last '.' in each input string using strrchr, substitutes a default string when a dot is missing, and then calls the passed comparator (strcmp) on those substrings."
          ],
          "evidence_refs": [
            "call:0x409d10",
            "imports:strrchr",
            "strings:'[A\\\\A]A^]'"
          ],
          "unknowns": [
            "Exact behavior when the comparator returns zero (i.e., extensions match) due to missing code after the conditional.",
            "The content and purpose of data_41af54 used as a fallback string."
          ],
          "confidence": 0.87
        }
      },
      "is_boring": true,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x409da0",
      "original_name": "sub_409da0",
      "final_name": "ai_compare_file_extension",
      "score": 8.8,
      "bb_count": 1,
      "insn_est": 6,
      "callers": 0,
      "callees": [
        {
          "addr": "0x409d10",
          "name": "ai_compare_file_extensions",
          "original_name": "sub_409d10"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x422fb8",
        "0x409d10"
      ],
      "snippets": {
        "asm": "  0x409da0  endbr64 \n  0x409da4  mov     rax, rdi\n  0x409da7  mov     rdx, qword [rel strcmp]\n  0x409dae  mov     rdi, rsi\n  0x409db1  mov     rsi, rax\n  0x409db4  jmp     sub_409d10",
        "hlil": "return sub_409d10(arg2, arg1, strcmp) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return sub_409d10(arg2, arg1, strcmp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_file_extension",
          "confidence": 0.86,
          "rationale": "The function tail-calls sub_409d10 which extracts file extensions using strrchr and compares them via strcmp, indicating a file extension comparison routine.",
          "evidence_refs": [
            "imports:strrchr",
            "call:0x409d10"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_ext_cmp",
            "ai_path_extension_compare"
          ]
        },
        "explain": {
          "summary": "sub_409da0 is a thin wrapper that forwards its two arguments to sub_409d10 in swapped order, supplying strcmp as the comparison routine, effectively comparing the file extensions of two strings.",
          "details": [
            "The function performs a tail-call to sub_409d10 with arguments (arg2, arg1, strcmp).",
            "sub_409d10 extracts the substring after the last '.' in each input string using strrchr and then calls the provided comparator (strcmp) on those substrings."
          ],
          "evidence_refs": [
            "call:0x409d10",
            "imports:strcmp",
            "imports:strrchr"
          ],
          "unknowns": [
            "The exact content of data_41af54 used as a fallback when no '.' is found."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x409dc0",
      "original_name": "sub_409dc0",
      "final_name": "ai_compare_file_type_and_extension",
      "score": 29.8,
      "bb_count": 9,
      "insn_est": 36,
      "callers": 0,
      "callees": [
        {
          "addr": "0x409d10",
          "name": "ai_compare_file_extensions",
          "original_name": "sub_409d10"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x422fb8",
        "0x409d10"
      ],
      "snippets": {
        "asm": "  0x409dc0  endbr64 \n  0x409dc4  mov     eax, dword [rdi+0xa8]\n  0x409dca  mov     ecx, dword [rsi+0xa8]\n  0x409dd0  cmp     eax, 0x9\n  0x409dd3  sete    dl\n  0x409dd6  cmp     eax, 0x3\n  0x409dd9  sete    al\n  0x409ddc  or      edx, eax\n  0x409dde  cmp     ecx, 0x3\n  0x409de1  je      0x409e10\n  0x409e10  mov     eax, 0x1\n  0x409e15  test    dl, dl\n  0x409e17  je      0x409e28\n  0x409de3  cmp     ecx, 0x9\n  0x409de6  je      0x409e10\n  0x409e28  mov     edx, dword [rdi+0xac]\n  0x409e2e  xor     ecx, ecx  {0x0}\n  0x409e30  and     edx, 0xf000\n  0x409e36  cmp     edx, 0x4000\n  0x409e3c  sete    cl\n  0x409e3f  sub     eax, ecx\n  0x409e41  jne     0x409e0b\n  0x409e19  mov     rdx, qword [rel strcmp]\n  0x409e20  jmp     sub_409d10\n  0x409de8  mov     eax, dword [rsi+0xac]\n  0x409dee  mov     ecx, 0x1\n  0x409df3  and     eax, 0xf000\n  0x409df8  cmp     eax, 0x4000\n  0x409dfd  sete    al\n  0x409e00  movzx   eax, al\n  ... (126 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_409e3c:\nrcx.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx)\nreturn zx.q(rax_3 - rcx)\nrcx = 1\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_409e3c\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_409d10(arg1, arg2, strcmp, rcx) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_409e3c:\n            (uint8_t)rcx = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx)\n                return (uint64_t)(rax_3 - rcx);\n        }\n    }\n    else\n    {\n        rcx = 1;\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_409e3c;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_409d10(arg1, arg2, strcmp, rcx);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_file_type_and_extension",
          "confidence": 0.78,
          "rationale": "The function checks type fields and attribute flags of two objects, then delegates to a helper that compares file extensions using strcmp, indicating a comparator for file entries based on type/attributes and extension.",
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x409d10",
            "strings:none",
            "imports:none"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_file_entry_compare",
            "ai_sort_by_extension"
          ]
        },
        "explain": {
          "summary": "The function compares two structures' type fields (offset 0x15) against values 3 and 9, checks a flag in each structure at offset 0xac masked with 0xf000 for the value 0x4000, and ensures consistency between them. If the checks pass, it tailcalls sub_409d10 to compare the file extensions of two strings using strcmp; otherwise it returns a difference indicating a mismatch.",
          "details": [
            "Reads arg1[0x15] and arg2[0x15] and sets flags based on whether they equal 3 or 9.",
            "Masks a 32bit field at offset 0xac with 0xf000 and checks for 0x4000, using this to influence the return value.",
            "If the type and flag checks succeed, it calls sub_409d10 with strcmp to compare the substrings after the last '.' in the two input strings.",
            "Returns a numeric difference (rax_3 - rcx) when the flag or type checks fail, indicating a mismatch."
          ],
          "evidence_refs": [
            "call:0x409d10",
            "constants:0xf000",
            "constants:0x4000",
            "constants:0x422fb8",
            "constants:0x409d10"
          ],
          "unknowns": [
            "Exact semantics of the structures pointed by arg1 and arg2",
            "Purpose of the magic values 3 and 9",
            "Reason for using the mask 0xf000 and comparison to 0x4000"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x409e50",
      "original_name": "sub_409e50",
      "final_name": "ai_compare_file_entries",
      "score": 30.7,
      "bb_count": 9,
      "insn_est": 39,
      "callers": 0,
      "callees": [
        {
          "addr": "0x409d10",
          "name": "ai_compare_file_extensions",
          "original_name": "sub_409d10"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x422fb8",
        "0x409d10"
      ],
      "snippets": {
        "asm": "  0x409e50  endbr64 \n  0x409e54  mov     rcx, rdi\n  0x409e57  mov     rdi, rsi\n  0x409e5a  mov     esi, dword [rsi+0xa8]\n  0x409e60  mov     eax, dword [rcx+0xa8]\n  0x409e66  cmp     eax, 0x9\n  0x409e69  sete    dl\n  0x409e6c  cmp     eax, 0x3\n  0x409e6f  sete    al\n  0x409e72  or      edx, eax\n  0x409e74  cmp     esi, 0x3\n  0x409e77  je      0x409ea8\n  0x409ea8  mov     eax, 0x1\n  0x409ead  test    dl, dl\n  0x409eaf  je      0x409ec0\n  0x409e79  cmp     esi, 0x9\n  0x409e7c  je      0x409ea8\n  0x409ec0  mov     edx, dword [rcx+0xac]\n  0x409ec6  xor     esi, esi  {0x0}\n  0x409ec8  and     edx, 0xf000\n  0x409ece  cmp     edx, 0x4000\n  0x409ed4  sete    sil\n  0x409ed8  sub     eax, esi\n  0x409eda  jne     0x409ea1\n  0x409eb1  mov     rdx, qword [rel strcmp]\n  0x409eb8  mov     rsi, rcx\n  0x409ebb  jmp     sub_409d10\n  0x409e7e  mov     eax, dword [rdi+0xac]\n  0x409e84  mov     esi, 0x1\n  0x409e89  and     eax, 0xf000\n  ... (136 bytes total, truncated)",
        "hlil": "int32_t rsi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rsi == 3 || rsi == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_409ed4:\nint32_t rsi_3\nrsi_3.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rsi_3)\nreturn zx.q(rax_3 - rsi_3)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_409ed4\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_409d10(arg2, arg1, strcmp) __tailcall",
        "pseudoc": "{\n    int32_t rsi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rsi == 3 || rsi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_409ed4:\n            int32_t rsi_3;\n            (uint8_t)rsi_3 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rsi_3)\n                return (uint64_t)(rax_3 - rsi_3);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_409ed4;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_409d10(arg2, arg1, strcmp);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_file_entries",
          "confidence": 0.78,
          "rationale": "The function checks file mode bits (0x4000) to distinguish directories, compares type codes (3,9), and then delegates to a comparator that compares file extensions using strcmp, indicating a file entry comparison/sorting routine.",
          "evidence_refs": [
            "constants:0x4000",
            "constants:0xf000",
            "call:0x409d10"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_sort_by_type_and_extension",
            "ai_file_entry_comparator"
          ]
        },
        "explain": {
          "summary": "sub_409e50 validates two objects by checking a type field at offset 0x15 and a flag in a 32bit field at offset 0xAC, then conditionally compares their file extensions via a tail call to sub_409d10. If the type or flag checks differ, it returns the numeric difference; otherwise it delegates to sub_409d10 which uses strcmp on the extensions.",
          "details": [
            "Reads arg1[0x15] and arg2[0x15] to determine if they equal 3 or 9, setting a boolean rdx_1 for arg1.",
            "If arg2's type is 3 or 9, sets rax_3 = 1; otherwise computes rax_3 based on whether bits 0xf000 of the dword at offset 0xAC equal 0x4000.",
            "When arg1's type is not 3 or 9, also checks the same flag for arg1 and returns the difference if the flag values differ.",
            "If the type/flag checks pass, tailcalls sub_409d10(arg2, arg1, strcmp) which extracts file extensions with strrchr and compares them using strcmp.",
            "Returns either a numeric mismatch indicator or the result of the extension comparison."
          ],
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x409d10",
            "imports:strrchr",
            "strings:'[A\\\\A]A^]'"
          ],
          "unknowns": [
            "Exact semantics of the values 3 and 9 in the type field",
            "Purpose of the structures pointed by arg1 and arg2",
            "What the returned numeric difference represents in the broader program"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x409ee0",
      "original_name": "sub_409ee0",
      "final_name": "ai_stdout_isatty_cached",
      "score": 23.9,
      "bb_count": 3,
      "insn_est": 13,
      "callers": 7,
      "callees": [
        {
          "addr": "0x4047c0",
          "name": "ai_check_isatty",
          "original_name": "isatty"
        }
      ],
      "import_refs": [
        "isatty"
      ],
      "string_refs": [],
      "constants": [
        "0x423027",
        "0x4047c0"
      ],
      "snippets": {
        "asm": "  0x409ee0  movzx   eax, byte [rel data_423027]\n  0x409ee7  test    al, al\n  0x409ee9  js      0x409ef0\n  0x409ef0  push    rbp {__saved_rbp}\n  0x409ef1  mov     edi, 0x1\n  0x409ef6  mov     rbp, rsp {__saved_rbp}\n  0x409ef9  call    isatty\n  0x409efe  pop     rbp {__saved_rbp}\n  0x409eff  mov     byte [rel data_423027], al\n  0x409f05  and     eax, 0x1\n  0x409f08  retn     {__return_addr}\n  0x409eeb  and     eax, 0x1\n  0x409eee  retn     {__return_addr}",
        "hlil": "uint32_t rax_3 = zx.d(data_423027)\nif (rax_3.b s>= 0)\nreturn zx.q(rax_3) & 1\nint32_t rax_1 = isatty(1)\ndata_423027 = rax_1.b\nreturn zx.q(rax_1) & 1",
        "pseudoc": "{\n    uint32_t rax_3 = (uint32_t)data_423027;\n    \n    if ((char)rax_3 >= 0)\n        return (uint64_t)rax_3 & 1;\n    \n    int32_t rax_1 = isatty(1);\n    data_423027 = (uint8_t)rax_1;\n    return (uint64_t)rax_1 & 1;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_stdout_isatty_cached",
          "confidence": 0.96,
          "rationale": "The function checks a cached global flag; if unset it calls isatty(1) to determine if stdout is a terminal, stores the result, and returns the low bit.",
          "evidence_refs": [
            "imports:isatty",
            "call:0x4047c0",
            "constants:0x423027"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_check_stdout_tty",
            "ai_isatty_stdout_cached"
          ]
        },
        "explain": {
          "summary": "The function checks a cached byte at address 0x423027; if it is non-negative it returns its lowest bit. If the cached value is negative, it calls isatty(1) to determine if stdout is a terminal, stores the result in the cache, and returns the result's lowest bit.",
          "details": [
            "Reads a global byte (data_423027) and uses its signed value to decide whether to use a cached result.",
            "If the cached byte is negative, invokes isatty(1) via a tail call to the imported isatty function, caches the returned value, and returns its LSB as a boolean."
          ],
          "evidence_refs": [
            "imports:isatty",
            "call:0x4047c0",
            "constants:0x423027"
          ],
          "unknowns": [
            "Initial value of data_423027 before first call",
            "Why only the LSB of the isatty result is returned (though isatty returns 0/1)",
            "Potential side effects beyond caching"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x409f10",
      "original_name": "sub_409f10",
      "final_name": "ai_cleanup_global_structs",
      "score": 79.0,
      "bb_count": 6,
      "insn_est": 45,
      "callers": 3,
      "callees": [
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404920",
          "name": "ai_free_security_context",
          "original_name": "freecon"
        },
        {
          "addr": "0x4248e8"
        }
      ],
      "import_refs": [
        "free",
        "free",
        "free",
        "freecon"
      ],
      "string_refs": [],
      "constants": [
        "0x423318",
        "0x4232c9",
        "0x4232c8",
        "0x4232c4",
        "0x4232c0",
        "0x4232bc",
        "0x4232b8",
        "0x4232b4",
        "0x4232b0",
        "0x4232ac",
        "0x4232a8",
        "0x4232a4",
        "0x4232a0",
        "0x423024",
        "0x404920",
        "0x423450",
        "0x4046b0"
      ],
      "snippets": {
        "asm": "  0x409f10  push    rbp {__saved_rbp}\n  0x409f11  mov     rbp, rsp {__saved_rbp}\n  0x409f14  push    r13 {__saved_r13}\n  0x409f16  push    r12 {__saved_r12}\n  0x409f18  push    rbx {__saved_rbx}\n  0x409f19  sub     rsp, 0x8\n  0x409f1d  cmp     qword [rel data_423318], 0x0\n  0x409f25  je      0x409f7b\n  0x409f7b  mov     qword [rel data_423318], 0x0\n  0x409f86  mov     byte [rel data_4232c9], 0x0\n  0x409f8d  mov     byte [rel data_4232c8], 0x0\n  0x409f94  mov     dword [rel data_4232c4], 0x0\n  0x409f9e  mov     dword [rel data_4232c0], 0x0\n  0x409fa8  mov     dword [rel data_4232bc], 0x0\n  0x409fb2  mov     dword [rel data_4232b8], 0x0\n  0x409fbc  mov     dword [rel data_4232b4], 0x0\n  0x409fc6  mov     dword [rel data_4232b0], 0x0\n  0x409fd0  mov     dword [rel data_4232ac], 0x0\n  0x409fda  mov     dword [rel data_4232a8], 0x0\n  0x409fe4  mov     dword [rel data_4232a4], 0x0\n  0x409fee  mov     dword [rel data_4232a0], 0x0\n  0x409ff8  add     rsp, 0x8\n  0x409ffc  pop     rbx {__saved_rbx}\n  0x409ffd  pop     r12 {__saved_r12}\n  0x409fff  pop     r13 {__saved_r13}\n  0x40a001  pop     rbp {__saved_rbp}\n  0x40a002  retn     {__return_addr}\n  0x409f27  xor     r12d, r12d  {0x0}\n  0x409f2a  lea     r13, [rel data_423024]\n  0x409f31  nop     dword [rax]\n  ... (243 bytes total, truncated)",
        "hlil": "if (data_423318 != 0)\nint64_t i = 0\nint64_t* rbx_1 = *(data_423450 + (i << 3))\nfree(*rbx_1)\nfree(rbx_1[1])\nfree(rbx_1[2])\nint64_t rdi_4 = rbx_1[0x16]\nif (rdi_4 != &data_423024)\nfreecon(rdi_4)\ni += 1\ndo while (i u< data_423318)\ndata_423318 = 0\n__builtin_memset(&data_4232a0, 0, 0x2a)\nreturn ",
        "pseudoc": "{\n    if (data_423318)\n    {\n        int64_t i = 0;\n        \n        do\n        {\n            int64_t* rbx_1 = *(uint64_t*)(data_423450 + (i << 3));\n            free(*(uint64_t*)rbx_1);\n            free(rbx_1[1]);\n            free(rbx_1[2]);\n            int64_t rdi_4 = rbx_1[0x16];\n            \n            if (rdi_4 != &data_423024)\n                freecon(rdi_4);\n            \n            i += 1;\n        } while (i < data_423318);\n    }\n    \n    data_423318 = 0;\n    __builtin_memset(&data_4232a0, 0, 0x2a);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_cleanup_global_structs",
          "confidence": 0.93,
          "rationale": "The function iterates over a global array, frees multiple allocated pointers for each entry, conditionally frees a connection object, then resets the count and zeroes a data region, indicating a global cleanup routine.",
          "evidence_refs": [
            "imports:free",
            "imports:freecon",
            "call:0x4046b0",
            "call:0x4248e8"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_release_global_memory",
            "ai_reset_global_state"
          ]
        },
        "explain": {
          "summary": "sub_409f10 is a cleanup routine that iterates over a global array of structures, frees several allocated pointers within each entry, conditionally frees a connection object, then resets the entry count and clears a related data buffer.",
          "details": [
            "If data_423318 (the entry count) is non-zero, the function loops from i = 0 to i < data_423318, retrieving a pointer from data_423450 + (i * 8).",
            "For each structure, it frees three pointers stored at offsets 0, 8, and 16 bytes (rbx_1[0], rbx_1[1], rbx_1[2]) using the imported free function.",
            "It then checks a pointer at offset 0x16 (rbx_1[0x16]); if it does not equal the global &data_423024, it frees it with freecon.",
            "After processing all entries, it sets data_423318 to 0 and zeroes a 0x2abyte region starting at data_4232a0 with memset."
          ],
          "evidence_refs": [
            "imports:free",
            "imports:freecon",
            "call:0x4046b0",
            "call:0x4248e8"
          ],
          "unknowns": [
            "Exact layout and semantic meaning of the structures referenced by data_423450",
            "Purpose of the data_4232a0 buffer being cleared"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x40a010",
      "original_name": "sub_40a010",
      "final_name": "ai_struct_compare_with_fallback_strcoll",
      "score": 28.4,
      "bb_count": 3,
      "insn_est": 33,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a010  endbr64 \n  0x40a014  mov     rax, qword [rsi+0x80]\n  0x40a01b  xor     edx, edx  {0x0}\n  0x40a01d  cmp     qword [rdi+0x80], rax\n  0x40a024  setg    al\n  0x40a027  setl    dl\n  0x40a02a  movzx   eax, al\n  0x40a02d  sub     edx, eax\n  0x40a02f  mov     rax, qword [rsi+0x88]\n  0x40a036  cmp     qword [rdi+0x88], rax\n  0x40a03d  setl    al\n  0x40a040  setg    cl\n  0x40a043  movzx   eax, al\n  0x40a046  movzx   ecx, cl\n  0x40a049  sub     eax, ecx\n  0x40a04b  lea     eax, [rax+rdx*2]\n  0x40a04e  test    eax, eax\n  0x40a050  jne     0x40a080\n  0x40a080  retn     {__return_addr}\n  0x40a052  push    rbp {__saved_rbp}\n  0x40a053  mov     rbp, rsp {__saved_rbp}\n  0x40a056  push    r12 {__saved_r12}\n  0x40a058  push    rbx {__saved_rbx}\n  0x40a059  mov     rbx, qword [rdi]\n  0x40a05c  mov     r12, qword [rsi]\n  0x40a05f  call    __errno_location\n  0x40a064  mov     rsi, r12\n  0x40a067  mov     rdi, rbx\n  0x40a06a  mov     dword [rax], 0x0\n  0x40a070  pop     rbx {__saved_rbx}\n  ... (106 bytes total, truncated)",
        "hlil": "int64_t rax = arg2[0x10]\nint64_t temp0 = arg1[0x10]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg2[0x11]\nint64_t temp1 = arg1[0x11]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nchar* rbx = *arg1\nchar* r12 = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[0x10];\n    int64_t temp0 = arg1[0x10];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg2[0x11];\n    int64_t temp1 = arg1[0x11];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    char* rbx = *(uint64_t*)arg1;\n    char* r12 = *(uint64_t*)arg2;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_with_fallback_strcoll",
          "confidence": 0.86,
          "rationale": "The function compares two structures by numeric fields at offsets 0x10/0x11, and if they are equal it falls back to a locale-aware string comparison using strcoll, resetting errno before the call.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_structs",
            "ai_fallback_locale_string_compare"
          ]
        },
        "explain": {
          "summary": "sub_40a010 compares two structures by examining the 0x10 and 0x11 fields; it returns a nonzero integer if those fields differ, otherwise it clears errno and delegates to strcoll to compare the strings pointed to by the structures' first members.",
          "details": [
            "The function loads 64bit values at offset 0x10 from both arguments and computes a signed result based on <, > comparisons of those values and the values at offset 0x11.",
            "If the computed result is nonzero, it is returned directly; otherwise the function retrieves the pointers stored at offset 0 of each argument, resets errno to 0 via __errno_location, and calls strcoll on the two strings."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0x10 and 0x11 (e.g., version, timestamp, or other numeric identifier).",
            "Why the result calculation mixes two comparison flags into a single integer rather than using a simple subtraction."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a090",
      "original_name": "sub_40a090",
      "final_name": "ai_struct_comparator",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40a010",
          "name": "ai_struct_compare_with_fallback_strcoll",
          "original_name": "sub_40a010"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40a010"
      ],
      "snippets": {
        "asm": "  0x40a090  endbr64 \n  0x40a094  mov     eax, dword [rdi+0xa8]\n  0x40a09a  mov     ecx, dword [rsi+0xa8]\n  0x40a0a0  cmp     eax, 0x9\n  0x40a0a3  sete    dl\n  0x40a0a6  cmp     eax, 0x3\n  0x40a0a9  sete    al\n  0x40a0ac  or      edx, eax\n  0x40a0ae  cmp     ecx, 0x3\n  0x40a0b1  je      0x40a0e0\n  0x40a0e0  mov     eax, 0x1\n  0x40a0e5  test    dl, dl\n  0x40a0e7  je      0x40a0f0\n  0x40a0b3  cmp     ecx, 0x9\n  0x40a0b6  je      0x40a0e0\n  0x40a0f0  mov     edx, dword [rdi+0xac]\n  0x40a0f6  xor     ecx, ecx  {0x0}\n  0x40a0f8  and     edx, 0xf000\n  0x40a0fe  cmp     edx, 0x4000\n  0x40a104  sete    cl\n  0x40a107  sub     eax, ecx\n  0x40a109  jne     0x40a0db\n  0x40a0e9  jmp     sub_40a010\n  0x40a0b8  mov     eax, dword [rsi+0xac]\n  0x40a0be  mov     ecx, 0x1\n  0x40a0c3  and     eax, 0xf000\n  0x40a0c8  cmp     eax, 0x4000\n  0x40a0cd  sete    al\n  0x40a0d0  movzx   eax, al\n  0x40a0d3  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40a104:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40a104\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40a010(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40a104:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40a104;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40a010(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_comparator",
          "confidence": 0.85,
          "rationale": "The function compares fields of two structures (type at offset 0x15, flag bits at offset 0xac, and later numeric fields) and falls back to a string comparison, indicating it is a comparator used for sorting or ordering objects.",
          "evidence_refs": [
            "call:0x40a010",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "tags": [],
          "alt_names": [
            "ai_entry_compare",
            "ai_object_sort_key"
          ]
        },
        "explain": {
          "summary": "sub_40a090 compares specific fields of two structures, checking for particular flag values (3 or 9) and a masked high-order bit pattern at offset 0xac, returning a numeric difference when mismatched, otherwise delegating to sub_40a010 for further comparison.",
          "details": [
            "Reads a byte at offset 0x15 from both arguments and sets flags if the value equals 3 or 9.",
            "If either argument has a flag of 3 or 9, it sets a temporary result to 1; otherwise it extracts the high 4 bits of a dword at offset 0xac, masks with 0xf000, and checks if it equals 0x4000.",
            "Compares the derived flag/result between the two structures; if they differ, returns the difference.",
            "When no early return occurs, it tailcalls sub_40a010, which performs further numeric and string comparison."
          ],
          "evidence_refs": [
            "call:0x40a010"
          ],
          "unknowns": [
            "Exact semantic meaning of the structures and the fields at offsets 0x15 and 0xac",
            "Purpose of the constants 0xf000 and 0x4000 in the broader program context"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a110",
      "original_name": "sub_40a110",
      "final_name": "ai_struct_comparator",
      "score": 28.4,
      "bb_count": 3,
      "insn_est": 33,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a110  endbr64 \n  0x40a114  mov     rax, qword [rdi+0x80]\n  0x40a11b  xor     edx, edx  {0x0}\n  0x40a11d  cmp     qword [rsi+0x80], rax\n  0x40a124  setg    al\n  0x40a127  setl    dl\n  0x40a12a  movzx   eax, al\n  0x40a12d  sub     edx, eax\n  0x40a12f  mov     rax, qword [rdi+0x88]\n  0x40a136  cmp     qword [rsi+0x88], rax\n  0x40a13d  setl    al\n  0x40a140  setg    cl\n  0x40a143  movzx   eax, al\n  0x40a146  movzx   ecx, cl\n  0x40a149  sub     eax, ecx\n  0x40a14b  lea     eax, [rax+rdx*2]\n  0x40a14e  test    eax, eax\n  0x40a150  jne     0x40a180\n  0x40a180  retn     {__return_addr}\n  0x40a152  push    rbp {__saved_rbp}\n  0x40a153  mov     rbp, rsp {__saved_rbp}\n  0x40a156  push    r12 {__saved_r12}\n  0x40a158  push    rbx {__saved_rbx}\n  0x40a159  mov     rbx, qword [rsi]\n  0x40a15c  mov     r12, qword [rdi]\n  0x40a15f  call    __errno_location\n  0x40a164  mov     rsi, r12\n  0x40a167  mov     rdi, rbx\n  0x40a16a  mov     dword [rax], 0x0\n  0x40a170  pop     rbx {__saved_rbx}\n  ... (106 bytes total, truncated)",
        "hlil": "int64_t rax = arg1[0x10]\nint64_t temp0 = arg2[0x10]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg1[0x11]\nint64_t temp1 = arg2[0x11]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nchar* rbx = *arg2\nchar* r12 = *arg1\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[0x10];\n    int64_t temp0 = arg2[0x10];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg1[0x11];\n    int64_t temp1 = arg2[0x11];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    char* rbx = *(uint64_t*)arg2;\n    char* r12 = *(uint64_t*)arg1;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_comparator",
          "confidence": 0.86,
          "rationale": "The function compares two structures by numeric fields at offsets 0x10/0x11, returns a comparison result, and falls back to a locale-aware string comparison (strcoll) when those fields are equal, typical of a custom comparator.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_entries",
            "ai_locale_fallback_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two structured objects by examining two integer fields at offsets 0x10 and 0x11, computes a composite ordering value, and if the objects are otherwise equal it clears errno and performs a locale-aware string comparison using strcoll, returning the resulting ordering integer.",
          "details": [
            "It loads 64bit values from arg1[0x10] and arg2[0x10] and sets flags based on < and > comparisons, then does the same for offsets 0x11.",
            "A result is calculated from the comparison flags: ((rdx - (uint8_t)rax) << 1) + ((uint8_t)rax_2 - cond:1). If nonzero, this result is returned as the ordering.",
            "When the result is zero (fields equal), the function retrieves the first pointer from each argument, clears errno via __errno_location(), and tailcalls strcoll to compare the pointedto strings, returning that result."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0x10 and 0x11 in the structures",
            "Why the specific bitwise combination of comparison results is used for the ordering"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a190",
      "original_name": "sub_40a190",
      "final_name": "ai_struct_compare_by_type_and_flag",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40a110",
          "name": "ai_struct_comparator",
          "original_name": "sub_40a110"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40a110"
      ],
      "snippets": {
        "asm": "  0x40a190  endbr64 \n  0x40a194  mov     eax, dword [rdi+0xa8]\n  0x40a19a  mov     ecx, dword [rsi+0xa8]\n  0x40a1a0  cmp     eax, 0x9\n  0x40a1a3  sete    dl\n  0x40a1a6  cmp     eax, 0x3\n  0x40a1a9  sete    al\n  0x40a1ac  or      edx, eax\n  0x40a1ae  cmp     ecx, 0x3\n  0x40a1b1  je      0x40a1e0\n  0x40a1e0  mov     eax, 0x1\n  0x40a1e5  test    dl, dl\n  0x40a1e7  je      0x40a1f0\n  0x40a1b3  cmp     ecx, 0x9\n  0x40a1b6  je      0x40a1e0\n  0x40a1f0  mov     edx, dword [rdi+0xac]\n  0x40a1f6  xor     ecx, ecx  {0x0}\n  0x40a1f8  and     edx, 0xf000\n  0x40a1fe  cmp     edx, 0x4000\n  0x40a204  sete    cl\n  0x40a207  sub     eax, ecx\n  0x40a209  jne     0x40a1db\n  0x40a1e9  jmp     sub_40a110\n  0x40a1b8  mov     eax, dword [rsi+0xac]\n  0x40a1be  mov     ecx, 0x1\n  0x40a1c3  and     eax, 0xf000\n  0x40a1c8  cmp     eax, 0x4000\n  0x40a1cd  sete    al\n  0x40a1d0  movzx   eax, al\n  0x40a1d3  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40a204:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40a204\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40a110(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40a204:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40a204;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40a110(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_by_type_and_flag",
          "confidence": 0.78,
          "rationale": "The function checks type fields (values 3 or 9) and a masked flag (0x4000) in two structures, returns a difference or delegates to sub_40a110 which performs further numeric and string comparison, indicating a comparator for sorting or ordering objects.",
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a110"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_entries",
            "ai_sort_key_compare"
          ]
        },
        "explain": {
          "summary": "sub_40a190 compares two file-like structures, first checking special type codes and directory flags, then delegating to sub_40a110 for timestamp and name comparison, effectively implementing a sort order that prioritizes directories and handles special cases.",
          "details": [
            "Reads a field at offset 0x15 from both arguments and checks for values 3 or 9, setting a flag if either matches.",
            "If the second argument has type 3 or 9, it sets a base comparison result of 1; otherwise it extracts the mode bits at offset 0xac, masks with 0xf000, and checks for the directory flag 0x4000.",
            "When the type flag is not set, it compares the directory flag of the first argument against the expected value and returns a difference if they differ.",
            "If the preliminary checks pass, it tailcalls sub_40a110, which compares timestamps (fields at 0x10/0x11) and finally falls back to a localeaware string comparison via strcoll.",
            "The function returns early with a numeric ordering when directory status or special type codes differ, otherwise it defers to the more detailed comparator."
          ],
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a110"
          ],
          "unknowns": [
            "Exact meaning of the values 3 and 9 at offset 0x15",
            "Why the function returns the difference of boolean flags rather than a fixed ordering value"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a210",
      "original_name": "sub_40a210",
      "final_name": "ai_struct_comparator",
      "score": 28.4,
      "bb_count": 3,
      "insn_est": 33,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a210  endbr64 \n  0x40a214  mov     rax, qword [rsi+0x70]\n  0x40a218  xor     edx, edx  {0x0}\n  0x40a21a  cmp     qword [rdi+0x70], rax\n  0x40a21e  setg    al\n  0x40a221  setl    dl\n  0x40a224  movzx   eax, al\n  0x40a227  sub     edx, eax\n  0x40a229  mov     rax, qword [rsi+0x78]\n  0x40a22d  cmp     qword [rdi+0x78], rax\n  0x40a231  setl    al\n  0x40a234  setg    cl\n  0x40a237  movzx   eax, al\n  0x40a23a  movzx   ecx, cl\n  0x40a23d  sub     eax, ecx\n  0x40a23f  lea     eax, [rax+rdx*2]\n  0x40a242  test    eax, eax\n  0x40a244  jne     0x40a270\n  0x40a270  retn     {__return_addr}\n  0x40a246  push    rbp {__saved_rbp}\n  0x40a247  mov     rbp, rsp {__saved_rbp}\n  0x40a24a  push    r12 {__saved_r12}\n  0x40a24c  push    rbx {__saved_rbx}\n  0x40a24d  mov     rbx, qword [rdi]\n  0x40a250  mov     r12, qword [rsi]\n  0x40a253  call    __errno_location\n  0x40a258  mov     rsi, r12\n  0x40a25b  mov     rdi, rbx\n  0x40a25e  mov     dword [rax], 0x0\n  0x40a264  pop     rbx {__saved_rbx}\n  ... (94 bytes total, truncated)",
        "hlil": "int64_t rax = arg2[0xe]\nint64_t temp0 = arg1[0xe]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg2[0xf]\nint64_t temp1 = arg1[0xf]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nchar* rbx = *arg1\nchar* r12 = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[0xe];\n    int64_t temp0 = arg1[0xe];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg2[0xf];\n    int64_t temp1 = arg1[0xf];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    char* rbx = *(uint64_t*)arg1;\n    char* r12 = *(uint64_t*)arg2;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_comparator",
          "confidence": 0.85,
          "rationale": "The function compares two structures by numeric fields at offsets 0xe/0xf, returns a result if they differ, otherwise clears errno and performs a locale-aware string comparison via strcoll, indicating a custom comparator used for sorting.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_custom_compare",
            "ai_locale_string_compare"
          ]
        },
        "explain": {
          "summary": "The function implements a comparator that first orders two objects by two integer fields at offsets 0xe and 0xf, returning a signed result based on those fields; if the fields are equal it falls back to a locale-aware string comparison of the objects' name pointers.",
          "details": [
            "It loads 64bit values from arg1[0xe] and arg2[0xe] and computes a signed result using < and > comparisons, weighting this comparison by 2.",
            "It then loads values from arg1[0xf] and arg2[0xf] and adds a secondary comparison weighted by 1 to the result.",
            "If the combined result is nonzero, it returns that value as the ordering indicator.",
            "When the integer fields are equal, it retrieves the first pointer from each structure, clears errno via __errno_location, and calls strcoll to compare the strings.",
            "The function thus provides a lexicographic ordering: primary integer field, secondary integer field, then string name."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x40a210"
          ],
          "unknowns": [
            "Exact semantic meaning of the structures and the fields at offsets 0xe and 0xf",
            "Why errno is cleared before calling strcoll"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40a280",
      "original_name": "sub_40a280",
      "final_name": "ai_compare_struct_by_type_flag",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40a210",
          "name": "ai_struct_comparator",
          "original_name": "sub_40a210"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40a210"
      ],
      "snippets": {
        "asm": "  0x40a280  endbr64 \n  0x40a284  mov     eax, dword [rdi+0xa8]\n  0x40a28a  mov     ecx, dword [rsi+0xa8]\n  0x40a290  cmp     eax, 0x9\n  0x40a293  sete    dl\n  0x40a296  cmp     eax, 0x3\n  0x40a299  sete    al\n  0x40a29c  or      edx, eax\n  0x40a29e  cmp     ecx, 0x3\n  0x40a2a1  je      0x40a2d0\n  0x40a2d0  mov     eax, 0x1\n  0x40a2d5  test    dl, dl\n  0x40a2d7  je      0x40a2e0\n  0x40a2a3  cmp     ecx, 0x9\n  0x40a2a6  je      0x40a2d0\n  0x40a2e0  mov     edx, dword [rdi+0xac]\n  0x40a2e6  xor     ecx, ecx  {0x0}\n  0x40a2e8  and     edx, 0xf000\n  0x40a2ee  cmp     edx, 0x4000\n  0x40a2f4  sete    cl\n  0x40a2f7  sub     eax, ecx\n  0x40a2f9  jne     0x40a2cb\n  0x40a2d9  jmp     sub_40a210\n  0x40a2a8  mov     eax, dword [rsi+0xac]\n  0x40a2ae  mov     ecx, 0x1\n  0x40a2b3  and     eax, 0xf000\n  0x40a2b8  cmp     eax, 0x4000\n  0x40a2bd  sete    al\n  0x40a2c0  movzx   eax, al\n  0x40a2c3  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40a2f4:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40a2f4\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40a210(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40a2f4:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40a2f4;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40a210(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_flag",
          "confidence": 0.73,
          "rationale": "The function checks type fields (values 3 or 9) and specific flag bits (mask 0xf000 against 0x4000) in two structures, returns a difference or delegates to sub_40a210 which performs further numeric and string comparison, indicating a comparator for objects with type/flag handling.",
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a210"
          ],
          "tags": [
            "file_io",
            "config"
          ],
          "alt_names": [
            "ai_struct_comparator",
            "ai_type_flag_compare"
          ]
        },
        "explain": {
          "summary": "sub_40a280 compares two objects based on a type field at offset 0x15 and a flag in the word at offset 0xac, returning a simple ordering value or delegating to sub_40a210 for a deeper comparison.",
          "details": [
            "It reads a 32bit value at offset 0x15 from each argument and checks if either is 3 or 9, using these as special type codes.",
            "A mask of 0xf000 on the dword at offset 0xac is compared against 0x4000 to derive a boolean flag for each object.",
            "If the type codes match certain conditions, it may return the difference of the flag values; otherwise it tailcalls sub_40a210 for further numeric and lexical comparison.",
            "sub_40a210 performs additional numeric field comparisons (offsets 0xe and 0xf) and finally calls strcoll on the strings pointed to by the objects."
          ],
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a210"
          ],
          "unknowns": [
            "Exact semantic meaning of the values at offset 0x15 and the flag bits at offset 0xac",
            "Why only the values 3 and 9 are treated specially"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io",
        "config"
      ]
    },
    {
      "addr": "0x40a300",
      "original_name": "sub_40a300",
      "final_name": "ai_struct_comparator_by_fields_and_name",
      "score": 28.4,
      "bb_count": 3,
      "insn_est": 33,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a300  endbr64 \n  0x40a304  mov     rax, qword [rdi+0x70]\n  0x40a308  xor     edx, edx  {0x0}\n  0x40a30a  cmp     qword [rsi+0x70], rax\n  0x40a30e  setg    al\n  0x40a311  setl    dl\n  0x40a314  movzx   eax, al\n  0x40a317  sub     edx, eax\n  0x40a319  mov     rax, qword [rdi+0x78]\n  0x40a31d  cmp     qword [rsi+0x78], rax\n  0x40a321  setl    al\n  0x40a324  setg    cl\n  0x40a327  movzx   eax, al\n  0x40a32a  movzx   ecx, cl\n  0x40a32d  sub     eax, ecx\n  0x40a32f  lea     eax, [rax+rdx*2]\n  0x40a332  test    eax, eax\n  0x40a334  jne     0x40a360\n  0x40a360  retn     {__return_addr}\n  0x40a336  push    rbp {__saved_rbp}\n  0x40a337  mov     rbp, rsp {__saved_rbp}\n  0x40a33a  push    r12 {__saved_r12}\n  0x40a33c  push    rbx {__saved_rbx}\n  0x40a33d  mov     rbx, qword [rsi]\n  0x40a340  mov     r12, qword [rdi]\n  0x40a343  call    __errno_location\n  0x40a348  mov     rsi, r12\n  0x40a34b  mov     rdi, rbx\n  0x40a34e  mov     dword [rax], 0x0\n  0x40a354  pop     rbx {__saved_rbx}\n  ... (94 bytes total, truncated)",
        "hlil": "int64_t rax = arg1[0xe]\nint64_t temp0 = arg2[0xe]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg1[0xf]\nint64_t temp1 = arg2[0xf]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nchar* rbx = *arg2\nchar* r12 = *arg1\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[0xe];\n    int64_t temp0 = arg2[0xe];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg1[0xf];\n    int64_t temp1 = arg2[0xf];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    char* rbx = *(uint64_t*)arg2;\n    char* r12 = *(uint64_t*)arg1;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_comparator_by_fields_and_name",
          "confidence": 0.86,
          "rationale": "The function compares two structures using numeric fields at offsets 0xe/0xf, returns a comparison result, and falls back to a string collation (strcoll) after clearing errno, indicating a custom comparator used for sorting.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "tags": [],
          "alt_names": [
            "ai_custom_sort_comparator",
            "ai_compare_entries"
          ]
        },
        "explain": {
          "summary": "sub_40a300 implements a comparator that first orders two objects by two integer fields at offsets 0xE and 0xF, returning a nonzero ordering value if they differ; if those fields are equal it clears errno and delegates to localeaware string comparison via strcoll on the pointers stored at the start of each object.",
          "details": [
            "Loads 64bit values from arg1[0xE] and arg2[0xE] and from arg1[0xF] and arg2[0xF] and computes a signed comparison result using bitwise logic.",
            "If the computed result is nonzero, it is returned directly as the ordering indicator.",
            "When the numeric fields compare equal, the function retrieves the first pointer from each structure, resets errno to 0, and tailcalls strcoll to compare the associated strings."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0xE and 0xF (e.g., timestamps, version numbers).",
            "Why the result calculation uses the specific bitwise expression rather than a straightforward subtraction."
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a370",
      "original_name": "sub_40a370",
      "final_name": "ai_compare_struct_by_type_flag",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40a300",
          "name": "ai_struct_comparator_by_fields_and_name",
          "original_name": "sub_40a300"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40a300"
      ],
      "snippets": {
        "asm": "  0x40a370  endbr64 \n  0x40a374  mov     eax, dword [rdi+0xa8]\n  0x40a37a  mov     ecx, dword [rsi+0xa8]\n  0x40a380  cmp     eax, 0x9\n  0x40a383  sete    dl\n  0x40a386  cmp     eax, 0x3\n  0x40a389  sete    al\n  0x40a38c  or      edx, eax\n  0x40a38e  cmp     ecx, 0x3\n  0x40a391  je      0x40a3c0\n  0x40a3c0  mov     eax, 0x1\n  0x40a3c5  test    dl, dl\n  0x40a3c7  je      0x40a3d0\n  0x40a393  cmp     ecx, 0x9\n  0x40a396  je      0x40a3c0\n  0x40a3d0  mov     edx, dword [rdi+0xac]\n  0x40a3d6  xor     ecx, ecx  {0x0}\n  0x40a3d8  and     edx, 0xf000\n  0x40a3de  cmp     edx, 0x4000\n  0x40a3e4  sete    cl\n  0x40a3e7  sub     eax, ecx\n  0x40a3e9  jne     0x40a3bb\n  0x40a3c9  jmp     sub_40a300\n  0x40a398  mov     eax, dword [rsi+0xac]\n  0x40a39e  mov     ecx, 0x1\n  0x40a3a3  and     eax, 0xf000\n  0x40a3a8  cmp     eax, 0x4000\n  0x40a3ad  sete    al\n  0x40a3b0  movzx   eax, al\n  0x40a3b3  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40a3e4:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40a3e4\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40a300(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40a3e4:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40a3e4;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40a300(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_flag",
          "confidence": 0.78,
          "rationale": "The function checks type fields (values 3 or 9) and a masked flag (0xf000 == 0x4000) in two structures, returns a difference or delegates to sub_40a300 which performs further comparison, indicating a comparator for objects based on type and flag.",
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a300"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_type_flag_compare"
          ]
        },
        "explain": {
          "summary": "sub_40a370 compares two structures based on a type flag at offset 0x15 and a masked field at offset 0xac, returning a difference if they differ, otherwise delegating to sub_40a300 for further numeric and locale-aware string comparison.",
          "details": [
            "It checks if arg1[0x15] or arg2[0x15] equal the values 3 or 9, using those as special cases that set a boolean flag.",
            "It extracts a 0xf000 mask from the 0xac field of each argument and tests for the value 0x4000, using the result to compute a comparison value.",
            "If the computed comparison values differ, it returns their difference; otherwise it tailcalls sub_40a300, which compares additional numeric fields and finally uses strcoll for localeaware string ordering."
          ],
          "evidence_refs": [
            "call:0x40a300",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantic meaning of the values 3, 9 and the masked 0x4000 flag",
            "The overall data structure layout beyond the examined offsets"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a3f0",
      "original_name": "sub_40a3f0",
      "final_name": "ai_struct_compare_by_fields_and_name",
      "score": 28.4,
      "bb_count": 3,
      "insn_est": 33,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a3f0  endbr64 \n  0x40a3f4  mov     rax, qword [rsi+0x60]\n  0x40a3f8  xor     edx, edx  {0x0}\n  0x40a3fa  cmp     qword [rdi+0x60], rax\n  0x40a3fe  setg    al\n  0x40a401  setl    dl\n  0x40a404  movzx   eax, al\n  0x40a407  sub     edx, eax\n  0x40a409  mov     rax, qword [rsi+0x68]\n  0x40a40d  cmp     qword [rdi+0x68], rax\n  0x40a411  setl    al\n  0x40a414  setg    cl\n  0x40a417  movzx   eax, al\n  0x40a41a  movzx   ecx, cl\n  0x40a41d  sub     eax, ecx\n  0x40a41f  lea     eax, [rax+rdx*2]\n  0x40a422  test    eax, eax\n  0x40a424  jne     0x40a450\n  0x40a450  retn     {__return_addr}\n  0x40a426  push    rbp {__saved_rbp}\n  0x40a427  mov     rbp, rsp {__saved_rbp}\n  0x40a42a  push    r12 {__saved_r12}\n  0x40a42c  push    rbx {__saved_rbx}\n  0x40a42d  mov     rbx, qword [rdi]\n  0x40a430  mov     r12, qword [rsi]\n  0x40a433  call    __errno_location\n  0x40a438  mov     rsi, r12\n  0x40a43b  mov     rdi, rbx\n  0x40a43e  mov     dword [rax], 0x0\n  0x40a444  pop     rbx {__saved_rbx}\n  ... (94 bytes total, truncated)",
        "hlil": "int64_t rax = arg2[0xc]\nint64_t temp0 = arg1[0xc]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg2[0xd]\nint64_t temp1 = arg1[0xd]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nchar* rbx = *arg1\nchar* r12 = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[0xc];\n    int64_t temp0 = arg1[0xc];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg2[0xd];\n    int64_t temp1 = arg1[0xd];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    char* rbx = *(uint64_t*)arg1;\n    char* r12 = *(uint64_t*)arg2;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_by_fields_and_name",
          "confidence": 0.86,
          "rationale": "The function compares two structures using numeric fields at offsets 0xc and 0xd, then falls back to a locale-aware string comparison via strcoll, acting as a custom comparator for sorting.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404b60"
          ],
          "tags": [],
          "alt_names": [
            "ai_custom_sort",
            "ai_compare_entries"
          ]
        },
        "explain": {
          "summary": "sub_40a3f0 compares two objects by inspecting two integer fields at offsets 0xc and 0xd; it returns a nonzero ordering value if those fields differ. If the numeric fields are equal, it clears errno and delegates to strcoll to perform a localeaware string comparison of the pointers stored at the objects' first fields. The result is used as a combined ordering metric.",
          "details": [
            "Loads arg1[0xc] and arg2[0xc] and computes a signed comparison, contributing to the result.",
            "Loads arg1[0xd] and arg2[0xd] and computes another signed comparison, also contributing to the result.",
            "If the combined numeric comparison result is zero, retrieves the first pointer from each argument, resets errno via __errno_location, and calls strcoll to compare the strings.",
            "Returns either the numeric comparison result or the strcoll result."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0xc and 0xd",
            "Structure layout of the arguments beyond the examined fields"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a460",
      "original_name": "sub_40a460",
      "final_name": "ai_compare_struct_entries",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40a3f0",
          "name": "ai_struct_compare_by_fields_and_name",
          "original_name": "sub_40a3f0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40a3f0"
      ],
      "snippets": {
        "asm": "  0x40a460  endbr64 \n  0x40a464  mov     eax, dword [rdi+0xa8]\n  0x40a46a  mov     ecx, dword [rsi+0xa8]\n  0x40a470  cmp     eax, 0x9\n  0x40a473  sete    dl\n  0x40a476  cmp     eax, 0x3\n  0x40a479  sete    al\n  0x40a47c  or      edx, eax\n  0x40a47e  cmp     ecx, 0x3\n  0x40a481  je      0x40a4b0\n  0x40a4b0  mov     eax, 0x1\n  0x40a4b5  test    dl, dl\n  0x40a4b7  je      0x40a4c0\n  0x40a483  cmp     ecx, 0x9\n  0x40a486  je      0x40a4b0\n  0x40a4c0  mov     edx, dword [rdi+0xac]\n  0x40a4c6  xor     ecx, ecx  {0x0}\n  0x40a4c8  and     edx, 0xf000\n  0x40a4ce  cmp     edx, 0x4000\n  0x40a4d4  sete    cl\n  0x40a4d7  sub     eax, ecx\n  0x40a4d9  jne     0x40a4ab\n  0x40a4b9  jmp     sub_40a3f0\n  0x40a488  mov     eax, dword [rsi+0xac]\n  0x40a48e  mov     ecx, 0x1\n  0x40a493  and     eax, 0xf000\n  0x40a498  cmp     eax, 0x4000\n  0x40a49d  sete    al\n  0x40a4a0  movzx   eax, al\n  0x40a4a3  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40a4d4:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40a4d4\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40a3f0(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40a4d4:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40a4d4;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40a3f0(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_entries",
          "confidence": 0.78,
          "rationale": "The function checks type fields (values 3 or 9) and flag bits (0xf000 mask) of two structures, then delegates to a secondary comparator that compares numeric fields and finally performs a string collation. This pattern matches a custom comparator used for ordering or matching entries.",
          "evidence_refs": [
            "constants:0xf000",
            "call:0x40a3f0"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_entry_compare"
          ]
        },
        "explain": {
          "summary": "sub_40a460 compares two objects (likely file entries) by checking a type field and a mode flag, returning an ordering based on those checks, and otherwise delegates to sub_40a3f0 which compares timestamps and finally falls back to lexical name comparison via strcoll.",
          "details": [
            "It reads a byte at offset 0x15 of each argument and treats values 3 or 9 as special type markers, setting a flag rdx_1.",
            "If the second argument has type 3 or 9, it sets a default comparison result of 1; otherwise it extracts the high bits of a 32bit field at offset 0xac, masks with 0xf000 and compares against 0x4000 (directory flag).",
            "When the type flag is not set, it compares the derived boolean flags of both arguments and returns their difference if they differ.",
            "If the type checks pass, it tailcalls sub_40a3f0 which compares fields at offsets 0xc and 0xd (likely timestamps) and finally uses strcoll to compare string names.",
            "The function returns early with a nonzero integer when the type or mode flags differ, otherwise it falls back to the more detailed comparison."
          ],
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a3f0",
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "unknowns": [
            "Exact semantics of the values 3 and 9 at offset 0x15",
            "Precise structure layout of the arguments beyond the observed offsets"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a4e0",
      "original_name": "sub_40a4e0",
      "final_name": "ai_struct_comparator",
      "score": 28.4,
      "bb_count": 3,
      "insn_est": 33,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a4e0  endbr64 \n  0x40a4e4  mov     rax, qword [rdi+0x60]\n  0x40a4e8  xor     edx, edx  {0x0}\n  0x40a4ea  cmp     qword [rsi+0x60], rax\n  0x40a4ee  setg    al\n  0x40a4f1  setl    dl\n  0x40a4f4  movzx   eax, al\n  0x40a4f7  sub     edx, eax\n  0x40a4f9  mov     rax, qword [rdi+0x68]\n  0x40a4fd  cmp     qword [rsi+0x68], rax\n  0x40a501  setl    al\n  0x40a504  setg    cl\n  0x40a507  movzx   eax, al\n  0x40a50a  movzx   ecx, cl\n  0x40a50d  sub     eax, ecx\n  0x40a50f  lea     eax, [rax+rdx*2]\n  0x40a512  test    eax, eax\n  0x40a514  jne     0x40a540\n  0x40a540  retn     {__return_addr}\n  0x40a516  push    rbp {__saved_rbp}\n  0x40a517  mov     rbp, rsp {__saved_rbp}\n  0x40a51a  push    r12 {__saved_r12}\n  0x40a51c  push    rbx {__saved_rbx}\n  0x40a51d  mov     rbx, qword [rsi]\n  0x40a520  mov     r12, qword [rdi]\n  0x40a523  call    __errno_location\n  0x40a528  mov     rsi, r12\n  0x40a52b  mov     rdi, rbx\n  0x40a52e  mov     dword [rax], 0x0\n  0x40a534  pop     rbx {__saved_rbx}\n  ... (94 bytes total, truncated)",
        "hlil": "int64_t rax = arg1[0xc]\nint64_t temp0 = arg2[0xc]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg1[0xd]\nint64_t temp1 = arg2[0xd]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nchar* rbx = *arg2\nchar* r12 = *arg1\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[0xc];\n    int64_t temp0 = arg2[0xc];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg1[0xd];\n    int64_t temp1 = arg2[0xd];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    char* rbx = *(uint64_t*)arg2;\n    char* r12 = *(uint64_t*)arg1;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_comparator",
          "confidence": 0.86,
          "rationale": "Function compares two structures by numeric fields at offsets 0xc and 0xd, then falls back to locale-aware string comparison using strcoll, typical of a custom sort comparator.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "tags": [],
          "alt_names": [
            "ai_entry_compare",
            "ai_custom_sort"
          ]
        },
        "explain": {
          "summary": "sub_40a4e0 implements a comparator that first orders two objects by numeric fields at offsets 0xc and 0xd, returning a nonzero ordering value if they differ. If those fields are equal, it clears errno and falls back to a localeaware string comparison of the pointers stored at the start of each object using strcoll.",
          "details": [
            "Loads 64bit values from arg1[0xc] and arg2[0xc] and computes a signed comparison, contributing to the result.",
            "Loads 64bit values from arg1[0xd] and arg2[0xd] and computes a second signed comparison, combined with the first using a shiftandadd scheme to produce -1, 0, or 1.",
            "If the combined numeric comparison yields zero, the function retrieves the first pointer from each structure (arg1[0] and arg2[0]), resets errno via __errno_location, and returns the result of strcoll on those strings.",
            "The function is likely used as a custom comparison routine for sorting or searching structures that contain a primary numeric key and a secondary string key."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0xc and 0xd (e.g., timestamp, version, etc.)",
            "Structure layout beyond the examined fields"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a550",
      "original_name": "sub_40a550",
      "final_name": "ai_compare_entries_by_type_and_flags",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40a4e0",
          "name": "ai_struct_comparator",
          "original_name": "sub_40a4e0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40a4e0"
      ],
      "snippets": {
        "asm": "  0x40a550  endbr64 \n  0x40a554  mov     eax, dword [rdi+0xa8]\n  0x40a55a  mov     ecx, dword [rsi+0xa8]\n  0x40a560  cmp     eax, 0x9\n  0x40a563  sete    dl\n  0x40a566  cmp     eax, 0x3\n  0x40a569  sete    al\n  0x40a56c  or      edx, eax\n  0x40a56e  cmp     ecx, 0x3\n  0x40a571  je      0x40a5a0\n  0x40a5a0  mov     eax, 0x1\n  0x40a5a5  test    dl, dl\n  0x40a5a7  je      0x40a5b0\n  0x40a573  cmp     ecx, 0x9\n  0x40a576  je      0x40a5a0\n  0x40a5b0  mov     edx, dword [rdi+0xac]\n  0x40a5b6  xor     ecx, ecx  {0x0}\n  0x40a5b8  and     edx, 0xf000\n  0x40a5be  cmp     edx, 0x4000\n  0x40a5c4  sete    cl\n  0x40a5c7  sub     eax, ecx\n  0x40a5c9  jne     0x40a59b\n  0x40a5a9  jmp     sub_40a4e0\n  0x40a578  mov     eax, dword [rsi+0xac]\n  0x40a57e  mov     ecx, 0x1\n  0x40a583  and     eax, 0xf000\n  0x40a588  cmp     eax, 0x4000\n  0x40a58d  sete    al\n  0x40a590  movzx   eax, al\n  0x40a593  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40a5c4:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40a5c4\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40a4e0(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40a5c4:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40a5c4;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40a4e0(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_entries_by_type_and_flags",
          "confidence": 0.86,
          "rationale": "The function checks type fields and flag bits of two structures, returns ordering differences, and delegates to a detailed comparator, indicating it is a sorting/comparison routine.",
          "evidence_refs": [
            "call:0x40a4e0",
            "constants:0x4000",
            "constants:0xf000"
          ],
          "tags": [],
          "alt_names": [
            "ai_entry_comparator",
            "ai_sort_key_compare"
          ]
        },
        "explain": {
          "summary": "sub_40a550 performs preliminary checks on two structures' type fields and a masked flag before delegating to sub_40a4e0 for detailed comparison, returning a numeric difference when the checks fail.",
          "details": [
            "It reads a field at offset 0x15 from both arguments and checks if the values are 3 or 9, setting a combined flag rdx_1.",
            "It examines a 32bit value at offset 0xac, masks it with 0xf000, and compares the result to 0x4000 to derive a boolean flag.",
            "If the type checks succeed and the flag conditions match, it tailcalls sub_40a4e0; otherwise it returns the difference of the derived flags.",
            "sub_40a4e0 then compares additional numeric fields and finally performs a localeaware string comparison via strcoll."
          ],
          "evidence_refs": [
            "call:0x40a4e0",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantics of the structures pointed to by arg1 and arg2",
            "Purpose of the type codes 3 and 9",
            "Reason for the specific flag mask 0xf000"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a5d0",
      "original_name": "sub_40a5d0",
      "final_name": "ai_struct_compare_by_fields_and_name",
      "score": 28.4,
      "bb_count": 3,
      "insn_est": 33,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a5d0  endbr64 \n  0x40a5d4  mov     rax, qword [rsi+0x70]\n  0x40a5d8  xor     edx, edx  {0x0}\n  0x40a5da  cmp     qword [rdi+0x70], rax\n  0x40a5de  setg    al\n  0x40a5e1  setl    dl\n  0x40a5e4  movzx   eax, al\n  0x40a5e7  sub     edx, eax\n  0x40a5e9  mov     rax, qword [rsi+0x78]\n  0x40a5ed  cmp     qword [rdi+0x78], rax\n  0x40a5f1  setl    al\n  0x40a5f4  setg    cl\n  0x40a5f7  movzx   eax, al\n  0x40a5fa  movzx   ecx, cl\n  0x40a5fd  sub     eax, ecx\n  0x40a5ff  lea     eax, [rax+rdx*2]\n  0x40a602  test    eax, eax\n  0x40a604  jne     0x40a630\n  0x40a630  retn     {__return_addr}\n  0x40a606  push    rbp {__saved_rbp}\n  0x40a607  mov     rbp, rsp {__saved_rbp}\n  0x40a60a  push    r12 {__saved_r12}\n  0x40a60c  push    rbx {__saved_rbx}\n  0x40a60d  mov     rbx, qword [rdi]\n  0x40a610  mov     r12, qword [rsi]\n  0x40a613  call    __errno_location\n  0x40a618  mov     rsi, r12\n  0x40a61b  mov     rdi, rbx\n  0x40a61e  mov     dword [rax], 0x0\n  0x40a624  pop     rbx {__saved_rbx}\n  ... (94 bytes total, truncated)",
        "hlil": "int64_t rax = arg2[0xe]\nint64_t temp0 = arg1[0xe]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg2[0xf]\nint64_t temp1 = arg1[0xf]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nchar* rbx = *arg1\nchar* r12 = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[0xe];\n    int64_t temp0 = arg1[0xe];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg2[0xf];\n    int64_t temp1 = arg1[0xf];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    char* rbx = *(uint64_t*)arg1;\n    char* r12 = *(uint64_t*)arg2;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_by_fields_and_name",
          "confidence": 0.86,
          "rationale": "The function compares two structures using numeric fields at offsets 0xe/0xf, then falls back to locale-aware string comparison via strcoll, indicating a custom comparator used for sorting or ordering objects.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "tags": [],
          "alt_names": [
            "ai_custom_comparator",
            "ai_sort_key_compare"
          ]
        },
        "explain": {
          "summary": "The function implements a three-way comparison of two objects: it first compares integer fields at offsets 0xe and 0xf, returns a non-zero ordering if they differ, and if they are equal it falls back to a locale-aware string comparison of the pointers stored at the objects' start, clearing errno before calling strcoll.",
          "details": [
            "Loads int64 values from arg1[0xe] and arg2[0xe] and computes a signed comparison result using both < and > flags.",
            "Repeats the comparison for int64 values at offset 0xf, combines the two comparison outcomes into a single integer result.",
            "If the combined result is zero, retrieves the first pointer from each structure, resets *__errno_location() to 0, and returns the result of strcoll on the two strings."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0xe and 0xf in the structures",
            "The broader context in which this comparator is used (e.g., sorting algorithm or data structure)"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a640",
      "original_name": "sub_40a640",
      "final_name": "ai_compare_file_entry",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40a5d0",
          "name": "ai_struct_compare_by_fields_and_name",
          "original_name": "sub_40a5d0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40a5d0"
      ],
      "snippets": {
        "asm": "  0x40a640  endbr64 \n  0x40a644  mov     eax, dword [rdi+0xa8]\n  0x40a64a  mov     ecx, dword [rsi+0xa8]\n  0x40a650  cmp     eax, 0x9\n  0x40a653  sete    dl\n  0x40a656  cmp     eax, 0x3\n  0x40a659  sete    al\n  0x40a65c  or      edx, eax\n  0x40a65e  cmp     ecx, 0x3\n  0x40a661  je      0x40a690\n  0x40a690  mov     eax, 0x1\n  0x40a695  test    dl, dl\n  0x40a697  je      0x40a6a0\n  0x40a663  cmp     ecx, 0x9\n  0x40a666  je      0x40a690\n  0x40a6a0  mov     edx, dword [rdi+0xac]\n  0x40a6a6  xor     ecx, ecx  {0x0}\n  0x40a6a8  and     edx, 0xf000\n  0x40a6ae  cmp     edx, 0x4000\n  0x40a6b4  sete    cl\n  0x40a6b7  sub     eax, ecx\n  0x40a6b9  jne     0x40a68b\n  0x40a699  jmp     sub_40a5d0\n  0x40a668  mov     eax, dword [rsi+0xac]\n  0x40a66e  mov     ecx, 0x1\n  0x40a673  and     eax, 0xf000\n  0x40a678  cmp     eax, 0x4000\n  0x40a67d  sete    al\n  0x40a680  movzx   eax, al\n  0x40a683  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40a6b4:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40a6b4\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40a5d0(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40a6b4:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40a6b4;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40a5d0(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_file_entry",
          "confidence": 0.86,
          "rationale": "The function compares two structures based on type fields, flag masks (0x4000), timestamps, and finally string names, acting as a comparator for file or directory entries.",
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a5d0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_entry_compare",
            "ai_file_record_compare"
          ]
        },
        "explain": {
          "summary": "sub_40a640 performs preliminary type and flag checks on two objects before delegating to sub_40a5d0 for deeper comparison. It examines a field at offset 0x15 for values 3 or 9, and a masked flag at offset 0xac for the pattern 0x4000, returning a difference if they disagree. If the checks pass, it tailcalls sub_40a5d0 which compares additional numeric fields and finally performs a localeaware string comparison.",
          "details": [
            "Reads arg1[0x15] and arg2[0x15] to detect values 3 or 9, setting a combined flag rdx_1.",
            "If either object has those values, sets a baseline comparison result (rax_3 = 1).",
            "When the flag rdx_1 is false, extracts the highorder bits (0xf000 mask) of a 32bit field at offset 0xac and checks for equality with 0x4000, returning the boolean difference if mismatched.",
            "If the flag is true but the masked check on arg2 fails, returns the difference between the masked result and 1.",
            "When all preliminary checks succeed, it tailcalls sub_40a5d0 to compare further numeric fields and then calls strcoll on the objects' string pointers."
          ],
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a5d0"
          ],
          "unknowns": [
            "Exact semantic meaning of the structures pointed to by arg1 and arg2",
            "Purpose of the values 3 and 9 in the context of the application"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40a6c0",
      "original_name": "sub_40a6c0",
      "final_name": "ai_struct_compare_by_fields_and_name",
      "score": 28.4,
      "bb_count": 3,
      "insn_est": 33,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a6c0  endbr64 \n  0x40a6c4  mov     rax, qword [rdi+0x70]\n  0x40a6c8  xor     edx, edx  {0x0}\n  0x40a6ca  cmp     qword [rsi+0x70], rax\n  0x40a6ce  setg    al\n  0x40a6d1  setl    dl\n  0x40a6d4  movzx   eax, al\n  0x40a6d7  sub     edx, eax\n  0x40a6d9  mov     rax, qword [rdi+0x78]\n  0x40a6dd  cmp     qword [rsi+0x78], rax\n  0x40a6e1  setl    al\n  0x40a6e4  setg    cl\n  0x40a6e7  movzx   eax, al\n  0x40a6ea  movzx   ecx, cl\n  0x40a6ed  sub     eax, ecx\n  0x40a6ef  lea     eax, [rax+rdx*2]\n  0x40a6f2  test    eax, eax\n  0x40a6f4  jne     0x40a720\n  0x40a720  retn     {__return_addr}\n  0x40a6f6  push    rbp {__saved_rbp}\n  0x40a6f7  mov     rbp, rsp {__saved_rbp}\n  0x40a6fa  push    r12 {__saved_r12}\n  0x40a6fc  push    rbx {__saved_rbx}\n  0x40a6fd  mov     rbx, qword [rsi]\n  0x40a700  mov     r12, qword [rdi]\n  0x40a703  call    __errno_location\n  0x40a708  mov     rsi, r12\n  0x40a70b  mov     rdi, rbx\n  0x40a70e  mov     dword [rax], 0x0\n  0x40a714  pop     rbx {__saved_rbx}\n  ... (94 bytes total, truncated)",
        "hlil": "int64_t rax = arg1[0xe]\nint64_t temp0 = arg2[0xe]\nbool cond:0 = temp0 s< rax\nrax.b = temp0 s> rax\nint32_t rdx\nrdx.b = cond:0\nint64_t rax_2 = arg1[0xf]\nint64_t temp1 = arg2[0xf]\nbool cond:1 = temp1 s> rax_2\nrax_2.b = temp1 s< rax_2\nuint32_t result = zx.d(rax_2.b) - zx.d(cond:1) + ((rdx - zx.d(rax.b)) << 1)\nif (result != 0)\nreturn result\nchar* rbx = *arg2\nchar* r12 = *arg1\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[0xe];\n    int64_t temp0 = arg2[0xe];\n    bool cond:0 = temp0 < rax;\n    (uint8_t)rax = temp0 > rax;\n    int32_t rdx;\n    (uint8_t)rdx = cond:0;\n    int64_t rax_2 = arg1[0xf];\n    int64_t temp1 = arg2[0xf];\n    bool cond:1 = temp1 > rax_2;\n    (uint8_t)rax_2 = temp1 < rax_2;\n    uint32_t result =\n        (uint32_t)(uint8_t)rax_2 - (uint32_t)cond:1 + ((rdx - (uint32_t)(uint8_t)rax) << 1);\n    \n    if (result)\n        return result;\n    \n    char* rbx = *(uint64_t*)arg2;\n    char* r12 = *(uint64_t*)arg1;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_struct_compare_by_fields_and_name",
          "confidence": 0.78,
          "rationale": "The function compares two structures by numeric fields at offsets 0xe/0xf and falls back to locale-aware string comparison via strcoll, indicating a custom comparator used for sorting entries.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_custom_sort_comparator",
            "ai_entry_compare"
          ]
        },
        "explain": {
          "summary": "sub_40a6c0 implements a comparator that first orders two objects by comparing 64bit fields at offsets 0xE and 0xF. If those fields differ, it returns a signed integer indicating the ordering. When the fields are equal, it falls back to a localeaware string comparison of the pointers stored at the start of each object, after clearing errno.",
          "details": [
            "Loads arg1[0xE] and arg2[0xE] and computes a signed result based on < and > comparisons.",
            "Loads arg1[0xF] and arg2[0xF] and combines the two comparison results into a single integer using bitwise operations.",
            "If the combined result is nonzero, it is returned directly.",
            "If the result is zero, the function retrieves the first pointer from each structure, resets errno to 0, and calls strcoll to compare the referenced strings."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the structures and the fields at offsets 0xE/0xF",
            "Why the specific bitwise combination of comparison flags is used"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40a730",
      "original_name": "sub_40a730",
      "final_name": "ai_compare_struct_by_type_and_flags",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40a6c0",
          "name": "ai_struct_compare_by_fields_and_name",
          "original_name": "sub_40a6c0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40a6c0"
      ],
      "snippets": {
        "asm": "  0x40a730  endbr64 \n  0x40a734  mov     eax, dword [rdi+0xa8]\n  0x40a73a  mov     ecx, dword [rsi+0xa8]\n  0x40a740  cmp     eax, 0x9\n  0x40a743  sete    dl\n  0x40a746  cmp     eax, 0x3\n  0x40a749  sete    al\n  0x40a74c  or      edx, eax\n  0x40a74e  cmp     ecx, 0x3\n  0x40a751  je      0x40a780\n  0x40a780  mov     eax, 0x1\n  0x40a785  test    dl, dl\n  0x40a787  je      0x40a790\n  0x40a753  cmp     ecx, 0x9\n  0x40a756  je      0x40a780\n  0x40a790  mov     edx, dword [rdi+0xac]\n  0x40a796  xor     ecx, ecx  {0x0}\n  0x40a798  and     edx, 0xf000\n  0x40a79e  cmp     edx, 0x4000\n  0x40a7a4  sete    cl\n  0x40a7a7  sub     eax, ecx\n  0x40a7a9  jne     0x40a77b\n  0x40a789  jmp     sub_40a6c0\n  0x40a758  mov     eax, dword [rsi+0xac]\n  0x40a75e  mov     ecx, 0x1\n  0x40a763  and     eax, 0xf000\n  0x40a768  cmp     eax, 0x4000\n  0x40a76d  sete    al\n  0x40a770  movzx   eax, al\n  0x40a773  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40a7a4:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40a7a4\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40a6c0(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40a7a4:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40a7a4;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40a6c0(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_flags",
          "confidence": 0.86,
          "rationale": "The function examines type fields (offset 0x15) and flag bits (mask 0xf000) of two structures, returns a difference or delegates to sub_40a6c0 which performs further numeric and string comparison, indicating a comparator for sorting or ordering objects.",
          "evidence_refs": [
            "call:0x40a6c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_sort_key_function"
          ]
        },
        "explain": {
          "summary": "sub_40a730 implements a conditional comparator that first checks specific type codes (3 or 9) in two structures, then evaluates a masked flag at offset 0xac, returning a difference if they disagree; otherwise it forwards the comparison to sub_40a6c0 for further ordering logic.",
          "details": [
            "Reads a byte at offset 0x15 from both arguments and sets flags when the value equals 3 or 9.",
            "If either argument has a type of 3 or 9, it checks whether the high nibble of the dword at offset 0xac matches 0x4000, and returns the boolean difference if mismatched.",
            "When the type codes are not 3 or 9, it performs the same mask check on the second argument and returns a difference if needed.",
            "If all preliminary checks pass, it tailcalls sub_40a6c0, which performs further numeric comparisons and finally a localeaware string comparison (strcoll)."
          ],
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40a6c0"
          ],
          "unknowns": [
            "Exact semantic meaning of the values at offset 0x15 (type identifiers).",
            "Purpose of the mask 0xf000/0x4000 on the field at offset 0xac (likely attribute flags).",
            "Higherlevel context of the structures being compared (e.g., file entries, UI objects)."
          ],
          "confidence": 0.81
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a7b0",
      "original_name": "sub_40a7b0",
      "final_name": "ai_compare_struct_by_numeric_and_string",
      "score": 24.7,
      "bb_count": 3,
      "insn_est": 24,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a7b0  endbr64 \n  0x40a7b4  mov     rax, qword [rsi+0x48]\n  0x40a7b8  cmp     qword [rdi+0x48], rax\n  0x40a7bc  setl    al\n  0x40a7bf  setg    dl\n  0x40a7c2  movzx   eax, al\n  0x40a7c5  movzx   edx, dl\n  0x40a7c8  sub     eax, edx\n  0x40a7ca  jne     0x40a7f8\n  0x40a7f8  retn     {__return_addr}\n  0x40a7cc  push    rbp {__saved_rbp}\n  0x40a7cd  mov     rbp, rsp {__saved_rbp}\n  0x40a7d0  push    r12 {__saved_r12}\n  0x40a7d2  push    rbx {__saved_rbx}\n  0x40a7d3  mov     rbx, qword [rdi]\n  0x40a7d6  mov     r12, qword [rsi]\n  0x40a7d9  call    __errno_location\n  0x40a7de  mov     rsi, r12\n  0x40a7e1  mov     rdi, rbx\n  0x40a7e4  mov     dword [rax], 0x0\n  0x40a7ea  pop     rbx {__saved_rbx}\n  0x40a7eb  pop     r12 {__saved_r12}\n  0x40a7ed  pop     rbp {__saved_rbp}\n  0x40a7ee  jmp     strcoll",
        "hlil": "int64_t rax = arg2[9]\nint64_t temp0 = arg1[9]\nbool cond:0 = temp0 s> rax\nrax.b = temp0 s< rax\nuint32_t rax_1 = zx.d(rax.b)\nuint32_t rdx_1 = zx.d(cond:0)\nif (rax_1 != rdx_1)\nreturn zx.q(rax_1 - rdx_1)\nchar* rbx = *arg1\nchar* r12 = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg2[9];\n    int64_t temp0 = arg1[9];\n    bool cond:0 = temp0 > rax;\n    (uint8_t)rax = temp0 < rax;\n    uint32_t rax_1 = (uint32_t)(uint8_t)rax;\n    uint32_t rdx_1 = (uint32_t)cond:0;\n    \n    if (rax_1 != rdx_1)\n        return (uint64_t)(rax_1 - rdx_1);\n    \n    char* rbx = *(uint64_t*)arg1;\n    char* r12 = *(uint64_t*)arg2;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_numeric_and_string",
          "confidence": 0.86,
          "rationale": "The function compares two objects: first by a numeric field at offset 9, returning -1/0/1, and if equal, falls back to locale-aware string comparison using strcoll, resetting errno before the call.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_numeric_string_compare"
          ]
        },
        "explain": {
          "summary": "The function performs a two-tier comparison of two objects. It first compares a 64-bit field at offset 9 (index 9) of each argument, returning -1, 0, or 1 based on that numeric ordering. If the numeric fields are equal, it resets errno and delegates to the locale-aware string comparison function strcoll on the pointers stored at the start of each object.",
          "details": [
            "Reads int64_t values from arg1[9] and arg2[9] and determines if one is greater, less, or equal.",
            "If the numeric comparison yields a non-zero ordering, returns the sign of the difference (1 for less, -1 for greater).",
            "When the numeric fields are equal, loads the first pointer from each argument, clears errno via __errno_location, and calls strcoll to compare the referenced strings."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact structure layout of the arguments beyond the accessed fields",
            "Purpose of the numeric field at offset 9 in the broader program context"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a800",
      "original_name": "sub_40a800",
      "final_name": "ai_compare_by_numeric_then_string",
      "score": 24.7,
      "bb_count": 3,
      "insn_est": 24,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a800  endbr64 \n  0x40a804  mov     rax, qword [rdi+0x48]\n  0x40a808  cmp     qword [rsi+0x48], rax\n  0x40a80c  setl    al\n  0x40a80f  setg    dl\n  0x40a812  movzx   eax, al\n  0x40a815  movzx   edx, dl\n  0x40a818  sub     eax, edx\n  0x40a81a  jne     0x40a848\n  0x40a848  retn     {__return_addr}\n  0x40a81c  push    rbp {__saved_rbp}\n  0x40a81d  mov     rbp, rsp {__saved_rbp}\n  0x40a820  push    r12 {__saved_r12}\n  0x40a822  push    rbx {__saved_rbx}\n  0x40a823  mov     rbx, qword [rsi]\n  0x40a826  mov     r12, qword [rdi]\n  0x40a829  call    __errno_location\n  0x40a82e  mov     rsi, r12\n  0x40a831  mov     rdi, rbx\n  0x40a834  mov     dword [rax], 0x0\n  0x40a83a  pop     rbx {__saved_rbx}\n  0x40a83b  pop     r12 {__saved_r12}\n  0x40a83d  pop     rbp {__saved_rbp}\n  0x40a83e  jmp     strcoll",
        "hlil": "int64_t rax = arg1[9]\nint64_t temp0 = arg2[9]\nbool cond:0 = temp0 s> rax\nrax.b = temp0 s< rax\nuint32_t rax_1 = zx.d(rax.b)\nuint32_t rdx_1 = zx.d(cond:0)\nif (rax_1 != rdx_1)\nreturn zx.q(rax_1 - rdx_1)\nchar* rbx = *arg2\nchar* r12 = *arg1\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int64_t rax = arg1[9];\n    int64_t temp0 = arg2[9];\n    bool cond:0 = temp0 > rax;\n    (uint8_t)rax = temp0 < rax;\n    uint32_t rax_1 = (uint32_t)(uint8_t)rax;\n    uint32_t rdx_1 = (uint32_t)cond:0;\n    \n    if (rax_1 != rdx_1)\n        return (uint64_t)(rax_1 - rdx_1);\n    \n    char* rbx = *(uint64_t*)arg2;\n    char* r12 = *(uint64_t*)arg1;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_by_numeric_then_string",
          "confidence": 0.93,
          "rationale": "The function compares two structures: first by a numeric field at offset 9, returning ordering if different; if equal, it falls back to locale-aware string comparison using strcoll. This behavior matches a comparator used for sorting.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_compare_by_priority_and_name"
          ]
        },
        "explain": {
          "summary": "The function implements a twostage comparator: it first compares a 64bit integer located at index 9 of each argument and returns -1, 0, or 1 based on that ordering; if the integers are equal it falls back to a localeaware string comparison of the pointers stored at index 0 using strcoll.",
          "details": [
            "Reads int64 values from arg1[9] and arg2[9] and determines which is greater, returning -1 or 1 when they differ.",
            "When the integer fields are equal, loads the first element of each argument as a char* and calls strcoll after clearing errno.",
            "Uses __errno_location to reset errno before invoking strcoll."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the structures passed in (what the integer at index 9 represents)",
            "Why errno is cleared before strcoll (potential error handling context)"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a850",
      "original_name": "sub_40a850",
      "final_name": "ai_compare_structs_by_type_and_name",
      "score": 45.4,
      "bb_count": 10,
      "insn_est": 58,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a850  endbr64 \n  0x40a854  mov     rdx, rdi\n  0x40a857  mov     rcx, rsi\n  0x40a85a  mov     edi, dword [rsi+0xa8]\n  0x40a860  mov     eax, dword [rdx+0xa8]\n  0x40a866  cmp     eax, 0x9\n  0x40a869  sete    sil\n  0x40a86d  cmp     eax, 0x3\n  0x40a870  sete    al\n  0x40a873  or      esi, eax\n  0x40a875  cmp     edi, 0x3\n  0x40a878  je      0x40a8a8\n  0x40a8a8  mov     eax, 0x1\n  0x40a8ad  test    sil, sil\n  0x40a8b0  je      0x40a8f8\n  0x40a87a  cmp     edi, 0x9\n  0x40a87d  je      0x40a8a8\n  0x40a8f8  mov     esi, dword [rdx+0xac]\n  0x40a8fe  xor     edi, edi  {0x0}\n  0x40a900  and     esi, 0xf000\n  0x40a906  cmp     esi, 0x4000\n  0x40a90c  sete    dil\n  0x40a910  sub     eax, edi\n  0x40a912  jne     0x40a8a3\n  0x40a8b2  mov     rax, qword [rcx+0x48]\n  0x40a8b6  cmp     qword [rdx+0x48], rax\n  0x40a8ba  setl    al\n  0x40a8bd  setg    sil\n  0x40a8c1  movzx   eax, al\n  0x40a8c4  movzx   esi, sil\n  ... (189 bytes total, truncated)",
        "hlil": "int64_t* rcx = arg2\nint32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\narg2.b = rax == 9\nrax.b = rax == 3\nint32_t rsi = arg2.d | rax\nuint64_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rsi.b == 0)\nlabel_40a90c:\nint32_t rdi_3\nrdi_3.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = zx.q(rax_3 - rdi_3)\nif (rax_3 == rdi_3)\ngoto label_40a8b2\nlabel_40a8b2:\nint64_t rax_4 = rcx[9]\nint64_t temp1_1 = arg1[9]\nbool cond:0_1 = temp1_1 s> rax_4\nrax_4.b = temp1_1 s< rax_4\nrsi.b = cond:0_1\nuint32_t rax_5 = zx.d(rax_4.b)\nuint32_t rsi_1 = zx.d(rsi.b)\nresult = zx.q(rax_5 - rsi_1)\nif (rax_5 == rsi_1)\nchar* r12 = *rcx\nchar* rbx = *arg1\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall\nint32_t rax_2\nrax_2.b = (*(rcx + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rsi.b == 0)\ngoto label_40a90c\nresult = zx.q(rax_3 - 1)\nif (rax_3 == 1)\ngoto label_40a8b2\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int64_t* rcx = arg2;\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    (uint8_t)arg2 = rax == 9;\n    (uint8_t)rax = rax == 3;\n    int32_t rsi = (uint32_t)arg2 | rax;\n    uint64_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!(uint8_t)rsi)\n        {\n        label_40a90c:\n            int32_t rdi_3;\n            (uint8_t)rdi_3 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = (uint64_t)(rax_3 - rdi_3);\n            \n            if (rax_3 == rdi_3)\n                goto label_40a8b2;\n        }\n        else\n        {\n        label_40a8b2:\n            int64_t rax_4 = rcx[9];\n            int64_t temp1_1 = arg1[9];\n            bool cond:0_1 = temp1_1 > rax_4;\n            (uint8_t)rax_4 = temp1_1 < rax_4;\n            (uint8_t)rsi = cond:0_1;\n            uint32_t rax_5 = (uint32_t)(uint8_t)rax_4;\n            uint32_t rsi_1 = (uint32_t)(uint8_t)rsi;\n            result = (uint64_t)(rax_5 - rsi_1);\n            \n            if (rax_5 == rsi_1)\n            {\n                char* r12 = *(uint64_t*)rcx;\n                char* rbx = *(uint64_t*)arg1;\n                *(uint32_t*)__errno_location() = 0;\n                /* tailcall */\n                return strcoll(rbx, r12);\n            }\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)rcx + 0xac) & 0xf000) == 0x4000;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_structs_by_type_and_name",
          "confidence": 0.78,
          "rationale": "The function checks type fields, flag bits, compares numeric fields, and finally calls strcoll on string pointers, indicating it implements a comparator for sorting structures based on type, numeric value, and locale-aware string comparison.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_struct_comparator",
            "ai_sort_by_type_name"
          ]
        },
        "explain": {
          "summary": "The function implements a multistage comparison between two data structures pointed to by arg1 and arg2. It first checks a type field at offset 0x15 for values 3 or 9, then examines a flag in the 0xac offset masked with 0xf000, followed by a numeric comparison of the value at index 9. If those checks deem the objects equal, it clears errno and performs a localeaware string comparison via strcoll on the pointers stored at the structures' base addresses.",
          "details": [
            "If arg1[0x15] or arg2[0x15] equals 3 or 9, a flag (rax_3) is set to 1, otherwise the function skips further comparison.",
            "When both objects have the same flag condition, it checks whether the highorder bits (0xf000) of the dword at offset 0xac equal 0x4000 for each object, influencing the result.",
            "It then compares the 64bit values at index 9 of each structure, returning the difference unless they are equal.",
            "When all prior fields match, it resets *__errno_location()* to 0 and calls strcoll on the strings referenced by the first pointer of each structure, returning that result."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantic meaning of the type codes (3, 9) and the flag mask 0xf000/0x4000",
            "Purpose of the numeric field at index 9 (e.g., timestamp, size)",
            "Why rax_3 is forced to 1 regardless of specific type"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40a920",
      "original_name": "sub_40a920",
      "final_name": "ai_compare_struct_by_type_and_timestamp",
      "score": 45.1,
      "bb_count": 10,
      "insn_est": 57,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a920  endbr64 \n  0x40a924  mov     rdx, rdi\n  0x40a927  mov     edi, dword [rsi+0xa8]\n  0x40a92d  mov     eax, dword [rdx+0xa8]\n  0x40a933  cmp     eax, 0x9\n  0x40a936  sete    cl\n  0x40a939  cmp     eax, 0x3\n  0x40a93c  sete    al\n  0x40a93f  or      ecx, eax\n  0x40a941  cmp     edi, 0x3\n  0x40a944  je      0x40a970\n  0x40a970  mov     eax, 0x1\n  0x40a975  test    cl, cl\n  0x40a977  je      0x40a9c0\n  0x40a946  cmp     edi, 0x9\n  0x40a949  je      0x40a970\n  0x40a9c0  mov     ecx, dword [rdx+0xac]\n  0x40a9c6  xor     edi, edi  {0x0}\n  0x40a9c8  and     ecx, 0xf000\n  0x40a9ce  cmp     ecx, 0x4000\n  0x40a9d4  sete    dil\n  0x40a9d8  sub     eax, edi\n  0x40a9da  jne     0x40a96e\n  0x40a979  mov     rax, qword [rdx+0x48]\n  0x40a97d  cmp     qword [rsi+0x48], rax\n  0x40a981  setl    al\n  0x40a984  setg    cl\n  0x40a987  movzx   eax, al\n  0x40a98a  movzx   ecx, cl\n  0x40a98d  sub     eax, ecx\n  ... (181 bytes total, truncated)",
        "hlil": "int32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\nint32_t rcx\nrcx.b = rax == 9\nrax.b = rax == 3\nint32_t rcx_1 = rcx | rax\nuint64_t result\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rcx_1.b == 0)\nlabel_40a9d4:\nint32_t rdi_3\nrdi_3.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nresult = zx.q(rax_3 - rdi_3)\nif (rax_3 == rdi_3)\ngoto label_40a979\nlabel_40a979:\nint64_t rax_4 = arg1[9]\nint64_t temp1_1 = arg2[9]\nbool cond:0_1 = temp1_1 s> rax_4\nrax_4.b = temp1_1 s< rax_4\nrcx_1.b = cond:0_1\nuint32_t rax_5 = zx.d(rax_4.b)\nuint32_t rcx_2 = zx.d(rcx_1.b)\nresult = zx.q(rax_5 - rcx_2)\nif (rax_5 == rcx_2)\nchar* r12 = *arg1\nchar* rbx = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rcx_1.b == 0)\ngoto label_40a9d4\nresult = zx.q(rax_3 - 1)\nif (rax_3 == 1)\ngoto label_40a979\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    int32_t rcx;\n    (uint8_t)rcx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    int32_t rcx_1 = rcx | rax;\n    uint64_t result;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!(uint8_t)rcx_1)\n        {\n        label_40a9d4:\n            int32_t rdi_3;\n            (uint8_t)rdi_3 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            result = (uint64_t)(rax_3 - rdi_3);\n            \n            if (rax_3 == rdi_3)\n                goto label_40a979;\n        }\n        else\n        {\n        label_40a979:\n            int64_t rax_4 = arg1[9];\n            int64_t temp1_1 = arg2[9];\n            bool cond:0_1 = temp1_1 > rax_4;\n            (uint8_t)rax_4 = temp1_1 < rax_4;\n            (uint8_t)rcx_1 = cond:0_1;\n            uint32_t rax_5 = (uint32_t)(uint8_t)rax_4;\n            uint32_t rcx_2 = (uint32_t)(uint8_t)rcx_1;\n            result = (uint64_t)(rax_5 - rcx_2);\n            \n            if (rax_5 == rcx_2)\n            {\n                char* r12 = *(uint64_t*)arg1;\n                char* rbx = *(uint64_t*)arg2;\n                *(uint32_t*)__errno_location() = 0;\n                /* tailcall */\n                return strcoll(rbx, r12);\n            }\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_timestamp",
          "confidence": 0.85,
          "rationale": "The function checks type fields (values 3 or 9), flag bits, compares timestamp fields, and finally performs a locale-aware string comparison via strcoll, indicating it is a custom comparator for sorting structures.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_comparator",
            "ai_custom_sort"
          ]
        },
        "explain": {
          "summary": "The function implements a custom comparator: it checks specific type codes (3 or 9) in the structures, optionally validates a flag in a bitfield, compares a numeric field, and if those are equal falls back to a locale-aware string comparison via strcoll, clearing errno beforehand.",
          "details": [
            "It reads a byte at offset 0x15 of both arguments and proceeds only if either value is 3 or 9.",
            "A bitmask check ((field_at_0xac & 0xf000) == 0x4000) influences a branch that may adjust the comparison result.",
            "It compares the 64bit values at offset 0x48 (arg1[9] and arg2[9]) and returns the difference if they differ.",
            "When the numeric values are equal, it retrieves the first pointer from each structure, clears errno via __errno_location, and returns the result of strcoll on the two strings."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantics of the type codes 3 and 9 and the bitfield at offset 0xac",
            "What the structures represent (e.g., file entries, locale objects)",
            "Why the function subtracts a flag-derived value before the numeric comparison"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40a9e0",
      "original_name": "sub_40a9e0",
      "final_name": "ai_locale_string_compare",
      "score": 19.0,
      "bb_count": 1,
      "insn_est": 15,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40a9e0  endbr64 \n  0x40a9e4  push    rbp {__saved_rbp}\n  0x40a9e5  mov     rbp, rsp {__saved_rbp}\n  0x40a9e8  push    r12 {__saved_r12}\n  0x40a9ea  push    rbx {__saved_rbx}\n  0x40a9eb  mov     r12, qword [rsi]\n  0x40a9ee  mov     rbx, qword [rdi]\n  0x40a9f1  call    __errno_location\n  0x40a9f6  mov     rsi, r12\n  0x40a9f9  mov     rdi, rbx\n  0x40a9fc  mov     dword [rax], 0x0\n  0x40aa02  pop     rbx {__saved_rbx}\n  0x40aa03  pop     r12 {__saved_r12}\n  0x40aa05  pop     rbp {__saved_rbp}\n  0x40aa06  jmp     strcoll",
        "hlil": "char* r12 = *arg2\nchar* rbx = *arg1\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    char* r12 = *(uint64_t*)arg2;\n    char* rbx = *(uint64_t*)arg1;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_locale_string_compare",
          "confidence": 0.96,
          "rationale": "The function resets errno and forwards its arguments to strcoll, acting as a wrapper for locale-aware string comparison.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "tags": [],
          "alt_names": [
            "ai_strcoll_wrapper",
            "ai_string_compare_locale"
          ]
        },
        "explain": {
          "summary": "The function extracts two string pointers from its arguments, clears the global errno variable, and then forwards the comparison to the locale-aware strcoll function, returning its result.",
          "details": [
            "Loads rbx = *(uint64_t*)arg1 and r12 = *(uint64_t*)arg2 as the strings to compare.",
            "Resets errno to 0 via __errno_location() before performing the comparison.",
            "Calls strcoll(rbx, r12) and returns the comparison result."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [],
          "confidence": 0.98
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40aa10",
      "original_name": "sub_40aa10",
      "final_name": "ai_locale_string_compare",
      "score": 19.0,
      "bb_count": 1,
      "insn_est": 15,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40aa10  endbr64 \n  0x40aa14  push    rbp {__saved_rbp}\n  0x40aa15  mov     rbp, rsp {__saved_rbp}\n  0x40aa18  push    r12 {__saved_r12}\n  0x40aa1a  push    rbx {__saved_rbx}\n  0x40aa1b  mov     r12, qword [rdi]\n  0x40aa1e  mov     rbx, qword [rsi]\n  0x40aa21  call    __errno_location\n  0x40aa26  mov     rsi, r12\n  0x40aa29  mov     rdi, rbx\n  0x40aa2c  mov     dword [rax], 0x0\n  0x40aa32  pop     rbx {__saved_rbx}\n  0x40aa33  pop     r12 {__saved_r12}\n  0x40aa35  pop     rbp {__saved_rbp}\n  0x40aa36  jmp     strcoll",
        "hlil": "char* r12 = *arg1\nchar* rbx = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    char* r12 = *(uint64_t*)arg1;\n    char* rbx = *(uint64_t*)arg2;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_locale_string_compare",
          "confidence": 0.78,
          "rationale": "The function resets errno and forwards its arguments to strcoll, acting as a wrapper for locale-aware string comparison.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll"
          ],
          "tags": [],
          "alt_names": [
            "ai_strcoll_wrapper",
            "ai_string_compare_locale"
          ]
        },
        "explain": {
          "summary": "The function is a thin wrapper around the locale-aware string comparison routine strcoll. It dereferences two pointer arguments to obtain string pointers, clears the global errno, then returns the result of strcoll on the second argument string compared to the first.",
          "details": [
            "Loads a char* from the memory location pointed to by arg1 and another from arg2.",
            "Resets errno to zero via __errno_location before invoking strcoll.",
            "Calls strcoll with the second string as the first parameter and the first string as the second, returning its integer result."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Why the argument order is reversed relative to typical usage",
            "The broader context in which this wrapper is called"
          ],
          "confidence": 0.97
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40aa40",
      "original_name": "sub_40aa40",
      "final_name": "ai_custom_string_compare",
      "score": 41.2,
      "bb_count": 9,
      "insn_est": 49,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40aa40  endbr64 \n  0x40aa44  mov     rdx, rdi\n  0x40aa47  mov     edi, dword [rsi+0xa8]\n  0x40aa4d  mov     eax, dword [rdx+0xa8]\n  0x40aa53  cmp     eax, 0x3\n  0x40aa56  sete    cl\n  0x40aa59  cmp     eax, 0x9\n  0x40aa5c  sete    al\n  0x40aa5f  or      ecx, eax\n  0x40aa61  cmp     edi, 0x3\n  0x40aa64  je      0x40aa90\n  0x40aa90  mov     eax, 0x1\n  0x40aa95  test    cl, cl\n  0x40aa97  je      0x40aac0\n  0x40aa66  cmp     edi, 0x9\n  0x40aa69  je      0x40aa90\n  0x40aac0  mov     ecx, dword [rdx+0xac]\n  0x40aac6  xor     edi, edi  {0x0}\n  0x40aac8  and     ecx, 0xf000\n  0x40aace  cmp     ecx, 0x4000\n  0x40aad4  sete    dil\n  0x40aad8  sub     eax, edi\n  0x40aada  jne     0x40aa8e\n  0x40aa99  push    rbp {__saved_rbp}\n  0x40aa9a  mov     rbp, rsp {__saved_rbp}\n  0x40aa9d  push    r12 {__saved_r12}\n  0x40aa9f  push    rbx {__saved_rbx}\n  0x40aaa0  mov     rbx, qword [rdx]\n  0x40aaa3  mov     r12, qword [rsi]\n  0x40aaa6  call    __errno_location\n  ... (157 bytes total, truncated)",
        "hlil": "int32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\nbool rcx = rax == 3\nrax.b = rax == 9\nchar rcx_1 = rcx | rax.b\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rcx_1 == 0)\nlabel_40aad4:\nint32_t rdi_3\nrdi_3.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rdi_3)\nreturn zx.q(rax_3 - rdi_3)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rcx_1 == 0)\ngoto label_40aad4\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nchar* rbx = *arg1\nchar* r12 = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    bool rcx = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rcx_1 = rcx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rcx_1)\n        {\n        label_40aad4:\n            int32_t rdi_3;\n            (uint8_t)rdi_3 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rdi_3)\n                return (uint64_t)(rax_3 - rdi_3);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rcx_1)\n            goto label_40aad4;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    char* rbx = *(uint64_t*)arg1;\n    char* r12 = *(uint64_t*)arg2;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_custom_string_compare",
          "confidence": 0.78,
          "rationale": "The function checks specific flag fields in two structures, sets errno to 0, then delegates to strcoll for locale-aware string comparison, acting as a custom comparator with special flag handling.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "tags": [],
          "alt_names": [
            "ai_strcoll_with_flags",
            "ai_compare_strings_conditional"
          ]
        },
        "explain": {
          "summary": "The function validates specific fields of two structures, checks a flag mask, clears errno, and then performs a locale-aware string comparison using strcoll, returning either the comparison result or a difference based on mismatched flags.",
          "details": [
            "It reads a byte at offset 0x15 from both arguments and checks if either value equals 3 or 9, setting a combined flag rcx_1.",
            "It examines bits masked by 0xf000 at offset 0xac of the structures, comparing them against 0x4000, and returns the difference if they do not match expected values.",
            "If the preliminary checks pass, it clears errno via __errno_location and delegates the actual string comparison to strcoll using the pointers stored at the start of each structure."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantics of the structures pointed to by arg1 and arg2",
            "Purpose of the specific type values 3 and 9",
            "Reason for using the 0xf000 mask and the 0x4000 flag"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40aae0",
      "original_name": "sub_40aae0",
      "final_name": "ai_custom_sort_compare",
      "score": 40.9,
      "bb_count": 9,
      "insn_est": 48,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40aae0  endbr64 \n  0x40aae4  mov     eax, dword [rdi+0xa8]\n  0x40aaea  mov     ecx, dword [rsi+0xa8]\n  0x40aaf0  cmp     eax, 0x3\n  0x40aaf3  sete    dl\n  0x40aaf6  cmp     eax, 0x9\n  0x40aaf9  sete    al\n  0x40aafc  or      edx, eax\n  0x40aafe  cmp     ecx, 0x3\n  0x40ab01  je      0x40ab30\n  0x40ab30  mov     eax, 0x1\n  0x40ab35  test    dl, dl\n  0x40ab37  je      0x40ab60\n  0x40ab03  cmp     ecx, 0x9\n  0x40ab06  je      0x40ab30\n  0x40ab60  mov     edx, dword [rdi+0xac]\n  0x40ab66  xor     ecx, ecx  {0x0}\n  0x40ab68  and     edx, 0xf000\n  0x40ab6e  cmp     edx, 0x4000\n  0x40ab74  sete    cl\n  0x40ab77  sub     eax, ecx\n  0x40ab79  jne     0x40ab2b\n  0x40ab39  push    rbp {__saved_rbp}\n  0x40ab3a  mov     rbp, rsp {__saved_rbp}\n  0x40ab3d  push    r12 {__saved_r12}\n  0x40ab3f  push    rbx {__saved_rbx}\n  0x40ab40  mov     r12, qword [rdi]\n  0x40ab43  mov     rbx, qword [rsi]\n  0x40ab46  call    __errno_location\n  0x40ab4b  mov     rsi, r12\n  ... (153 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 3\nrax.b = rax == 9\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40ab74:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40ab74\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nchar* r12 = *arg1\nchar* rbx = *arg2\n*__errno_location() = 0\nreturn strcoll(rbx, r12) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40ab74:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40ab74;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    char* r12 = *(uint64_t*)arg1;\n    char* rbx = *(uint64_t*)arg2;\n    *(uint32_t*)__errno_location() = 0;\n    /* tailcall */\n    return strcoll(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_custom_sort_compare",
          "confidence": 0.78,
          "rationale": "The function checks type fields and attribute flags of two objects, then clears errno and delegates to strcoll for string comparison, acting as a custom comparator for sorting entries.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_entries",
            "ai_string_compare_with_flags"
          ]
        },
        "explain": {
          "summary": "The function compares specific fields of two structures, checks for particular flag values, and if those checks pass it clears errno and performs a locale-aware string comparison using strcoll, returning the comparison result. If the flag conditions differ, it returns a numeric difference based on those flags.",
          "details": [
            "It reads a byte at offset 0x15 from both arguments and checks if either value equals 3 or 9, setting a combined flag rdx_1.",
            "It examines a 32bit field at offset 0xac masked with 0xf000 to see if it equals 0x4000, using this to compute a return value when the flag conditions differ.",
            "When the flag checks succeed, it clears errno via __errno_location and calls strcoll with the second argument's string pointer as the first parameter and the first argument's string pointer as the second.",
            "The function returns either the difference of flag-derived values or the result of strcoll."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x404760",
            "call:0x404b60",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantic meaning of the values at offset 0x15 and 0xac in the structures",
            "Why the function swaps argument order for strcoll (rbx, r12) compared to typical usage"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40ab80",
      "original_name": "sub_40ab80",
      "final_name": "ai_compare_filenames_by_extension",
      "score": 54.2,
      "bb_count": 3,
      "insn_est": 44,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404970",
          "name": "ai_strrchr_wrapper",
          "original_name": "strrchr"
        },
        {
          "addr": "0x404970",
          "name": "ai_strrchr_wrapper",
          "original_name": "strrchr"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "strrchr",
        "strrchr",
        "__errno_location",
        "strcoll",
        "strcoll"
      ],
      "string_refs": [
        "[A\\A]A^]"
      ],
      "constants": [
        "0x404970",
        "0x41af54",
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40ab80  endbr64 \n  0x40ab84  push    rbp {__saved_rbp}\n  0x40ab85  mov     rbp, rsp {__saved_rbp}\n  0x40ab88  push    r14 {__saved_r14}\n  0x40ab8a  push    r13 {__saved_r13}\n  0x40ab8c  push    r12 {__saved_r12}\n  0x40ab8e  mov     r12, rsi\n  0x40ab91  mov     esi, 0x2e\n  0x40ab96  push    rbx {__saved_rbx}\n  0x40ab97  mov     r13, qword [rdi]\n  0x40ab9a  mov     rdi, r13\n  0x40ab9d  call    strrchr\n  0x40aba2  mov     r14, qword [r12]\n  0x40aba6  mov     esi, 0x2e\n  0x40abab  mov     rbx, rax\n  0x40abae  mov     rdi, r14\n  0x40abb1  call    strrchr\n  0x40abb6  mov     r12, rax\n  0x40abb9  lea     rax, [rel data_41af54]\n  0x40abc0  test    r12, r12\n  0x40abc3  cmove   r12, rax  {data_41af54}\n  0x40abc7  test    rbx, rbx\n  0x40abca  cmove   rbx, rax  {data_41af54}\n  0x40abce  call    __errno_location\n  0x40abd3  mov     rsi, r12\n  0x40abd6  mov     dword [rax], 0x0\n  0x40abdc  mov     rdi, rbx\n  0x40abdf  call    strcoll\n  0x40abe4  test    eax, eax\n  0x40abe6  jne     0x40ac00\n  ... (132 bytes total, truncated)",
        "hlil": "char* r13 = *arg1\nchar* s1_1 = strrchr(r13, 0x2e)\nchar* r14 = *arg2\nchar* s1 = s1_1\nchar* s2 = strrchr(r14, 0x2e)\nif (s2 == 0)\ns2 = &data_41af54\nif (s1 == 0)\ns1 = &data_41af54\n*__errno_location() = 0\nint32_t result = strcoll(s1, s2)\nif (result != 0)\nreturn result\nreturn strcoll(r13, r14) __tailcall",
        "pseudoc": "{\n    char* r13 = *(uint64_t*)arg1;\n    char* s1_1 = strrchr(r13, 0x2e);\n    char* r14 = *(uint64_t*)arg2;\n    char* s1 = s1_1;\n    char* s2 = strrchr(r14, 0x2e);\n    \n    if (!s2)\n        s2 = &data_41af54;\n    \n    if (!s1)\n        s1 = &data_41af54;\n    \n    *(uint32_t*)__errno_location() = 0;\n    int32_t result = strcoll(s1, s2);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcoll(r13, r14);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_filenames_by_extension",
          "confidence": 0.86,
          "rationale": "The function extracts file extensions using strrchr, compares them with strcoll, and falls back to full string comparison, indicating a locale-aware filename/extension comparator.",
          "evidence_refs": [
            "imports:strrchr",
            "imports:strcoll",
            "imports:__errno_location",
            "strings:data_41af54"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_compare_by_extension",
            "ai_sort_filenames"
          ]
        },
        "explain": {
          "summary": "The function compares two file name strings by first comparing their extensions (the substring after the last '.') using locale-aware collation, and if the extensions are equal, it falls back to comparing the full strings. It clears errno before performing the comparisons.",
          "details": [
            "Extracts the actual string pointers from the provided arguments.",
            "Finds the last '.' in each string with strrchr; if none is found, substitutes a default empty string (data_41af54).",
            "Resets errno to zero via __errno_location.",
            "Uses strcoll to compare the extensions; returns the result if non-zero.",
            "If extensions match, calls strcoll again to compare the full strings and returns that result."
          ],
          "evidence_refs": [
            "imports:strrchr",
            "imports:strcoll",
            "imports:__errno_location",
            "call:0x404970",
            "call:0x404760",
            "call:0x404b60",
            "strings:data_41af54"
          ],
          "unknowns": [
            "Exact content of the default string at data_41af54",
            "Why the function receives pointers to pointers rather than direct strings"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40ac10",
      "original_name": "sub_40ac10",
      "final_name": "ai_compare_file_entries",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40ab80",
          "name": "ai_compare_filenames_by_extension",
          "original_name": "sub_40ab80"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40ab80"
      ],
      "snippets": {
        "asm": "  0x40ac10  endbr64 \n  0x40ac14  mov     eax, dword [rdi+0xa8]\n  0x40ac1a  mov     ecx, dword [rsi+0xa8]\n  0x40ac20  cmp     eax, 0x9\n  0x40ac23  sete    dl\n  0x40ac26  cmp     eax, 0x3\n  0x40ac29  sete    al\n  0x40ac2c  or      edx, eax\n  0x40ac2e  cmp     ecx, 0x3\n  0x40ac31  je      0x40ac60\n  0x40ac60  mov     eax, 0x1\n  0x40ac65  test    dl, dl\n  0x40ac67  je      0x40ac70\n  0x40ac33  cmp     ecx, 0x9\n  0x40ac36  je      0x40ac60\n  0x40ac70  mov     edx, dword [rdi+0xac]\n  0x40ac76  xor     ecx, ecx  {0x0}\n  0x40ac78  and     edx, 0xf000\n  0x40ac7e  cmp     edx, 0x4000\n  0x40ac84  sete    cl\n  0x40ac87  sub     eax, ecx\n  0x40ac89  jne     0x40ac5b\n  0x40ac69  jmp     sub_40ab80\n  0x40ac38  mov     eax, dword [rsi+0xac]\n  0x40ac3e  mov     ecx, 0x1\n  0x40ac43  and     eax, 0xf000\n  0x40ac48  cmp     eax, 0x4000\n  0x40ac4d  sete    al\n  0x40ac50  movzx   eax, al\n  0x40ac53  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40ac84:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40ac84\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40ab80(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40ac84:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40ac84;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40ab80(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_file_entries",
          "confidence": 0.86,
          "rationale": "The function checks type fields and flag bits of two structures, then falls back to comparing file name extensions via strcoll, indicating it is a comparator for file entries used in sorting or ordering.",
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40ab80"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_sort_by_type_and_extension",
            "ai_file_entry_comparator"
          ]
        },
        "explain": {
          "summary": "sub_40ac10 compares two objects based on a type field at offset 0x15 and a flag field at offset 0xac, returning a numeric ordering when certain type codes (3 or 9) or flag bits (0x4000) differ; otherwise it delegates to sub_40ab80 which performs a string comparison of file extensions and full names.",
          "details": [
            "Reads a byte/word at offset 0x15 from each argument and checks for values 3 or 9, setting a combined flag rdx_1.",
            "Masks a 32bit value at offset 0xac with 0xf000 and compares it against 0x4000 to influence the return value.",
            "If the early checks do not determine ordering, the function tailcalls sub_40ab80 to compare file extensions and then full strings.",
            "Returns the difference of the flag values when mismatched, otherwise passes control to the string comparator."
          ],
          "evidence_refs": [
            "call:0x40ab80",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantics of the values at offset 0x15 and 0xac (e.g., file type or attribute codes)",
            "Why only type codes 3 and 9 are specialcased"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40ac90",
      "original_name": "sub_40ac90",
      "final_name": "ai_compare_filenames_by_extension",
      "score": 54.2,
      "bb_count": 3,
      "insn_est": 44,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404970",
          "name": "ai_strrchr_wrapper",
          "original_name": "strrchr"
        },
        {
          "addr": "0x404970",
          "name": "ai_strrchr_wrapper",
          "original_name": "strrchr"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        }
      ],
      "import_refs": [
        "strrchr",
        "strrchr",
        "__errno_location",
        "strcoll",
        "strcoll"
      ],
      "string_refs": [
        "[A\\A]A^]"
      ],
      "constants": [
        "0x404970",
        "0x41af54",
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40ac90  endbr64 \n  0x40ac94  push    rbp {__saved_rbp}\n  0x40ac95  mov     rbp, rsp {__saved_rbp}\n  0x40ac98  push    r14 {__saved_r14}\n  0x40ac9a  push    r13 {__saved_r13}\n  0x40ac9c  push    r12 {__saved_r12}\n  0x40ac9e  mov     r12, rdi\n  0x40aca1  push    rbx {__saved_rbx}\n  0x40aca2  mov     r13, qword [rsi]\n  0x40aca5  mov     esi, 0x2e\n  0x40acaa  mov     rdi, r13\n  0x40acad  call    strrchr\n  0x40acb2  mov     r14, qword [r12]\n  0x40acb6  mov     esi, 0x2e\n  0x40acbb  mov     rbx, rax\n  0x40acbe  mov     rdi, r14\n  0x40acc1  call    strrchr\n  0x40acc6  mov     r12, rax\n  0x40acc9  lea     rax, [rel data_41af54]\n  0x40acd0  test    r12, r12\n  0x40acd3  cmove   r12, rax  {data_41af54}\n  0x40acd7  test    rbx, rbx\n  0x40acda  cmove   rbx, rax  {data_41af54}\n  0x40acde  call    __errno_location\n  0x40ace3  mov     rsi, r12\n  0x40ace6  mov     dword [rax], 0x0\n  0x40acec  mov     rdi, rbx\n  0x40acef  call    strcoll\n  0x40acf4  test    eax, eax\n  0x40acf6  jne     0x40ad10\n  ... (132 bytes total, truncated)",
        "hlil": "char* r13 = *arg2\nchar* s1_1 = strrchr(r13, 0x2e)\nchar* r14 = *arg1\nchar* s1 = s1_1\nchar* s2 = strrchr(r14, 0x2e)\nif (s2 == 0)\ns2 = &data_41af54\nif (s1 == 0)\ns1 = &data_41af54\n*__errno_location() = 0\nint32_t result = strcoll(s1, s2)\nif (result != 0)\nreturn result\nreturn strcoll(r13, r14) __tailcall",
        "pseudoc": "{\n    char* r13 = *(uint64_t*)arg2;\n    char* s1_1 = strrchr(r13, 0x2e);\n    char* r14 = *(uint64_t*)arg1;\n    char* s1 = s1_1;\n    char* s2 = strrchr(r14, 0x2e);\n    \n    if (!s2)\n        s2 = &data_41af54;\n    \n    if (!s1)\n        s1 = &data_41af54;\n    \n    *(uint32_t*)__errno_location() = 0;\n    int32_t result = strcoll(s1, s2);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcoll(r13, r14);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_filenames_by_extension",
          "confidence": 0.87,
          "rationale": "The function extracts file extensions using strrchr, compares them with strcoll, and falls back to full string comparison, indicating a filename/extension comparator used for sorting or ordering.",
          "evidence_refs": [
            "imports:strrchr",
            "imports:strcoll",
            "imports:__errno_location",
            "strings:'[A\\A]A^]'"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_compare_by_extension",
            "ai_sort_filenames"
          ]
        },
        "explain": {
          "summary": "The function compares two file path strings by first extracting their extensions (text after the last '.') and comparing those extensions using locale-aware string comparison; if the extensions differ, it returns that result, otherwise it falls back to comparing the full original strings.",
          "details": [
            "It retrieves the last '.' in each input string via strrchr; if none is found, it substitutes a default string located at data_41af54.",
            "It clears errno, then calls strcoll on the two extensions; a non-zero result is returned immediately.",
            "If the extensions are equal, it calls strcoll again on the original full strings and returns that result."
          ],
          "evidence_refs": [
            "imports:strrchr",
            "imports:__errno_location",
            "imports:strcoll",
            "strings:data_41af54",
            "call:0x404970",
            "call:0x404760"
          ],
          "unknowns": [
            "Exact content of data_41af54 (likely an empty string or placeholder)",
            "Purpose of the constant string \"[A\\A]A^]\" which is not used in this function"
          ],
          "confidence": 0.97
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40ad20",
      "original_name": "sub_40ad20",
      "final_name": "ai_compare_file_entries",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40ac90",
          "name": "ai_compare_filenames_by_extension",
          "original_name": "sub_40ac90"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40ac90"
      ],
      "snippets": {
        "asm": "  0x40ad20  endbr64 \n  0x40ad24  mov     eax, dword [rdi+0xa8]\n  0x40ad2a  mov     ecx, dword [rsi+0xa8]\n  0x40ad30  cmp     eax, 0x9\n  0x40ad33  sete    dl\n  0x40ad36  cmp     eax, 0x3\n  0x40ad39  sete    al\n  0x40ad3c  or      edx, eax\n  0x40ad3e  cmp     ecx, 0x3\n  0x40ad41  je      0x40ad70\n  0x40ad70  mov     eax, 0x1\n  0x40ad75  test    dl, dl\n  0x40ad77  je      0x40ad80\n  0x40ad43  cmp     ecx, 0x9\n  0x40ad46  je      0x40ad70\n  0x40ad80  mov     edx, dword [rdi+0xac]\n  0x40ad86  xor     ecx, ecx  {0x0}\n  0x40ad88  and     edx, 0xf000\n  0x40ad8e  cmp     edx, 0x4000\n  0x40ad94  sete    cl\n  0x40ad97  sub     eax, ecx\n  0x40ad99  jne     0x40ad6b\n  0x40ad79  jmp     sub_40ac90\n  0x40ad48  mov     eax, dword [rsi+0xac]\n  0x40ad4e  mov     ecx, 0x1\n  0x40ad53  and     eax, 0xf000\n  0x40ad58  cmp     eax, 0x4000\n  0x40ad5d  sete    al\n  0x40ad60  movzx   eax, al\n  0x40ad63  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40ad94:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40ad94\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40ac90(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40ad94:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40ad94;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40ac90(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_file_entries",
          "confidence": 0.78,
          "rationale": "The function checks type fields and flag bits of two structures, then delegates to sub_40ac90 which compares file extensions and full names, indicating a comparator for sorting file entries based on type and extension.",
          "evidence_refs": [
            "call:0x40ac90",
            "constants:0x4000",
            "constants:0xf000"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_entry_type_extension_compare",
            "ai_sort_file_records"
          ]
        },
        "explain": {
          "summary": "sub_40ad20 first checks a type field at offset 0x15 of both arguments for values 3 or 9 and examines a highorder flag mask (0xf000) at offset 0xac. Depending on those checks it may return a simple numeric ordering result; otherwise it falls back to sub_40ac90 which compares file name extensions and full strings. The function thus implements a twostage comparison: a quick numeric/flag based ordering followed by a lexical string comparison.",
          "details": [
            "Reads arg1[0x15] and arg2[0x15] and sets flags if they equal 3 or 9.",
            "Masks a 32bit field at offset 0xac with 0xf000 and compares it against 0x4000 to derive a secondary ordering value.",
            "If the preliminary checks resolve ordering, returns the difference of the computed values.",
            "If not resolved, tailcalls sub_40ac90 which extracts file extensions via strrchr and compares them with strcoll, then compares full paths if extensions match."
          ],
          "evidence_refs": [
            "call:0x40ac90",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantic meaning of the type codes 3 and 9 in the structures",
            "Purpose of the masked field at offset 0xac and why 0x4000 is significant"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40ada0",
      "original_name": "sub_40ada0",
      "final_name": "ai_custom_string_compare",
      "score": 26.1,
      "bb_count": 3,
      "insn_est": 22,
      "callers": 0,
      "callees": [
        {
          "addr": "0x412600",
          "name": "ai_filename_compare",
          "original_name": "sub_412600"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [
        "[A\\]"
      ],
      "constants": [
        "0x412600",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x40ada0  endbr64 \n  0x40ada4  push    rbp {__saved_rbp}\n  0x40ada5  mov     rbp, rsp {__saved_rbp}\n  0x40ada8  push    r12 {__saved_r12}\n  0x40adaa  push    rbx {__saved_rbx}\n  0x40adab  mov     rbx, qword [rdi]\n  0x40adae  mov     r12, qword [rsi]\n  0x40adb1  mov     rdi, rbx\n  0x40adb4  mov     rsi, r12\n  0x40adb7  call    sub_412600\n  0x40adbc  test    eax, eax\n  0x40adbe  jne     0x40add0\n  0x40add0  pop     rbx {__saved_rbx}\n  0x40add1  pop     r12 {__saved_r12}\n  0x40add3  pop     rbp {__saved_rbp}\n  0x40add4  retn     {__return_addr}\n  0x40adc0  mov     rsi, r12\n  0x40adc3  mov     rdi, rbx\n  0x40adc6  pop     rbx {__saved_rbx}\n  0x40adc7  pop     r12 {__saved_r12}\n  0x40adc9  pop     rbp {__saved_rbp}\n  0x40adca  jmp     strcmp",
        "hlil": "char* rbx = *arg1\nchar* r12 = *arg2\nuint32_t result = sub_412600(rbx, r12)\nif (result != 0)\nreturn result\nreturn strcmp(rbx, r12) __tailcall",
        "pseudoc": "{\n    char* rbx = *(uint64_t*)arg1;\n    char* r12 = *(uint64_t*)arg2;\n    uint32_t result = sub_412600(rbx, r12);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_custom_string_compare",
          "confidence": 0.78,
          "rationale": "The function first calls a custom comparison routine (sub_412600) and falls back to strcmp, indicating a specialized string comparison wrapper.",
          "evidence_refs": [
            "strings:'[A\\\\]'",
            "imports:strcmp",
            "call:0x412600"
          ],
          "tags": [],
          "alt_names": [
            "ai_strcmp_with_custom_fallback",
            "ai_special_strcmp"
          ]
        },
        "explain": {
          "summary": "sub_40ada0 compares two strings by first invoking a custom comparison routine (sub_412600) that handles special cases, and if that routine reports equality it falls back to a standard strcmp for a full lexical comparison.",
          "details": [
            "Loads the first characters of the input strings and calls sub_412600(rbx, r12) to perform a preliminary check.",
            "If sub_412600 returns a non-zero result (indicating a difference), that result is returned directly.",
            "If sub_412600 reports equality (returns zero), the function tailcalls the standard library strcmp to complete the comparison."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x412600",
            "call:0x4046c0",
            "strings:[A\\]"
          ],
          "unknowns": [
            "Exact semantics of sub_412600's special handling (e.g., handling of '.' or other characters).",
            "Purpose of the string constant \"[A\\\\]\" in this context."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40ade0",
      "original_name": "sub_40ade0",
      "final_name": "ai_custom_strcmp",
      "score": 26.1,
      "bb_count": 3,
      "insn_est": 22,
      "callers": 0,
      "callees": [
        {
          "addr": "0x412600",
          "name": "ai_filename_compare",
          "original_name": "sub_412600"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [
        "[A\\]"
      ],
      "constants": [
        "0x412600",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x40ade0  endbr64 \n  0x40ade4  push    rbp {__saved_rbp}\n  0x40ade5  mov     rbp, rsp {__saved_rbp}\n  0x40ade8  push    r12 {__saved_r12}\n  0x40adea  push    rbx {__saved_rbx}\n  0x40adeb  mov     rbx, qword [rsi]\n  0x40adee  mov     r12, qword [rdi]\n  0x40adf1  mov     rdi, rbx\n  0x40adf4  mov     rsi, r12\n  0x40adf7  call    sub_412600\n  0x40adfc  test    eax, eax\n  0x40adfe  jne     0x40ae10\n  0x40ae10  pop     rbx {__saved_rbx}\n  0x40ae11  pop     r12 {__saved_r12}\n  0x40ae13  pop     rbp {__saved_rbp}\n  0x40ae14  retn     {__return_addr}\n  0x40ae00  mov     rsi, r12\n  0x40ae03  mov     rdi, rbx\n  0x40ae06  pop     rbx {__saved_rbx}\n  0x40ae07  pop     r12 {__saved_r12}\n  0x40ae09  pop     rbp {__saved_rbp}\n  0x40ae0a  jmp     strcmp",
        "hlil": "char* rbx = *arg2\nchar* r12 = *arg1\nuint32_t result = sub_412600(rbx, r12)\nif (result != 0)\nreturn result\nreturn strcmp(rbx, r12) __tailcall",
        "pseudoc": "{\n    char* rbx = *(uint64_t*)arg2;\n    char* r12 = *(uint64_t*)arg1;\n    uint32_t result = sub_412600(rbx, r12);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_custom_strcmp",
          "confidence": 0.78,
          "rationale": "The function performs a custom string comparison by first calling sub_412600 for special handling, then falling back to the standard strcmp, indicating a wrapper around string comparison with extra logic.",
          "evidence_refs": [
            "strings:[A\\]",
            "imports:strcmp",
            "call:0x412600",
            "call:0x4046c0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_strcmp_wrapper",
            "ai_string_compare_with_precheck"
          ]
        },
        "explain": {
          "summary": "sub_40ade0 performs a two-stage string comparison. It first calls a custom comparator sub_412600, returning its result if it indicates a difference, otherwise it falls back to the standard strcmp to compare the full strings.",
          "details": [
            "Loads two string pointers from the provided arguments and passes them to sub_412600.",
            "If sub_412600 returns a non-zero value (indicating inequality or a special case), that result is returned directly.",
            "If sub_412600 returns zero (strings appear equal under its custom rules), the function delegates to strcmp for a full lexical comparison."
          ],
          "evidence_refs": [
            "strings:'[A\\\\]'",
            "imports:strcmp",
            "call:0x412600",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantics of the custom comparison performed by sub_412600, especially handling of special characters."
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40ae20",
      "original_name": "sub_40ae20",
      "final_name": "ai_compare_structs_by_type",
      "score": 48.0,
      "bb_count": 11,
      "insn_est": 55,
      "callers": 0,
      "callees": [
        {
          "addr": "0x412600",
          "name": "ai_filename_compare",
          "original_name": "sub_412600"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [
        "[A\\]"
      ],
      "constants": [
        "0xf000",
        "0x4000",
        "0x412600",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x40ae20  endbr64 \n  0x40ae24  mov     eax, dword [rdi+0xa8]\n  0x40ae2a  mov     ecx, dword [rsi+0xa8]\n  0x40ae30  cmp     eax, 0x3\n  0x40ae33  sete    dl\n  0x40ae36  cmp     eax, 0x9\n  0x40ae39  sete    al\n  0x40ae3c  or      edx, eax\n  0x40ae3e  cmp     ecx, 0x3\n  0x40ae41  je      0x40ae70\n  0x40ae70  mov     eax, 0x1\n  0x40ae75  test    dl, dl\n  0x40ae77  je      0x40aea8\n  0x40ae43  cmp     ecx, 0x9\n  0x40ae46  je      0x40ae70\n  0x40aea8  mov     edx, dword [rdi+0xac]\n  0x40aeae  xor     ecx, ecx  {0x0}\n  0x40aeb0  and     edx, 0xf000\n  0x40aeb6  cmp     edx, 0x4000\n  0x40aebc  sete    cl\n  0x40aebf  sub     eax, ecx\n  0x40aec1  jne     0x40ae6b\n  0x40ae79  push    rbp {__saved_rbp}\n  0x40ae7a  mov     rbp, rsp {__saved_rbp}\n  0x40ae7d  push    r12 {__saved_r12}\n  0x40ae7f  push    rbx {__saved_rbx}\n  0x40ae80  mov     rbx, qword [rdi]\n  0x40ae83  mov     r12, qword [rsi]\n  0x40ae86  mov     rdi, rbx\n  0x40ae89  mov     rsi, r12\n  ... (162 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 3\nrax.b = rax == 9\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40aebc:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40aebc\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nchar* rbx = *arg1\nchar* r12 = *arg2\nuint32_t result = sub_412600(rbx, r12)\nif (result != 0)\nreturn result\nreturn strcmp(rbx, r12) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40aebc:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40aebc;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    char* rbx = *(uint64_t*)arg1;\n    char* r12 = *(uint64_t*)arg2;\n    uint32_t result = sub_412600(rbx, r12);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_structs_by_type",
          "confidence": 0.81,
          "rationale": "Function checks type/flag fields of two objects, then falls back to a custom compare and finally strcmp, indicating a comparator for entries based on type and string content.",
          "evidence_refs": [
            "strings:'[A\\]'",
            "imports:strcmp",
            "call:0x412600"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_struct_comparator",
            "ai_entry_compare"
          ]
        },
        "explain": {
          "summary": "sub_40ae20 compares two objects by first checking type codes and a flag field, then performs a custom string comparison via sub_412600 and falls back to a standard strcmp, returning an ordering or difference value.",
          "details": [
            "It reads a byte at offset 0x15 from each argument and treats values 3 or 9 specially, setting a flag rdx_1.",
            "It checks a masked field at offset 0xac for the bit pattern 0x4000 and uses this to influence the return value before any string comparison.",
            "If the preliminary checks pass, it extracts pointers from the start of each argument and calls sub_412600 for a specialized comparison; if that yields zero it calls strcmp on the pointed strings.",
            "The function returns either the result of the flag/field comparison, the result of sub_412600, or the strcmp result."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x412600",
            "constants:0xf000",
            "constants:0x4000",
            "strings:'[A\\\\]'"
          ],
          "unknowns": [
            "Exact semantic meaning of the values 3 and 9 at offset 0x15",
            "Purpose of the flag check using 0x4000 mask at offset 0xac",
            "Detailed behavior of sub_412600 beyond its partial implementation"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40aed0",
      "original_name": "sub_40aed0",
      "final_name": "ai_compare_objects_by_type_and_name",
      "score": 48.3,
      "bb_count": 11,
      "insn_est": 56,
      "callers": 0,
      "callees": [
        {
          "addr": "0x412600",
          "name": "ai_filename_compare",
          "original_name": "sub_412600"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [
        "[A\\]"
      ],
      "constants": [
        "0xf000",
        "0x4000",
        "0x412600",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x40aed0  endbr64 \n  0x40aed4  mov     rdx, rdi\n  0x40aed7  mov     edi, dword [rsi+0xa8]\n  0x40aedd  mov     eax, dword [rdx+0xa8]\n  0x40aee3  cmp     eax, 0x3\n  0x40aee6  sete    cl\n  0x40aee9  cmp     eax, 0x9\n  0x40aeec  sete    al\n  0x40aeef  or      ecx, eax\n  0x40aef1  cmp     edi, 0x3\n  0x40aef4  je      0x40af20\n  0x40af20  mov     eax, 0x1\n  0x40af25  test    cl, cl\n  0x40af27  je      0x40af58\n  0x40aef6  cmp     edi, 0x9\n  0x40aef9  je      0x40af20\n  0x40af58  mov     ecx, dword [rdx+0xac]\n  0x40af5e  xor     edi, edi  {0x0}\n  0x40af60  and     ecx, 0xf000\n  0x40af66  cmp     ecx, 0x4000\n  0x40af6c  sete    dil\n  0x40af70  sub     eax, edi\n  0x40af72  jne     0x40af1e\n  0x40af29  push    rbp {__saved_rbp}\n  0x40af2a  mov     rbp, rsp {__saved_rbp}\n  0x40af2d  push    r12 {__saved_r12}\n  0x40af2f  mov     r12, qword [rdx]\n  0x40af32  push    rbx {__saved_rbx}\n  0x40af33  mov     rbx, qword [rsi]\n  0x40af36  mov     rsi, r12\n  ... (166 bytes total, truncated)",
        "hlil": "int32_t rdi = arg2[0x15].d\nint32_t rax = arg1[0x15].d\nbool rcx = rax == 3\nrax.b = rax == 9\nchar rcx_1 = rcx | rax.b\nuint32_t rax_3\nif (rdi == 3 || rdi == 9)\nrax_3 = 1\nif (rcx_1 == 0)\nlabel_40af6c:\nint32_t rdi_4\nrdi_4.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rdi_4)\nreturn zx.q(rax_3 - rdi_4)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rcx_1 == 0)\ngoto label_40af6c\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nchar* r12 = *arg1\nchar* rbx = *arg2\nuint32_t result = sub_412600(rbx, r12)\nif (result != 0)\nreturn result\nreturn strcmp(rbx, r12) __tailcall",
        "pseudoc": "{\n    int32_t rdi = arg2[0x15];\n    int32_t rax = arg1[0x15];\n    bool rcx = rax == 3;\n    (uint8_t)rax = rax == 9;\n    char rcx_1 = rcx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rdi == 3 || rdi == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rcx_1)\n        {\n        label_40af6c:\n            int32_t rdi_4;\n            (uint8_t)rdi_4 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rdi_4)\n                return (uint64_t)(rax_3 - rdi_4);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rcx_1)\n            goto label_40af6c;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    char* r12 = *(uint64_t*)arg1;\n    char* rbx = *(uint64_t*)arg2;\n    uint32_t result = sub_412600(rbx, r12);\n    \n    if (result)\n        return result;\n    \n    /* tailcall */\n    return strcmp(rbx, r12);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_objects_by_type_and_name",
          "confidence": 0.78,
          "rationale": "The function checks type fields and flag bits of two structures, then calls a custom comparator sub_412600 and falls back to strcmp, indicating it implements a comparison routine for objects or entries.",
          "evidence_refs": [
            "strings:'[A\\\\]'",
            "imports:strcmp",
            "call:0x412600"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_compare_structs",
            "ai_entry_comparator"
          ]
        },
        "explain": {
          "summary": "sub_40aed0 compares two objects by first checking a type field and a flag field, then optionally performing a custom string comparison before falling back to a standard strcmp. It returns a difference based on mismatched flags or the result of the custom comparison, otherwise the lexical string comparison result.",
          "details": [
            "The function reads a byte at offset 0x15 from both arguments and checks for values 3 or 9, using this to set a flag (rcx_1).",
            "It then examines a 32-bit field at offset 0xac masked with 0xf000 to see if it equals 0x4000, using this to compute a boolean (rax_3) that is compared against the flag, returning the difference if they differ.",
            "If the flag checks pass, it retrieves pointers stored at the start of each structure (arg1 and arg2) and calls sub_412600 for a specialized comparison.",
            "If sub_412600 returns nonzero, that value is returned; otherwise the function calls strcmp on the two strings and returns its result."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x412600",
            "constants:0xf000",
            "constants:0x4000",
            "strings:'[A\\\\]'"
          ],
          "unknowns": [
            "Exact semantics of the type values 3 and 9",
            "Purpose of the custom comparison performed by sub_412600",
            "Structure layout beyond the examined offsets"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40af90",
      "original_name": "sub_40af90",
      "final_name": "ai_print_padded_string",
      "score": 78.0,
      "bb_count": 8,
      "insn_est": 50,
      "callers": 4,
      "callees": [
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        }
      ],
      "import_refs": [
        "strlen",
        "strlen",
        "__overflow",
        "__printf_chk"
      ],
      "string_refs": [
        "[A\\]",
        "%*lu "
      ],
      "constants": [
        "0x41ae8c",
        "0x404bd0",
        "0x423350",
        "0x4048e0",
        "0x4140a0",
        "0x408170",
        "0x422fa8",
        "0x404960"
      ],
      "snippets": {
        "asm": "  0x40af90  push    rbp {__saved_rbp}\n  0x40af91  mov     rbp, rsp {__saved_rbp}\n  0x40af94  push    r12 {__saved_r12}\n  0x40af96  push    rbx {__saved_rbx}\n  0x40af97  mov     ebx, edx\n  0x40af99  test    rdi, rdi\n  0x40af9c  je      0x40b018\n  0x40b018  mov     rcx, rsi\n  0x40b01b  mov     edi, 0x2\n  0x40b020  xor     eax, eax  {0x0}\n  0x40b022  lea     rsi, [rel data_41ae8c]  {\"%*lu \"}\n  0x40b029  call    __printf_chk\n  0x40b02e  pop     rbx {__saved_rbx}\n  0x40b02f  pop     r12 {__saved_r12}\n  0x40b031  cdqe    \n  0x40b033  pop     rbp {__saved_rbp}\n  0x40b034  add     qword [rel data_423350], rax\n  0x40b03b  retn     {__return_addr}\n  0x40af9e  mov     r12, rdi\n  0x40afa1  call    strlen\n  0x40afa6  mov     rdi, r12\n  0x40afa9  mov     rsi, rax\n  0x40afac  call    sub_4140a0\n  0x40afb1  mov     rdi, r12\n  0x40afb4  sub     ebx, eax\n  0x40afb6  mov     eax, 0x0\n  0x40afbb  cmovs   ebx, eax  {0x0}\n  0x40afbe  call    strlen\n  0x40afc3  mov     rdi, r12\n  0x40afc6  mov     rsi, rax\n  ... (163 bytes total, truncated)",
        "hlil": "if (arg1 == 0)\nint64_t rax_5 = sx.q(__printf_chk(2, \"%*lu \", arg3, arg2))\ndata_423350 += rax_5\nreturn rax_5\nchar* r12 = arg1\nint32_t rax_1 = sub_4140a0(r12, strlen(arg1))\nint32_t i_1 = arg3 - rax_1\nif (arg3 - rax_1 s< 0)\ni_1 = 0\nsub_408170(r12, strlen(r12))\nchar* _IO_write_ptr\nint32_t i\nFILE* f = *stdout\ndata_423350 += 1\n_IO_write_ptr = f->_IO_write_ptr\nif (_IO_write_ptr u>= f->_IO_write_end)\n_IO_write_ptr = __overflow(f, 0x20)\nf->_IO_write_ptr = &_IO_write_ptr[1]\n*_IO_write_ptr = 0x20\ni = i_1\ni_1 -= 1\ndo while (i u>= 1)\nreturn _IO_write_ptr",
        "pseudoc": "{\n    if (!arg1)\n    {\n        int64_t rax_5 = (int64_t)__printf_chk(2, \"%*lu \", arg3, arg2);\n        data_423350 += rax_5;\n        return rax_5;\n    }\n    \n    char* r12 = arg1;\n    int32_t rax_1 = sub_4140a0(r12, strlen(arg1));\n    int32_t i_1 = arg3 - rax_1;\n    \n    if (arg3 - rax_1 < 0)\n        i_1 = 0;\n    \n    sub_408170(r12, strlen(r12));\n    char* _IO_write_ptr;\n    int32_t i;\n    \n    do\n    {\n        FILE* f = *(uint64_t*)stdout;\n        data_423350 += 1;\n        _IO_write_ptr = f->_IO_write_ptr;\n        \n        if (_IO_write_ptr >= f->_IO_write_end)\n            _IO_write_ptr = __overflow(f, 0x20);\n        else\n        {\n            f->_IO_write_ptr = &_IO_write_ptr[1];\n            *(uint8_t*)_IO_write_ptr = 0x20;\n        }\n        \n        i = i_1;\n        i_1 -= 1;\n    } while (i >= 1);\n    return _IO_write_ptr;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_padded_string",
          "confidence": 0.86,
          "rationale": "The function formats output by printing a string (or number) with left padding to a specified width, handling multibyte width calculations and writing spaces directly to stdout.",
          "evidence_refs": [
            "strings:\"%*lu \"",
            "imports:__printf_chk",
            "imports:__overflow",
            "call:0x4140a0",
            "call:0x408170"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_format_aligned_output",
            "ai_print_column_padding"
          ]
        },
        "explain": {
          "summary": "The function formats output to a fixed width. If the first argument is NULL it prints a numeric value using a \"%*lu \" format and updates a global counter. If a string is provided it computes its display width, prints the string, then pads the output with spaces until the desired width is reached, also updating the counter.",
          "details": [
            "When arg1 is NULL, __printf_chk is called with format \"%*lu \" using arg3 as field width and arg2 as the value, and the number of characters printed is added to data_423350.",
            "When arg1 is nonNULL, sub_4140a0 is called to compute the printable width of the string (likely handling multibyte characters).",
            "The string is output via sub_408170, then a loop writes space characters directly to stdout until the total printed width matches arg3.",
            "Each space written increments the global counter data_423350, and the function returns a pointer to the last written character."
          ],
          "evidence_refs": [
            "strings:\"%*lu \"",
            "imports:__printf_chk",
            "imports:strlen",
            "imports:__overflow",
            "call:0x4140a0",
            "call:0x408170"
          ],
          "unknowns": [
            "Exact implementation of sub_408170 (how it writes the string)",
            "Precise behavior of sub_4140a0 for multibyte/wide characters",
            "Purpose of the global variable data_423350 beyond counting characters"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40b040",
      "original_name": "sub_40b040",
      "final_name": "ai_compute_string_sort_key",
      "score": 55.2,
      "bb_count": 6,
      "insn_est": 39,
      "callers": 10,
      "callees": [
        {
          "addr": "0x414230",
          "name": "ai_validate_string_and_flag",
          "original_name": "sub_414230"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "free",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x1000",
        "0xffffffffffffdfd8",
        "0xffffffffffffdfe0",
        "0xffffffffffffdfcf",
        "0xffffffffffffdfd0",
        "0x414230",
        "0x4048f0",
        "0x2030",
        "0x4046b0"
      ],
      "snippets": {
        "asm": "  0x40b040  push    rbp {__saved_rbp}\n  0x40b041  mov     rbp, rsp {__saved_rbp}\n  0x40b044  push    r12 {__saved_r12}\n  0x40b046  push    rbx {__saved_rbx}\n  0x40b047  sub     rsp, 0x1000\n  0x40b04e  or      qword [rsp {var_1018_1} {var_1018}], 0x0\n  0x40b053  sub     rsp, 0x1000\n  0x40b05a  or      qword [rsp {var_2018_1} {var_2018}], 0x0\n  0x40b05f  sub     rsp, 0x30\n  0x40b063  mov     rbx, rdi\n  0x40b066  mov     ecx, edx\n  0x40b068  lea     rdi, [rbp-0x2028 {var_2030}]\n  0x40b06f  mov     rdx, rsi\n  0x40b072  lea     r12, [rbp-0x2020 {var_2028}]\n  0x40b079  lea     r9, [rbp-0x2031 {var_2039}]\n  0x40b080  mov     rsi, rbx\n  0x40b083  mov     rax, qword [fs:0x28]\n  0x40b08c  mov     qword [rbp-0x18 {var_20}], rax\n  0x40b090  xor     eax, eax  {0x0}\n  0x40b092  lea     r8, [rbp-0x2030 {var_2038}]\n  0x40b099  mov     qword [rbp-0x2028 {var_2030}], r12 {var_2028}\n  0x40b0a0  call    sub_414230\n  0x40b0a5  mov     rdi, qword [rbp-0x2028 {var_2030}]\n  0x40b0ac  cmp     rdi, rbx\n  0x40b0af  je      0x40b0bb\n  0x40b0bb  movzx   eax, byte [rbp-0x2031 {var_2039}]\n  0x40b0c2  add     rax, qword [rbp-0x2030 {var_2038}]\n  0x40b0c9  mov     rdx, qword [rbp-0x18 {var_20}]\n  0x40b0cd  sub     rdx, qword [fs:0x28]\n  0x40b0d6  jne     0x40b0e4\n  ... (169 bytes total, truncated)",
        "hlil": "int64_t var_1018\nint64_t var_1018_1 = var_1018\nint64_t var_2018\nint64_t var_2018_1 = var_2018\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nvoid var_2028\nvoid* var_2030 = &var_2028\nchar var_2039\nuint64_t var_2038\nuint64_t r14\nsub_414230(&var_2030, arg1, arg2, arg3, &var_2038, &var_2039, r14)\nvoid* rdi_1 = var_2030\nif (rdi_1 != arg1 && rdi_1 != &var_2028)\nfree(rdi_1)\n*(fsbase + 0x28)\nif (rax == *(fsbase + 0x28))\nreturn zx.q(var_2039) + var_2038\n__stack_chk_fail()\nnoreturn",
        "pseudoc": "{\n    int64_t var_1018;\n    int64_t var_1018_1 = var_1018;\n    int64_t var_2018;\n    int64_t var_2018_1 = var_2018;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    void var_2028;\n    void* var_2030 = &var_2028;\n    char var_2039;\n    uint64_t var_2038;\n    uint64_t r14;\n    sub_414230(&var_2030, arg1, arg2, arg3, &var_2038, &var_2039, r14);\n    void* rdi_1 = var_2030;\n    \n    if (rdi_1 != arg1 && rdi_1 != &var_2028)\n        free(rdi_1);\n    \n    *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n        return (uint64_t)var_2039 + var_2038;\n    \n    __stack_chk_fail();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compute_string_sort_key",
          "confidence": 0.78,
          "rationale": "The function calls a helper that processes a string, frees temporary buffers, and returns a combined value used by comparison functions to sort strings, indicating it computes a locale-aware sort key or hash.",
          "evidence_refs": [
            "imports:free",
            "imports:__stack_chk_fail",
            "call:0x414230"
          ],
          "tags": [],
          "alt_names": [
            "ai_string_collation_key",
            "ai_string_hash_for_sort"
          ]
        },
        "explain": {
          "summary": "sub_40b040 is a wrapper that invokes sub_414230 to generate a processed representation of a string (likely a localeaware collation key), handles temporary allocation, frees it if needed, and returns a numeric result derived from two output values.",
          "details": [
            "Calls sub_414230 with the original string and additional parameters, receiving a pointer (var_2030), a size/value (var_2038) and a flag/extra value (var_2039).",
            "If the returned pointer is not the original input or a local buffer, it frees the allocated memory, then returns the sum of var_2038 and var_2039 after a stackcanary check."
          ],
          "evidence_refs": [
            "imports:free",
            "imports:__stack_chk_fail",
            "call:0x414230"
          ],
          "unknowns": [
            "Exact meaning of the returned sum (var_2038 + var_2039)  whether it is a length, hash, or collation weight.",
            "Precise behavior of sub_414230 (string transformation, locale handling, etc.)."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40b0f0",
      "original_name": "sub_40b0f0",
      "final_name": "ai_cached_string_compare",
      "score": 38.2,
      "bb_count": 7,
      "insn_est": 44,
      "callers": 1,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4235a0",
        "0x40b040",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x40b0f0  endbr64 \n  0x40b0f4  push    rbp {__saved_rbp}\n  0x40b0f5  mov     rbp, rsp {__saved_rbp}\n  0x40b0f8  push    r13 {__saved_r13}\n  0x40b0fa  mov     r13, rsi\n  0x40b0fd  push    r12 {__saved_r12}\n  0x40b0ff  mov     r12, rdi\n  0x40b102  push    rbx {__saved_rbx}\n  0x40b103  sub     rsp, 0x8\n  0x40b107  mov     rax, qword [rdi+0xc8]\n  0x40b10e  test    rax, rax\n  0x40b111  je      0x40b170\n  0x40b170  mov     edx, dword [rdi+0xc4]\n  0x40b176  mov     rsi, qword [rel data_4235a0]\n  0x40b17d  mov     rdi, qword [rdi]\n  0x40b180  call    sub_40b040\n  0x40b185  jmp     0x40b113\n  0x40b113  mov     rdx, qword [r13+0xc8]\n  0x40b11a  mov     ebx, eax\n  0x40b11c  test    rdx, rdx\n  0x40b11f  je      0x40b150\n  0x40b150  mov     edx, dword [r13+0xc4]\n  0x40b157  mov     rdi, qword [r13]\n  0x40b15b  mov     rsi, qword [rel data_4235a0]\n  0x40b162  call    sub_40b040\n  0x40b167  mov     rdx, rax\n  0x40b16a  jmp     0x40b121\n  0x40b121  sub     ebx, edx\n  0x40b123  jne     0x40b140\n  0x40b140  add     rsp, 0x8\n  ... (140 bytes total, truncated)",
        "hlil": "uint64_t rax = arg1[0x19]\nif (rax == 0)\nrax = sub_40b040(*arg1, data_4235a0, *(arg1 + 0xc4))\nuint64_t rdx_1 = arg2[0x19]\nint32_t rbx = rax.d\nif (rdx_1 == 0)\nrdx_1 = sub_40b040(*arg2, data_4235a0, *(arg2 + 0xc4))\nif (rbx != rdx_1.d)\nreturn zx.q(rbx - rdx_1.d)\nreturn strcmp(*arg1, *arg2) __tailcall",
        "pseudoc": "{\n    uint64_t rax = arg1[0x19];\n    \n    if (!rax)\n        rax = sub_40b040(*(uint64_t*)arg1, data_4235a0, *(uint32_t*)((char*)arg1 + 0xc4));\n    \n    uint64_t rdx_1 = arg2[0x19];\n    int32_t rbx = (uint32_t)rax;\n    \n    if (!rdx_1)\n        rdx_1 = sub_40b040(*(uint64_t*)arg2, data_4235a0, *(uint32_t*)((char*)arg2 + 0xc4));\n    \n    if (rbx != (uint32_t)rdx_1)\n        return (uint64_t)(rbx - (uint32_t)rdx_1);\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg1, *(uint64_t*)arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_cached_string_compare",
          "confidence": 0.86,
          "rationale": "Function compares two objects by a cached numeric field (likely a hash or length) and falls back to strcmp if equal, indicating a cached string comparison routine.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x40b040",
            "call:0x4046c0"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_string_with_hash",
            "ai_string_compare_cached"
          ]
        },
        "explain": {
          "summary": "sub_40b0f0 implements a twostage comparison of two objects: it first compares a cached numeric value (or computes it via sub_40b040 if missing) and, if those values are equal, falls back to a lexical strcmp of the objects' string fields.",
          "details": [
            "Reads a 64bit field at offset 0x19 from each argument; if zero it calls sub_40b040 to compute a value using the object's primary pointer, a global (data_4235a0), and a field at offset 0xc4.",
            "If the numeric values differ, the function returns their difference; otherwise it returns the result of strcmp on the two objects' string pointers.",
            "The function imports strcmp and calls sub_40b040 (address 0x40b040) and strcmp (address 0x4046c0) as shown in the evidence."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x40b040",
            "call:0x4046c0",
            "constants:0x4235a0"
          ],
          "unknowns": [
            "Exact meaning of the field at offset 0x19 and the value returned by sub_40b040 (likely a hash or length).",
            "Purpose of the global data_4235a0 used in sub_40b040."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40b190",
      "original_name": "sub_40b190",
      "final_name": "ai_compare_struct_by_type_and_flag",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40b0f0",
          "name": "ai_cached_string_compare",
          "original_name": "sub_40b0f0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40b0f0"
      ],
      "snippets": {
        "asm": "  0x40b190  endbr64 \n  0x40b194  mov     eax, dword [rdi+0xa8]\n  0x40b19a  mov     ecx, dword [rsi+0xa8]\n  0x40b1a0  cmp     eax, 0x9\n  0x40b1a3  sete    dl\n  0x40b1a6  cmp     eax, 0x3\n  0x40b1a9  sete    al\n  0x40b1ac  or      edx, eax\n  0x40b1ae  cmp     ecx, 0x3\n  0x40b1b1  je      0x40b1e0\n  0x40b1e0  mov     eax, 0x1\n  0x40b1e5  test    dl, dl\n  0x40b1e7  je      0x40b1f0\n  0x40b1b3  cmp     ecx, 0x9\n  0x40b1b6  je      0x40b1e0\n  0x40b1f0  mov     edx, dword [rdi+0xac]\n  0x40b1f6  xor     ecx, ecx  {0x0}\n  0x40b1f8  and     edx, 0xf000\n  0x40b1fe  cmp     edx, 0x4000\n  0x40b204  sete    cl\n  0x40b207  sub     eax, ecx\n  0x40b209  jne     0x40b1db\n  0x40b1e9  jmp     sub_40b0f0\n  0x40b1b8  mov     eax, dword [rsi+0xac]\n  0x40b1be  mov     ecx, 0x1\n  0x40b1c3  and     eax, 0xf000\n  0x40b1c8  cmp     eax, 0x4000\n  0x40b1cd  sete    al\n  0x40b1d0  movzx   eax, al\n  0x40b1d3  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40b204:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40b204\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40b0f0(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40b204:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40b204;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40b0f0(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_by_type_and_flag",
          "confidence": 0.78,
          "rationale": "The function examines type fields at offset 0x15 and flag bits at offset 0xac of two structures, performs conditional checks, and returns a comparison result or delegates to a deeper comparator, indicating it is a comparator for objects based on type and flag attributes.",
          "evidence_refs": [
            "call:0x40b0f0"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_objects",
            "ai_struct_type_flag_cmp"
          ]
        },
        "explain": {
          "summary": "sub_40b190 compares two objects by inspecting a type field at offset 0x15 and a flag field at offset 0xac, returning a numeric difference if they differ, otherwise delegating to sub_40b0f0 for deeper comparison. It handles special type values 3 and 9, checks a high-order nibble mask (0xf000) against 0x4000, and uses the result to decide whether to return early or call the secondary comparator.",
          "details": [
            "Reads a 32-bit value at offset 0x15 from each argument and checks for values 3 or 9, setting a combined flag rdx_1.",
            "If either argument has type 3 or 9, it sets a default result of 1 and may compare the masked flag at offset 0xac against this result.",
            "If neither argument has those types, it extracts the flag bit from arg2's offset 0xac, compares it to the flag from arg1, and may return the difference.",
            "When no early return occurs, it tail-calls sub_40b0f0, which further compares other fields and finally performs a strcmp on string pointers."
          ],
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40b0f0"
          ],
          "unknowns": [
            "Exact semantics of the fields at offsets 0x15 and 0xac",
            "Purpose of the type values 3 and 9 in the broader application"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40b210",
      "original_name": "sub_40b210",
      "final_name": "ai_compare_struct_cached_key_strcoll",
      "score": 45.9,
      "bb_count": 7,
      "insn_est": 48,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x4235a0",
        "0x40b040",
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40b210  endbr64 \n  0x40b214  push    rbp {__saved_rbp}\n  0x40b215  mov     rbp, rsp {__saved_rbp}\n  0x40b218  push    r13 {__saved_r13}\n  0x40b21a  mov     r13, rdi\n  0x40b21d  push    r12 {__saved_r12}\n  0x40b21f  mov     r12, rsi\n  0x40b222  push    rbx {__saved_rbx}\n  0x40b223  sub     rsp, 0x8\n  0x40b227  mov     rax, qword [rdi+0xc8]\n  0x40b22e  test    rax, rax\n  0x40b231  je      0x40b2a0\n  0x40b2a0  mov     edx, dword [rdi+0xc4]\n  0x40b2a6  mov     rsi, qword [rel data_4235a0]\n  0x40b2ad  mov     rdi, qword [rdi]\n  0x40b2b0  call    sub_40b040\n  0x40b2b5  jmp     0x40b233\n  0x40b233  mov     rdx, qword [r12+0xc8]\n  0x40b23b  mov     ebx, eax\n  0x40b23d  test    rdx, rdx\n  0x40b240  je      0x40b280\n  0x40b280  mov     edx, dword [r12+0xc4]\n  0x40b288  mov     rdi, qword [r12]\n  0x40b28c  mov     rsi, qword [rel data_4235a0]\n  0x40b293  call    sub_40b040\n  0x40b298  mov     rdx, rax\n  0x40b29b  jmp     0x40b242\n  0x40b242  sub     ebx, edx\n  0x40b244  jne     0x40b270\n  0x40b270  add     rsp, 0x8\n  ... (162 bytes total, truncated)",
        "hlil": "uint64_t rax = arg1[0x19]\nif (rax == 0)\nrax = sub_40b040(*arg1, data_4235a0, *(arg1 + 0xc4))\nuint64_t rdx_1 = arg2[0x19]\nint32_t rbx = rax.d\nif (rdx_1 == 0)\nrdx_1 = sub_40b040(*arg2, data_4235a0, *(arg2 + 0xc4))\nif (rbx != rdx_1.d)\nreturn zx.q(rbx - rdx_1.d)\nint32_t* rax_1 = __errno_location()\nchar* rbx_2 = *arg1\nchar* r12_1 = *arg2\n*rax_1 = 0\nreturn strcoll(rbx_2, r12_1) __tailcall",
        "pseudoc": "{\n    uint64_t rax = arg1[0x19];\n    \n    if (!rax)\n        rax = sub_40b040(*(uint64_t*)arg1, data_4235a0, *(uint32_t*)((char*)arg1 + 0xc4));\n    \n    uint64_t rdx_1 = arg2[0x19];\n    int32_t rbx = (uint32_t)rax;\n    \n    if (!rdx_1)\n        rdx_1 = sub_40b040(*(uint64_t*)arg2, data_4235a0, *(uint32_t*)((char*)arg2 + 0xc4));\n    \n    if (rbx != (uint32_t)rdx_1)\n        return (uint64_t)(rbx - (uint32_t)rdx_1);\n    \n    int32_t* rax_1 = __errno_location();\n    char* rbx_2 = *(uint64_t*)arg1;\n    char* r12_1 = *(uint64_t*)arg2;\n    *(uint32_t*)rax_1 = 0;\n    /* tailcall */\n    return strcoll(rbx_2, r12_1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_struct_cached_key_strcoll",
          "confidence": 0.86,
          "rationale": "The function compares two structures by a cached numeric field (offset 0x19), falling back to a locale-aware string comparison via strcoll, and resets errno. It acts as a comparator for objects with cached keys.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x40b040"
          ],
          "tags": [],
          "alt_names": [
            "ai_struct_string_compare",
            "ai_cached_key_string_compare"
          ]
        },
        "explain": {
          "summary": "The function implements a locale-aware string comparison with a cached collation key. It retrieves a cached value from each object, computes it via sub_40b040 if missing, compares the keys, and falls back to strcoll on the actual strings, resetting errno to zero before the final comparison.",
          "details": [
            "Reads a 64bit field at offset 0x19 from each argument; if zero, calls sub_40b040 to compute a value using the object's string pointer, a global table (data_4235a0), and a length at offset 0xc4.",
            "If the computed or cached values differ, returns their signed difference; otherwise clears errno via __errno_location and returns the result of strcoll on the two string pointers stored at the start of each structure."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x40b040",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantics of the value at offset 0x19 and the role of data_4235a0",
            "Precise structure layout of the arguments beyond the observed offsets"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40b2c0",
      "original_name": "sub_40b2c0",
      "final_name": "ai_type_flag_comparator",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40b210",
          "name": "ai_compare_struct_cached_key_strcoll",
          "original_name": "sub_40b210"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40b210"
      ],
      "snippets": {
        "asm": "  0x40b2c0  endbr64 \n  0x40b2c4  mov     eax, dword [rdi+0xa8]\n  0x40b2ca  mov     ecx, dword [rsi+0xa8]\n  0x40b2d0  cmp     eax, 0x9\n  0x40b2d3  sete    dl\n  0x40b2d6  cmp     eax, 0x3\n  0x40b2d9  sete    al\n  0x40b2dc  or      edx, eax\n  0x40b2de  cmp     ecx, 0x3\n  0x40b2e1  je      0x40b310\n  0x40b310  mov     eax, 0x1\n  0x40b315  test    dl, dl\n  0x40b317  je      0x40b320\n  0x40b2e3  cmp     ecx, 0x9\n  0x40b2e6  je      0x40b310\n  0x40b320  mov     edx, dword [rdi+0xac]\n  0x40b326  xor     ecx, ecx  {0x0}\n  0x40b328  and     edx, 0xf000\n  0x40b32e  cmp     edx, 0x4000\n  0x40b334  sete    cl\n  0x40b337  sub     eax, ecx\n  0x40b339  jne     0x40b30b\n  0x40b319  jmp     sub_40b210\n  0x40b2e8  mov     eax, dword [rsi+0xac]\n  0x40b2ee  mov     ecx, 0x1\n  0x40b2f3  and     eax, 0xf000\n  0x40b2f8  cmp     eax, 0x4000\n  0x40b2fd  sete    al\n  0x40b300  movzx   eax, al\n  0x40b303  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40b334:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40b334\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40b210(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40b334:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40b334;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40b210(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_type_flag_comparator",
          "confidence": 0.78,
          "rationale": "The function checks type codes (3,9) and a flag mask (0xf000 == 0x4000) in two structures, returns a difference or falls back to a string collation via sub_40b210, indicating it is a comparator for sorting items based on type and flag.",
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40b210"
          ],
          "tags": [],
          "alt_names": [
            "ai_compare_by_type_and_flag",
            "ai_struct_comparator"
          ]
        },
        "explain": {
          "summary": "sub_40b2c0 checks specific type codes (3 or 9) and a flag in a 0xac field of two structures, returns a difference if they mismatch, otherwise forwards to sub_40b210 for a locale-aware string comparison.",
          "details": [
            "Reads a field at offset 0x15 from both arguments and sets a flag if either value equals 3 or 9.",
            "If arg2's type is 3 or 9, it sets a temporary result to 1; otherwise it derives the result from a masked check of arg2's 0xac field against 0x4000.",
            "When arg1's type is not 3 or 9, it also checks arg1's 0xac field against 0x4000 and returns the difference between the two flag results.",
            "If all checks pass, it tailcalls sub_40b210, which ultimately calls strcoll to compare string data from the two objects."
          ],
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x4000",
            "call:0x40b210"
          ],
          "unknowns": [
            "Exact semantics of the structures pointed to by arg1 and arg2",
            "Why the specific type values 3 and 9 are significant",
            "The meaning of the flag stored at offset 0xac"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40b340",
      "original_name": "sub_40b340",
      "final_name": "ai_cached_strcoll_compare",
      "score": 45.9,
      "bb_count": 7,
      "insn_est": 48,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404b60",
          "name": "ai_string_collate_wrapper",
          "original_name": "strcoll"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strcoll"
      ],
      "string_refs": [],
      "constants": [
        "0x4235a0",
        "0x40b040",
        "0x404760",
        "0x404b60"
      ],
      "snippets": {
        "asm": "  0x40b340  endbr64 \n  0x40b344  push    rbp {__saved_rbp}\n  0x40b345  mov     rbp, rsp {__saved_rbp}\n  0x40b348  push    r13 {__saved_r13}\n  0x40b34a  mov     r13, rsi\n  0x40b34d  push    r12 {__saved_r12}\n  0x40b34f  mov     r12, rdi\n  0x40b352  push    rbx {__saved_rbx}\n  0x40b353  sub     rsp, 0x8\n  0x40b357  mov     rax, qword [rsi+0xc8]\n  0x40b35e  test    rax, rax\n  0x40b361  je      0x40b3d0\n  0x40b3d0  mov     edx, dword [rsi+0xc4]\n  0x40b3d6  mov     rdi, qword [rsi]\n  0x40b3d9  mov     rsi, qword [rel data_4235a0]\n  0x40b3e0  call    sub_40b040\n  0x40b3e5  jmp     0x40b363\n  0x40b363  mov     rdx, qword [r12+0xc8]\n  0x40b36b  mov     ebx, eax\n  0x40b36d  test    rdx, rdx\n  0x40b370  je      0x40b3b0\n  0x40b3b0  mov     edx, dword [r12+0xc4]\n  0x40b3b8  mov     rdi, qword [r12]\n  0x40b3bc  mov     rsi, qword [rel data_4235a0]\n  0x40b3c3  call    sub_40b040\n  0x40b3c8  mov     rdx, rax\n  0x40b3cb  jmp     0x40b372\n  0x40b372  sub     ebx, edx\n  0x40b374  jne     0x40b3a0\n  0x40b3a0  add     rsp, 0x8\n  ... (162 bytes total, truncated)",
        "hlil": "uint64_t rax = arg2[0x19]\nif (rax == 0)\nrax = sub_40b040(*arg2, data_4235a0, *(arg2 + 0xc4))\nuint64_t rdx_1 = arg1[0x19]\nint32_t rbx = rax.d\nif (rdx_1 == 0)\nrdx_1 = sub_40b040(*arg1, data_4235a0, *(arg1 + 0xc4))\nif (rbx != rdx_1.d)\nreturn zx.q(rbx - rdx_1.d)\nint32_t* rax_1 = __errno_location()\nchar* rbx_2 = *arg2\nchar* r12_1 = *arg1\n*rax_1 = 0\nreturn strcoll(rbx_2, r12_1) __tailcall",
        "pseudoc": "{\n    uint64_t rax = arg2[0x19];\n    \n    if (!rax)\n        rax = sub_40b040(*(uint64_t*)arg2, data_4235a0, *(uint32_t*)((char*)arg2 + 0xc4));\n    \n    uint64_t rdx_1 = arg1[0x19];\n    int32_t rbx = (uint32_t)rax;\n    \n    if (!rdx_1)\n        rdx_1 = sub_40b040(*(uint64_t*)arg1, data_4235a0, *(uint32_t*)((char*)arg1 + 0xc4));\n    \n    if (rbx != (uint32_t)rdx_1)\n        return (uint64_t)(rbx - (uint32_t)rdx_1);\n    \n    int32_t* rax_1 = __errno_location();\n    char* rbx_2 = *(uint64_t*)arg2;\n    char* r12_1 = *(uint64_t*)arg1;\n    *(uint32_t*)rax_1 = 0;\n    /* tailcall */\n    return strcoll(rbx_2, r12_1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_cached_strcoll_compare",
          "confidence": 0.92,
          "rationale": "Function compares two objects using a cached value; if missing, computes it via sub_40b040, then falls back to locale-aware string comparison using strcoll, resetting errno. Indicates a cached string comparison routine.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x40b040"
          ],
          "tags": [],
          "alt_names": [
            "ai_strcoll_with_cache",
            "ai_locale_string_compare"
          ]
        },
        "explain": {
          "summary": "The function compares two objects by first checking a cached integer at offset 0x19, computing it via sub_40b040 if missing, then returning the integer difference; if the integers match it clears errno and performs a locale-aware string comparison using strcoll on the objects' primary string pointers.",
          "details": [
            "Reads a cached value at offset 0x19 from each argument; if zero, calls sub_40b040 with the object's base pointer, a global data pointer, and a field at offset 0xc4 to compute the value.",
            "If the computed/ cached integers differ, returns their signed difference.",
            "If they are equal, resets errno to 0 via __errno_location and returns the result of strcoll on the two objects' string pointers (first field of each structure)."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strcoll",
            "call:0x40b040",
            "call:0x404760",
            "call:0x404b60"
          ],
          "unknowns": [
            "Exact semantics of the integer at offset 0x19 and the computation performed by sub_40b040",
            "Structure layout and meaning of the field at offset 0xc4",
            "Purpose of the global constant at 0x4235a0"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40b3f0",
      "original_name": "sub_40b3f0",
      "final_name": "ai_compare_objects_by_type_and_flag",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40b340",
          "name": "ai_cached_strcoll_compare",
          "original_name": "sub_40b340"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40b340"
      ],
      "snippets": {
        "asm": "  0x40b3f0  endbr64 \n  0x40b3f4  mov     eax, dword [rdi+0xa8]\n  0x40b3fa  mov     ecx, dword [rsi+0xa8]\n  0x40b400  cmp     eax, 0x9\n  0x40b403  sete    dl\n  0x40b406  cmp     eax, 0x3\n  0x40b409  sete    al\n  0x40b40c  or      edx, eax\n  0x40b40e  cmp     ecx, 0x3\n  0x40b411  je      0x40b440\n  0x40b440  mov     eax, 0x1\n  0x40b445  test    dl, dl\n  0x40b447  je      0x40b450\n  0x40b413  cmp     ecx, 0x9\n  0x40b416  je      0x40b440\n  0x40b450  mov     edx, dword [rdi+0xac]\n  0x40b456  xor     ecx, ecx  {0x0}\n  0x40b458  and     edx, 0xf000\n  0x40b45e  cmp     edx, 0x4000\n  0x40b464  sete    cl\n  0x40b467  sub     eax, ecx\n  0x40b469  jne     0x40b43b\n  0x40b449  jmp     sub_40b340\n  0x40b418  mov     eax, dword [rsi+0xac]\n  0x40b41e  mov     ecx, 0x1\n  0x40b423  and     eax, 0xf000\n  0x40b428  cmp     eax, 0x4000\n  0x40b42d  sete    al\n  0x40b430  movzx   eax, al\n  0x40b433  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40b464:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40b464\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40b340(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40b464:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40b464;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40b340(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_objects_by_type_and_flag",
          "confidence": 0.78,
          "rationale": "The function checks type fields (offset 0x15) and flag bits (mask 0xf000) of two structures, returns a comparison result, and falls back to a string collation via sub_40b340, indicating it is a comparator for objects based on type, flag, and name.",
          "evidence_refs": [
            "call:0x40b340"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_struct_type_comparator",
            "ai_entry_sort_key"
          ]
        },
        "explain": {
          "summary": "sub_40b3f0 compares two objects by first checking a type field at offset 0x15 for values 3 or 9, then examining a flag in the word at offset 0xac masked with 0xf000 against the constant 0x4000. If the preliminary checks differ, it returns a numeric ordering based on those differences; otherwise it delegates to sub_40b340 which performs a string collation comparison.",
          "details": [
            "The function reads arg1[0x15] and arg2[0x15] and sets flags when they equal 3 or 9.",
            "It extracts bits from *(uint32_t*)(argX + 0xac) using mask 0xf000 and compares the result to 0x4000.",
            "If the type/flag conditions mismatch, it returns the difference of the evaluated flags.",
            "When the preliminary checks pass, it tailcalls sub_40b340 to compare string data of the two objects."
          ],
          "evidence_refs": [
            "call:0x40b340",
            "constants:0xf000",
            "constants:0x4000"
          ],
          "unknowns": [
            "Exact semantic meaning of the structures pointed to by arg1 and arg2",
            "Why the specific type values 3 and 9 are significant"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40b470",
      "original_name": "sub_40b470",
      "final_name": "ai_string_compare_cached_hash",
      "score": 38.2,
      "bb_count": 7,
      "insn_est": 44,
      "callers": 1,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        }
      ],
      "import_refs": [
        "strcmp"
      ],
      "string_refs": [],
      "constants": [
        "0x4235a0",
        "0x40b040",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x40b470  endbr64 \n  0x40b474  push    rbp {__saved_rbp}\n  0x40b475  mov     rbp, rsp {__saved_rbp}\n  0x40b478  push    r13 {__saved_r13}\n  0x40b47a  mov     r13, rdi\n  0x40b47d  push    r12 {__saved_r12}\n  0x40b47f  mov     r12, rsi\n  0x40b482  push    rbx {__saved_rbx}\n  0x40b483  sub     rsp, 0x8\n  0x40b487  mov     rax, qword [rsi+0xc8]\n  0x40b48e  test    rax, rax\n  0x40b491  je      0x40b4f0\n  0x40b4f0  mov     edx, dword [rsi+0xc4]\n  0x40b4f6  mov     rdi, qword [rsi]\n  0x40b4f9  mov     rsi, qword [rel data_4235a0]\n  0x40b500  call    sub_40b040\n  0x40b505  jmp     0x40b493\n  0x40b493  mov     rdx, qword [r13+0xc8]\n  0x40b49a  mov     ebx, eax\n  0x40b49c  test    rdx, rdx\n  0x40b49f  je      0x40b4d0\n  0x40b4d0  mov     edx, dword [r13+0xc4]\n  0x40b4d7  mov     rdi, qword [r13]\n  0x40b4db  mov     rsi, qword [rel data_4235a0]\n  0x40b4e2  call    sub_40b040\n  0x40b4e7  mov     rdx, rax\n  0x40b4ea  jmp     0x40b4a1\n  0x40b4a1  sub     ebx, edx\n  0x40b4a3  jne     0x40b4c0\n  0x40b4c0  add     rsp, 0x8\n  ... (140 bytes total, truncated)",
        "hlil": "uint64_t rax = arg2[0x19]\nif (rax == 0)\nrax = sub_40b040(*arg2, data_4235a0, *(arg2 + 0xc4))\nuint64_t rdx_1 = arg1[0x19]\nint32_t rbx = rax.d\nif (rdx_1 == 0)\nrdx_1 = sub_40b040(*arg1, data_4235a0, *(arg1 + 0xc4))\nif (rbx != rdx_1.d)\nreturn zx.q(rbx - rdx_1.d)\nreturn strcmp(*arg2, *arg1) __tailcall",
        "pseudoc": "{\n    uint64_t rax = arg2[0x19];\n    \n    if (!rax)\n        rax = sub_40b040(*(uint64_t*)arg2, data_4235a0, *(uint32_t*)((char*)arg2 + 0xc4));\n    \n    uint64_t rdx_1 = arg1[0x19];\n    int32_t rbx = (uint32_t)rax;\n    \n    if (!rdx_1)\n        rdx_1 = sub_40b040(*(uint64_t*)arg1, data_4235a0, *(uint32_t*)((char*)arg1 + 0xc4));\n    \n    if (rbx != (uint32_t)rdx_1)\n        return (uint64_t)(rbx - (uint32_t)rdx_1);\n    \n    /* tailcall */\n    return strcmp(*(uint64_t*)arg2, *(uint64_t*)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_string_compare_cached_hash",
          "confidence": 0.86,
          "rationale": "The function compares two objects by first checking a cached hash field (offset 0x19), computing it via sub_40b040 if missing, then falling back to strcmp on the string pointers. This behavior matches a cached string comparison routine.",
          "evidence_refs": [
            "imports:strcmp",
            "call:0x40b040",
            "call:0x4046c0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_compare_strings_by_hash",
            "ai_cached_string_cmp"
          ]
        },
        "explain": {
          "summary": "sub_40b470 implements a two-stage comparison of two objects. It first checks a cached numeric field at offset 0x19; if missing it computes the value via sub_40b040 using a global table and a size field. If the numeric values differ, it returns their difference; otherwise it falls back to a lexical string comparison using strcmp on the objects' name pointers.",
          "details": [
            "Reads a 64bit field at offset 0x19 from each argument; if zero, calls sub_40b040 with the object's base pointer, a global data pointer (0x4235a0), and a size field at offset 0xc4 to compute a fallback value.",
            "Compares the resulting 32bit values; a nonzero difference is returned directly, providing a primary ordering key.",
            "When the primary keys are equal, the function delegates to strcmp on the first pointer of each object, providing a secondary alphabetical ordering."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "call:0x40b040",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact semantics of the field at offset 0x19 and the value returned by sub_40b040 (likely a hash or length)",
            "Purpose of the global constant at 0x4235a0"
          ],
          "confidence": 0.88
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40b510",
      "original_name": "sub_40b510",
      "final_name": "ai_compare_entries_by_type_flag",
      "score": 27.5,
      "bb_count": 9,
      "insn_est": 35,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40b470",
          "name": "ai_string_compare_cached_hash",
          "original_name": "sub_40b470"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x4000",
        "0x40b470"
      ],
      "snippets": {
        "asm": "  0x40b510  endbr64 \n  0x40b514  mov     eax, dword [rdi+0xa8]\n  0x40b51a  mov     ecx, dword [rsi+0xa8]\n  0x40b520  cmp     eax, 0x9\n  0x40b523  sete    dl\n  0x40b526  cmp     eax, 0x3\n  0x40b529  sete    al\n  0x40b52c  or      edx, eax\n  0x40b52e  cmp     ecx, 0x3\n  0x40b531  je      0x40b560\n  0x40b560  mov     eax, 0x1\n  0x40b565  test    dl, dl\n  0x40b567  je      0x40b570\n  0x40b533  cmp     ecx, 0x9\n  0x40b536  je      0x40b560\n  0x40b570  mov     edx, dword [rdi+0xac]\n  0x40b576  xor     ecx, ecx  {0x0}\n  0x40b578  and     edx, 0xf000\n  0x40b57e  cmp     edx, 0x4000\n  0x40b584  sete    cl\n  0x40b587  sub     eax, ecx\n  0x40b589  jne     0x40b55b\n  0x40b569  jmp     sub_40b470\n  0x40b538  mov     eax, dword [rsi+0xac]\n  0x40b53e  mov     ecx, 0x1\n  0x40b543  and     eax, 0xf000\n  0x40b548  cmp     eax, 0x4000\n  0x40b54d  sete    al\n  0x40b550  movzx   eax, al\n  0x40b553  test    dl, dl\n  ... (119 bytes total, truncated)",
        "hlil": "int32_t rax = arg1[0x15].d\nint32_t rcx = arg2[0x15].d\nbool rdx = rax == 9\nrax.b = rax == 3\nchar rdx_1 = rdx | rax.b\nuint32_t rax_3\nif (rcx == 3 || rcx == 9)\nrax_3 = 1\nif (rdx_1 == 0)\nlabel_40b584:\nint32_t rcx_2\nrcx_2.b = (*(arg1 + 0xac) & 0xf000) == 0x4000\nif (rax_3 != rcx_2)\nreturn zx.q(rax_3 - rcx_2)\nint32_t rax_2\nrax_2.b = (*(arg2 + 0xac) & 0xf000) == 0x4000\nrax_3 = zx.d(rax_2.b)\nif (rdx_1 == 0)\ngoto label_40b584\nif (rax_3 != 1)\nreturn zx.q(rax_3 - 1)\nreturn sub_40b470(arg1, arg2) __tailcall",
        "pseudoc": "{\n    int32_t rax = arg1[0x15];\n    int32_t rcx = arg2[0x15];\n    bool rdx = rax == 9;\n    (uint8_t)rax = rax == 3;\n    char rdx_1 = rdx | (uint8_t)rax;\n    uint32_t rax_3;\n    \n    if (rcx == 3 || rcx == 9)\n    {\n        rax_3 = 1;\n        \n        if (!rdx_1)\n        {\n        label_40b584:\n            int32_t rcx_2;\n            (uint8_t)rcx_2 = (*(uint32_t*)((char*)arg1 + 0xac) & 0xf000) == 0x4000;\n            \n            if (rax_3 != rcx_2)\n                return (uint64_t)(rax_3 - rcx_2);\n        }\n    }\n    else\n    {\n        int32_t rax_2;\n        (uint8_t)rax_2 = (*(uint32_t*)((char*)arg2 + 0xac) & 0xf000) == 0x4000;\n        rax_3 = (uint32_t)(uint8_t)rax_2;\n        \n        if (!rdx_1)\n            goto label_40b584;\n        \n        if (rax_3 != 1)\n            return (uint64_t)(rax_3 - 1);\n    }\n    /* tailcall */\n    return sub_40b470(arg1, arg2);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compare_entries_by_type_flag",
          "confidence": 0.78,
          "rationale": "The function checks type fields and a flag mask in two structures, returns a comparison result, and falls back to a string compare, indicating it is a comparator for entries based on type and attribute flags.",
          "evidence_refs": [
            "call:0x40b470"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_entry_compare",
            "ai_struct_compare"
          ]
        },
        "explain": {
          "summary": "sub_40b510 validates two objects by checking specific type codes (3 or 9) and a masked flag field at offset 0xAC against the constant 0x4000, returning a difference if they mismatch; otherwise it forwards the comparison to sub_40b470 for further checks.",
          "details": [
            "Reads a byte at offset 0x15 from both arguments and sets flags based on values 3 and 9.",
            "If either argument has type 3 or 9, it checks whether the high nibble of the dword at offset 0xAC equals 0x4000 and compares this flag between the two objects.",
            "When the type codes are not 3 or 9, it directly compares the masked flag of arg2 against the same constant.",
            "If all preliminary checks pass, it tailcalls sub_40b470, which performs additional comparisons (including a possible string compare)."
          ],
          "evidence_refs": [
            "call:0x40b470"
          ],
          "unknowns": [
            "Exact semantic meaning of the fields at offsets 0x15 and 0xAC",
            "Purpose of the constants 0xf000 and 0x4000 in the broader application"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40b590",
      "original_name": "sub_40b590",
      "final_name": "ai_ensure_capacity",
      "score": 97.0,
      "bb_count": 14,
      "insn_est": 90,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        },
        {
          "addr": "0x4168e0",
          "name": "ai_compute_bucket_capacity",
          "original_name": "sub_4168e0"
        },
        {
          "addr": "0x404a50",
          "name": "ai_calloc_wrapper",
          "original_name": "calloc"
        },
        {
          "addr": "0x409b80",
          "name": "ai_hash_table_insert",
          "original_name": "sub_409b80"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x409b80",
          "name": "ai_hash_table_insert",
          "original_name": "sub_409b80"
        },
        {
          "addr": "0x409b80",
          "name": "ai_hash_table_insert",
          "original_name": "sub_409b80"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "abort",
        "calloc",
        "__errno_location",
        "free",
        "free",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x4168e0",
        "0x4048f0",
        "0x404a50",
        "0x409b80",
        "0x4046b0",
        "0x404760",
        "0x404750"
      ],
      "snippets": {
        "asm": "  0x40b590  push    rbp {__saved_rbp}\n  0x40b591  mov     rbp, rsp {__saved_rbp}\n  0x40b594  push    r14 {__saved_r14}\n  0x40b596  push    r13 {__saved_r13}\n  0x40b598  push    r12 {__saved_r12}\n  0x40b59a  push    rbx {__saved_rbx}\n  0x40b59b  mov     rbx, rdi\n  0x40b59e  mov     rdi, rsi\n  0x40b5a1  sub     rsp, 0x60\n  0x40b5a5  mov     r13, qword [rbx+0x28]\n  0x40b5a9  mov     rax, qword [fs:0x28]\n  0x40b5b2  mov     qword [rbp-0x28 {var_30}], rax\n  0x40b5b6  xor     eax, eax  {0x0}\n  0x40b5b8  movzx   esi, byte [r13+0x10]\n  0x40b5bd  movss   xmm0, dword [r13+0x8]\n  0x40b5c3  call    sub_4168e0\n  0x40b5c8  test    rax, rax\n  0x40b5cb  je      0x40b696\n  0x40b696  xor     eax, eax  {0x0}\n  0x40b5d1  mov     r12, rax\n  0x40b5d4  cmp     qword [rbx+0x10], rax\n  0x40b5d8  je      0x40b6d9\n  0x40b6e0  call    __stack_chk_fail\n  0x40b6e0  { Does not return }\n  0x40b6a7  add     rsp, 0x60\n  0x40b6ab  pop     rbx {__saved_rbx}\n  0x40b6ac  pop     r12 {__saved_r12}\n  0x40b6ae  pop     r13 {__saved_r13}\n  0x40b6b0  pop     r14 {__saved_r14}\n  0x40b6b2  pop     rbp {__saved_rbp}\n  ... (342 bytes total, truncated)",
        "hlil": "void* r13 = arg1[5]\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nsize_t nmemb = sub_4168e0(arg2, *(r13 + 0x10), *(r13 + 8))\nint64_t result\nif (nmemb == 0)\nresult = 0\nif (arg1[2] == nmemb)\nresult = 1\nint64_t rax_2 = calloc(nmemb, 0x10)\nint64_t var_88 = rax_2\nif (rax_2 == 0)\nresult = 0\nint64_t var_70_1 = 0\nint64_t var_80_1 = rax_2 + (nmemb << 4)\nint64_t var_68_1 = 0\nint64_t var_48_1 = arg1[8]\nint64_t rax_5 = arg1[9]\nvoid* var_60_1 = r13\nint128_t var_58_1 = *(arg1 + 0x30)\nif (sub_409b80(&var_88, arg1, 0) != 0)\nfree(*arg1)\nint128_t zmm2_1 = var_88.o\narg1[9] = rax_5\n*arg1 = zmm2_1\n*(arg1 + 0x10) = nmemb.o\nresult = 1\nint32_t* rax_7 = __errno_location()\nint32_t r14_1 = *rax_7\narg1[9] = rax_5\nchar rax_9 = sub_409b80(arg1, &var_88, 1)\nchar rax_10\nif (rax_9 != 0)\nrax_10 = sub_409b80(arg1, &var_88, 0)\nif (rax_9 == 0 || rax_10 == 0)\nabort()\nnoreturn\nfree(var_88)\n*rax_7 = r14_1\nresult = 0\n// ... truncated",
        "pseudoc": "{\n    void* r13 = arg1[5];\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    size_t nmemb = sub_4168e0(arg2, *(uint8_t*)((char*)r13 + 0x10), *(uint32_t*)((char*)r13 + 8));\n    int64_t result;\n    \n    if (!nmemb)\n        result = 0;\n    else if (arg1[2] == nmemb)\n        result = 1;\n    else\n    {\n        int64_t rax_2 = calloc(nmemb, 0x10);\n        int64_t var_88 = rax_2;\n        \n        if (!rax_2)\n            result = 0;\n        else\n        {\n            int64_t var_70_1 = 0;\n            int64_t var_80_1 = rax_2 + (nmemb << 4);\n            int64_t var_68_1 = 0;\n            int64_t var_48_1 = arg1[8];\n            int64_t rax_5 = arg1[9];\n            void* var_60_1 = r13;\n            int128_t var_58_1 = *(uint128_t*)((char*)arg1 + 0x30);\n            \n            if (sub_409b80(&var_88, arg1, 0))\n            {\n                free(*(uint64_t*)arg1);\n                int128_t zmm2_1 = var_88;\n                arg1[9] = rax_5;\n                *(uint128_t*)arg1 = zmm2_1;\n                *(uint128_t*)((char*)arg1 + 0x10) = nmemb;\n                result = 1;\n            }\n            else\n            {\n                int32_t* rax_7 = __errno_location();\n                int32_t r14_1 = *(uint32_t*)rax_7;\n                arg1[9] = rax_5;\n                char rax_9 = sub_409b80(arg1, &var_88, 1);\n                char rax_10;\n                \n                if (rax_9)\n                    rax_10 = sub_409b80(arg1, &var_88, 0);\n                \n                if (!rax_9 || !rax_10)\n                {\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_ensure_capacity",
          "confidence": 0.78,
          "rationale": "The function calculates a required element count, allocates a new buffer with calloc, copies existing data, frees old memory, and updates structure fields, typical of a dynamic array resize or capacity ensure routine.",
          "evidence_refs": [
            "imports:calloc",
            "imports:free",
            "imports:abort",
            "call:0x4168e0",
            "call:0x409b80"
          ],
          "tags": [],
          "alt_names": [
            "ai_grow_vector",
            "ai_resize_buffer"
          ]
        },
        "explain": {
          "summary": "sub_40b590 resizes a container by computing a required element count, allocating a new buffer with calloc, copying existing data via sub_409b80, freeing the old buffer, and updating the container's metadata; it returns success if the new allocation and copy succeed, otherwise it handles errors and may abort.",
          "details": [
            "Calls sub_4168e0 to compute the number of elements (nmemb) needed based on input arguments.",
            "If the computed size is zero, the function returns failure; if it matches the current size stored in arg1[2], it returns success without changes.",
            "Otherwise it allocates a new buffer of nmemb * 0x10 bytes using calloc.",
            "On successful allocation, it attempts to copy existing data into the new buffer via sub_409b80; if successful, it frees the old buffer, updates the structure fields (pointer, size, and other saved values), and returns success.",
            "If any step fails, it retrieves errno, may attempt cleanup or rollback, and ultimately returns failure (potentially invoking abort on critical errors)."
          ],
          "evidence_refs": [
            "imports:calloc",
            "imports:free",
            "imports:__errno_location",
            "imports:abort",
            "calls:0x4168e0",
            "calls:0x409b80"
          ],
          "unknowns": [
            "Exact semantics of sub_4168e0 and sub_409b80 (how they compute size and perform copying)",
            "Precise layout and meaning of the fields in the arg1 structure",
            "Conditions under which abort is triggered"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40b6f0",
      "original_name": "sub_40b6f0",
      "final_name": "ai_flush_and_close_file",
      "score": 122.2,
      "bb_count": 17,
      "insn_est": 79,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404b00",
          "name": "ai_get_fileno",
          "original_name": "fileno"
        },
        {
          "addr": "0x404b80",
          "name": "ai_file_is_reading",
          "original_name": "__freading"
        },
        {
          "addr": "0x404b80",
          "name": "ai_file_is_reading",
          "original_name": "__freading"
        },
        {
          "addr": "0x404b40",
          "name": "ai_flush_file_stream",
          "original_name": "fflush"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404870",
          "name": "ai_close_file",
          "original_name": "fclose"
        },
        {
          "addr": "0x404b00",
          "name": "ai_get_fileno",
          "original_name": "fileno"
        },
        {
          "addr": "0x404990",
          "name": "ai_file_seek",
          "original_name": "lseek"
        },
        {
          "addr": "0x404870",
          "name": "ai_close_file",
          "original_name": "fclose"
        },
        {
          "addr": "0x404c40",
          "name": "ai_file_seek",
          "original_name": "fseeko"
        },
        {
          "addr": "0x404b00",
          "name": "ai_get_fileno",
          "original_name": "fileno"
        },
        {
          "addr": "0x404990",
          "name": "ai_file_seek",
          "original_name": "lseek"
        }
      ],
      "import_refs": [
        "fileno",
        "__freading",
        "__freading",
        "fflush",
        "__errno_location",
        "fclose",
        "fileno",
        "lseek",
        "fclose",
        "fseeko",
        "fileno",
        "lseek"
      ],
      "string_refs": [],
      "constants": [
        "0x404b00",
        "0x404870",
        "0x404b80",
        "0x404990",
        "0x100",
        "0x404b40",
        "0x404760",
        "0x404c40",
        "0xffffffff",
        "0xffffffef"
      ],
      "snippets": {
        "asm": "  0x40b6f0  push    rbp {__saved_rbp}\n  0x40b6f1  mov     rbp, rsp {__saved_rbp}\n  0x40b6f4  push    r13 {__saved_r13}\n  0x40b6f6  push    r12 {__saved_r12}\n  0x40b6f8  push    rbx {__saved_rbx}\n  0x40b6f9  mov     rbx, rdi\n  0x40b6fc  sub     rsp, 0x8\n  0x40b700  call    fileno\n  0x40b705  mov     rdi, rbx\n  0x40b708  test    eax, eax\n  0x40b70a  js      0x40b777\n  0x40b777  add     rsp, 0x8\n  0x40b77b  pop     rbx {__saved_rbx}\n  0x40b77c  pop     r12 {__saved_r12}\n  0x40b77e  pop     r13 {__saved_r13}\n  0x40b780  pop     rbp {__saved_rbp}\n  0x40b781  jmp     fclose\n  0x40b70c  call    __freading\n  0x40b711  test    eax, eax\n  0x40b713  jne     0x40b758\n  0x40b758  mov     rdi, rbx\n  0x40b75b  call    fileno\n  0x40b760  xor     esi, esi  {0x0}\n  0x40b762  mov     edx, 0x1\n  0x40b767  mov     edi, eax\n  0x40b769  call    lseek\n  0x40b76e  cmp     rax, 0xffffffffffffffff\n  0x40b772  jne     0x40b715\n  0x40b715  mov     rdi, rbx\n  0x40b718  call    __freading\n  ... (262 bytes total, truncated)",
        "hlil": "FILE* fp = arg1\nif (fileno(arg1) s>= 0)\nint32_t rax_1 = __freading(fp)\noff64_t rax_6\nif (rax_1 != 0)\nrax_6 = lseek(fileno(arg1), 0, 1)\nif (rax_1 == 0 || rax_6 != -1)\nif (__freading(arg1) != 0 && (arg1->_flags & 0x100) != 0)\nif (arg1->_IO_read_end == arg1->_IO_read_ptr && arg1->_IO_write_ptr == arg1->_IO_write_base && arg1->_IO_save_base == 0)\nint64_t rax_11 = lseek(fileno(arg1), 0, 1)\nif (rax_11 != -1)\narg1->_flags &= 0xffffffef\narg1->_offset = rax_11\nfseeko(arg1, 0, 1)\nif (fflush(arg1) != 0)\nint32_t* rax_4 = __errno_location()\nint32_t r13 = *rax_4\nint64_t result = fclose(arg1)\nif (r13 == 0)\nreturn result\n*rax_4 = r13\nreturn 0xffffffff\nfp = arg1\nreturn fclose(fp) __tailcall",
        "pseudoc": "{\n    FILE* fp = arg1;\n    \n    if (fileno(arg1) >= 0)\n    {\n        int32_t rax_1 = __freading(fp);\n        off64_t rax_6;\n        \n        if (rax_1)\n            rax_6 = lseek(fileno(arg1), 0, 1);\n        \n        if (!rax_1 || rax_6 != -1)\n        {\n            if (__freading(arg1) && arg1->_flags & 0x100)\n            {\n                if (arg1->_IO_read_end == arg1->_IO_read_ptr\n                    && arg1->_IO_write_ptr == arg1->_IO_write_base && !arg1->_IO_save_base)\n                {\n                    int64_t rax_11 = lseek(fileno(arg1), 0, 1);\n                    \n                    if (rax_11 != -1)\n                    {\n                        arg1->_flags &= 0xffffffef;\n                        arg1->_offset = rax_11;\n                    }\n                }\n                else\n                    fseeko(arg1, 0, 1);\n            }\n            \n            if (fflush(arg1))\n            {\n                int32_t* rax_4 = __errno_location();\n                int32_t r13 = *(uint32_t*)rax_4;\n                int64_t result = fclose(arg1);\n                \n                if (!r13)\n                    return result;\n                \n                *(uint32_t*)rax_4 = r13;\n                return 0xffffffff;\n            }\n        }\n        \n        fp = arg1;\n    }\n    \n    /* tailcall */\n    return fclose(fp);\n}\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_flush_and_close_file",
          "confidence": 0.88,
          "rationale": "The function checks file descriptor validity, flushes pending output, adjusts file offset for reading streams, and finally calls fclose, handling errors. It implements a safe flush-and-close routine for FILE* objects.",
          "evidence_refs": [
            "imports:fileno",
            "imports:__freading",
            "imports:fflush",
            "imports:__errno_location",
            "imports:fclose",
            "imports:lseek",
            "imports:fseeko"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_safe_fclose",
            "ai_file_flush_close"
          ]
        },
        "explain": {
          "summary": "sub_40b6f0 attempts to safely close a FILE* by first ensuring the file descriptor is valid, synchronizing the file position for reading streams, flushing pending output, and handling errors before finally calling fclose. It updates internal FILE state flags and offsets when appropriate, and restores errno on failure.",
          "details": [
            "Checks fileno(fp) >= 0 and uses __freading to determine if the stream is in read mode.",
            "If reading, obtains current file offset with lseek and, if internal buffers are empty, clears a flag (0x100) and updates the FILE->_offset field.",
            "If buffers are not empty, calls fseeko to synchronize the file position.",
            "Calls fflush(fp); on failure, retrieves errno, calls fclose(fp), and returns -1 (0xffffffff) while preserving errno.",
            "If all checks pass or flushing succeeds, directly tailcalls fclose(fp) to close the stream."
          ],
          "evidence_refs": [
            "imports:fileno",
            "imports:__freading",
            "imports:lseek",
            "imports:fseeko",
            "imports:fflush",
            "imports:__errno_location",
            "imports:fclose",
            "call:0x404b00",
            "call:0x404b80",
            "call:0x404b40",
            "call:0x404b70",
            "call:0x404b80"
          ],
          "unknowns": [
            "Exact semantics of the flag mask 0xffffffef and its impact on FILE internal state",
            "Why the function checks arg1->_IO_write_ptr == arg1->_IO_write_base and arg1->_IO_save_base conditions"
          ],
          "confidence": 0.94
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40b810",
      "original_name": "sub_40b810",
      "final_name": "ai_check_file_write_error",
      "score": 47.8,
      "bb_count": 8,
      "insn_est": 36,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4047b0",
          "name": "ai_check_file_pending",
          "original_name": "__fpending"
        },
        {
          "addr": "0x40b6f0",
          "name": "ai_flush_and_close_file",
          "original_name": "sub_40b6f0"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        }
      ],
      "import_refs": [
        "__fpending",
        "__errno_location",
        "__errno_location"
      ],
      "string_refs": [],
      "constants": [
        "0x4047b0",
        "0x40b6f0",
        "0xffffffff",
        "0x404760"
      ],
      "snippets": {
        "asm": "  0x40b810  push    rbp {__saved_rbp}\n  0x40b811  mov     rbp, rsp {__saved_rbp}\n  0x40b814  push    r13 {__saved_r13}\n  0x40b816  push    r12 {__saved_r12}\n  0x40b818  push    rbx {__saved_rbx}\n  0x40b819  mov     rbx, rdi\n  0x40b81c  sub     rsp, 0x8\n  0x40b820  call    __fpending\n  0x40b825  mov     r12d, dword [rbx]\n  0x40b828  mov     rdi, rbx\n  0x40b82b  mov     r13, rax\n  0x40b82e  and     r12d, 0x20\n  0x40b832  call    sub_40b6f0\n  0x40b837  test    r12d, r12d\n  0x40b83a  jne     0x40b860\n  0x40b860  test    eax, eax\n  0x40b862  jne     0x40b86f\n  0x40b83c  test    eax, eax\n  0x40b83e  je      0x40b855\n  0x40b86f  mov     eax, 0xffffffff\n  0x40b874  jmp     0x40b855\n  0x40b864  call    __errno_location\n  0x40b869  mov     dword [rax], 0x0\n  0x40b855  add     rsp, 0x8\n  0x40b859  pop     rbx {__saved_rbx}\n  0x40b85a  pop     r12 {__saved_r12}\n  0x40b85c  pop     r13 {__saved_r13}\n  0x40b85e  pop     rbp {__saved_rbp}\n  0x40b85f  retn     {__return_addr}\n  0x40b840  test    r13, r13\n  ... (102 bytes total, truncated)",
        "hlil": "int32_t* rbx = arg1\nuint64_t rax = __fpending(arg1)\nint32_t r12_1 = *rbx & 0x20\nint32_t result = sub_40b6f0(rbx)\nif (r12_1 == 0)\nif (result == 0)\nreturn result\nif (rax == 0)\nint32_t* rax_1\nrax_1.b = *__errno_location() != 9\nreturn neg.d(zx.d(rax_1.b))\nif (result == 0)\n*__errno_location() = 0\nreturn -1",
        "pseudoc": "{\n    int32_t* rbx = arg1;\n    uint64_t rax = __fpending(arg1);\n    int32_t r12_1 = *(uint32_t*)rbx & 0x20;\n    int32_t result = sub_40b6f0(rbx);\n    \n    if (!r12_1)\n    {\n        if (!result)\n            return result;\n        \n        if (!rax)\n        {\n            int32_t* rax_1;\n            (uint8_t)rax_1 = *(uint32_t*)__errno_location() != 9;\n            return -((uint32_t)(uint8_t)rax_1);\n        }\n    }\n    else if (!result)\n        *(uint32_t*)__errno_location() = 0;\n    \n    return -1;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_check_file_write_error",
          "confidence": 0.92,
          "rationale": "The function checks a FILE* stream for pending output, error flags, and errno to determine if a write error occurred, and is used by error handling for stdout/stderr.",
          "evidence_refs": [
            "imports:__fpending",
            "imports:__errno_location",
            "call:0x4047b0",
            "call:0x40b6f0",
            "call:0x404760"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_stdout_error_check",
            "ai_file_write_error_check"
          ]
        },
        "explain": {
          "summary": "sub_40b810 checks a FILE* for pending output and error conditions, invoking sub_40b6f0 to flush or sync the stream, then returns 0 on success or -1 on failure (with special handling for EAGAIN).",
          "details": [
            "Calls __fpending to get the number of pending output bytes for the file pointer.",
            "Inspects the FILE's flag 0x20 (likely the error flag) and calls sub_40b6f0 to perform flushing or state checks.",
            "If no error flag is set and sub_40b6f0 reports success, the function returns the result; otherwise it examines errno and returns -1 unless errno equals 9 (EAGAIN), in which case it returns 0.",
            "When the error flag is set and sub_40b6f0 reports no error, errno is cleared before returning -1."
          ],
          "evidence_refs": [
            "imports:__fpending",
            "imports:__errno_location",
            "call:0x40b6f0"
          ],
          "unknowns": [
            "Exact meaning of the FILE flag bit 0x20 in this context",
            "Full behavior of sub_40b6f0 beyond the provided snippet"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40b880",
      "original_name": "sub_40b880",
      "final_name": "ai_write_error_exit_handler",
      "score": 68.2,
      "bb_count": 5,
      "insn_est": 34,
      "callers": 0,
      "callees": [
        {
          "addr": "0x40b810",
          "name": "ai_check_file_write_error",
          "original_name": "sub_40b810"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x404790",
          "name": "ai_process_exit",
          "original_name": "_exit"
        },
        {
          "addr": "0x40b810",
          "name": "ai_check_file_write_error",
          "original_name": "sub_40b810"
        },
        {
          "addr": "0x404790",
          "name": "ai_process_exit",
          "original_name": "_exit"
        }
      ],
      "import_refs": [
        "dcgettext",
        "__errno_location",
        "error",
        "_exit",
        "_exit"
      ],
      "string_refs": [
        "write error"
      ],
      "constants": [
        "0x422fa8",
        "0x40b810",
        "0x422ff8",
        "0x41ae92",
        "0x4048c0",
        "0x404760",
        "0x41b563",
        "0x404c30",
        "0x423088",
        "0x404790"
      ],
      "snippets": {
        "asm": "  0x40b880  endbr64 \n  0x40b884  push    rbp {__saved_rbp}\n  0x40b885  mov     rbp, rsp {__saved_rbp}\n  0x40b888  push    rbx {__saved_rbx}\n  0x40b889  sub     rsp, 0x8\n  0x40b88d  mov     rax, qword [rel stdout]\n  0x40b894  mov     rdi, qword [rax]\n  0x40b897  call    sub_40b810\n  0x40b89c  test    eax, eax\n  0x40b89e  je      0x40b8e0\n  0x40b8e0  mov     rax, qword [rel stderr]\n  0x40b8e7  mov     rdi, qword [rax]\n  0x40b8ea  call    sub_40b810\n  0x40b8ef  test    eax, eax\n  0x40b8f1  jne     0x40b8f9\n  0x40b8a0  mov     edx, 0x5\n  0x40b8a5  lea     rsi, [rel data_41ae92]  {\"write error\"}\n  0x40b8ac  xor     edi, edi  {0x0}\n  0x40b8ae  call    dcgettext\n  0x40b8b3  mov     rbx, rax\n  0x40b8b6  call    __errno_location\n  0x40b8bb  xor     edi, edi  {0x0}\n  0x40b8bd  mov     rcx, rbx\n  0x40b8c0  lea     rdx, [rel data_41b561[2]]  {\"%s\"}\n  0x40b8c7  mov     esi, dword [rax]\n  0x40b8c9  xor     eax, eax  {0x0}\n  0x40b8cb  call    error\n  0x40b8d0  mov     edi, dword [rel data_423088]\n  0x40b8d6  call    _exit\n  0x40b8d6  { Does not return }\n  ... (127 bytes total, truncated)",
        "hlil": "if (sub_40b810(*stdout) != 0)\nchar* rax_1 = dcgettext(nullptr, \"write error\", 5)\nerror(0, zx.q(*__errno_location()), \"%s\", rax_1)\n_exit(data_423088)\nnoreturn\nif (sub_40b810(*stderr) == 0)\nreturn \n_exit(data_423088)\nnoreturn",
        "pseudoc": "{\n    if (sub_40b810(*(uint64_t*)stdout))\n    {\n        char* rax_1 = dcgettext(nullptr, \"write error\", 5);\n        error(0, (uint64_t)*(uint32_t*)__errno_location(), \"%s\", rax_1);\n        _exit(data_423088);\n        /* no return */\n    }\n    \n    if (!sub_40b810(*(uint64_t*)stderr))\n        return;\n    \n    _exit(data_423088);\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_write_error_exit_handler",
          "confidence": 0.92,
          "rationale": "The function checks write status of stdout and stderr via sub_40b810, logs a 'write error' using error() and terminates the process with _exit, indicating an I/O error handling routine.",
          "evidence_refs": [
            "strings:write error",
            "imports:error",
            "imports:_exit",
            "imports:dcgettext",
            "imports:__errno_location",
            "call:0x40b810"
          ],
          "tags": [
            "file_io",
            "process",
            "error_handling"
          ],
          "alt_names": [
            "ai_io_error_exit",
            "ai_stdout_stderr_error_handler"
          ]
        },
        "explain": {
          "summary": "The function checks for pending write errors on stdout and stderr, reports a \"write error\" via error() if stdout fails, and then terminates the process; if only stderr fails it exits silently, otherwise it returns normally.",
          "details": [
            "Calls sub_40b810 on stdout; if it indicates an error, retrieves a localized \"write error\" string with dcgettext, logs it with error(), and exits using _exit with data_423088 as status.",
            "If stdout is fine, it calls sub_40b810 on stderr; if that indicates an error, it exits with the same status without reporting.",
            "If neither stream reports an error, the function simply returns."
          ],
          "evidence_refs": [
            "strings:\"write error\"",
            "imports:dcgettext",
            "imports:error",
            "imports:_exit",
            "call:0x40b810"
          ],
          "unknowns": [
            "Exact meaning of the return value of sub_40b810 and the value stored at data_423088",
            "Whether the function also flushes buffers before checking errors"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": [
        "file_io",
        "process",
        "error_handling"
      ]
    },
    {
      "addr": "0x40b910",
      "original_name": "sub_40b910",
      "final_name": "ai_compute_file_mode_flags",
      "score": 63.2,
      "bb_count": 15,
      "insn_est": 44,
      "callers": 3,
      "callees": [
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        }
      ],
      "import_refs": [
        "abort"
      ],
      "string_refs": [],
      "constants": [
        "0x423348",
        "0x423344",
        "0x400",
        "0x423349",
        "0x102",
        "0x4243e4",
        "0x41adb0",
        "0x4243e0",
        "0x20c",
        "0x423343",
        "0x404750",
        "0x419164",
        "0x204",
        "0x42308c"
      ],
      "snippets": {
        "asm": "  0x40b910  endbr64 \n  0x40b914  movzx   eax, byte [rel data_423348]\n  0x40b91b  mov     edx, dword [rel data_423344]\n  0x40b921  neg     eax\n  0x40b923  and     eax, 0x400\n  0x40b928  cmp     byte [rel data_423349], 0x0\n  0x40b92f  je      0x40b9a8\n  0x40b9a8  or      eax, 0x2\n  0x40b9ab  test    edx, edx\n  0x40b9ad  je      0x40b93a\n  0x40b931  or      eax, 0x102\n  0x40b936  test    edx, edx\n  0x40b938  jne     0x40b972\n  0x40b93a  mov     edx, dword [rel data_4243e4]\n  0x40b940  lea     rcx, [rel data_41adb0]\n  0x40b947  or      eax, dword [rcx+rdx*4]\n  0x40b94a  cmp     byte [rel data_42308d], 0x0\n  0x40b951  mov     edx, eax\n  0x40b953  jne     0x40b95e\n  0x40b9af  jmp     0x40b972\n  0x40b972  cmp     dword [rel data_4243e0], 0x6\n  0x40b979  ja      0x404d7f\n  0x40b95e  or      edx, 0x20c\n  0x40b955  cmp     byte [rel data_423343], 0x0\n  0x40b95c  je      0x40b9d8\n  0x404d7f  call    abort\n  0x404d7f  { Does not return }\n  0x40b97f  mov     edx, dword [rel data_4243e0]\n  0x40b985  lea     rcx, [rel jump_table_419164]\n  0x40b98c  movsxd  rdx, dword [rcx+rdx*4]\n  ... (178 bytes total, truncated)",
        "hlil": "int32_t rdx = data_423344\nint32_t rax_2 = neg.d(zx.d(data_423348)) & 0x400\nint32_t result\nif (data_423349 == 0)\nresult = rax_2 | 2\nif (rdx == 0)\nlabel_40b947:\nint32_t rax_3 = result | *(&data_41adb0 + (zx.q(data_4243e4) << 2))\nint32_t rdx_3\nif (data_42308d != 0 || data_423343 != 0)\nrdx_3 = rax_3 | 0x20c\nrdx_3 = rax_3 | 0x204\nresult = (neg.d(zx.d(data_42308c)) & 0x10) | rdx_3\nresult = rax_2 | 0x102\nif (rdx == 0)\ngoto label_40b947\nif (data_4243e0 u> 6)\nabort()\nnoreturn\nswitch (data_4243e0)\ncase 0, 1, 2, 4, 6\nreturn result\ncase 3\nresult:1.b |= 2\nreturn result\ncase 5\nreturn zx.q(result) | zx.q(*(&data_41adb0 + (zx.q(data_4243e4) << 2)))",
        "pseudoc": "{\n    int32_t rdx = data_423344;\n    int32_t rax_2 = -((uint32_t)data_423348) & 0x400;\n    int32_t result;\n    \n    if (!data_423349)\n    {\n        result = rax_2 | 2;\n        \n        if (!rdx)\n        {\n        label_40b947:\n            int32_t rax_3 = result | *(uint32_t*)(&data_41adb0 + ((uint64_t)data_4243e4 << 2));\n            int32_t rdx_3;\n            \n            if (data_42308d || data_423343)\n                rdx_3 = rax_3 | 0x20c;\n            else\n                rdx_3 = rax_3 | 0x204;\n            \n            result = (-((uint32_t)data_42308c) & 0x10) | rdx_3;\n        }\n    }\n    else\n    {\n        result = rax_2 | 0x102;\n        \n        if (!rdx)\n            goto label_40b947;\n    }\n    \n    if (data_4243e0 > 6)\n    {\n        abort();\n        /* no return */\n    }\n    \n    switch (data_4243e0)\n    {\n        case 0:\n        case 1:\n        case 2:\n        case 4:\n        case 6:\n        {\n            return result;\n            break;\n        }\n        case 3:\n        {\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compute_file_mode_flags",
          "confidence": 0.78,
          "rationale": "The function builds a result by combining several global flag variables using bitwise operations, checks a mode index, and aborts on invalid values, indicating it computes configuration or file mode flags.",
          "evidence_refs": [
            "imports:abort",
            "constants:0x400",
            "constants:0x102",
            "constants:0x20c",
            "constants:0x204",
            "call:0x404750"
          ],
          "tags": [
            "config",
            "file_io"
          ],
          "alt_names": [
            "ai_assemble_flags",
            "ai_compute_mode"
          ]
        },
        "explain": {
          "summary": "The function builds a configuration bitmask by combining several global flags and constants, validates a mode index, and returns the mask; it aborts if the mode index exceeds an allowed range.",
          "details": [
            "Computes an initial flag using data_423348 and masks with 0x400, then adds base flags (0x2 or 0x102) depending on data_423349.",
            "If data_423344 is zero, further ORs the mask with a value from an array indexed by data_4243e4 and adds additional bits based on data_42308d, data_423343, and data_42308c.",
            "Checks data_4243e0; if greater than 6 the function calls abort, otherwise returns the constructed mask for specific case values (0,1,2,4,6)."
          ],
          "evidence_refs": [
            "imports:abort",
            "call:0x404750",
            "strings:none"
          ],
          "unknowns": [
            "Exact meaning of each global variable (e.g., data_423349, data_423344) and the purpose of the returned bitmask",
            "The full behavior for cases of data_4243e0 not shown in the truncated code"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "file_io"
      ]
    },
    {
      "addr": "0x40b9e0",
      "original_name": "sub_40b9e0",
      "final_name": "ai_collect_file_metadata",
      "score": 82.4,
      "bb_count": 8,
      "insn_est": 98,
      "callers": 6,
      "callees": [
        {
          "addr": "0x404be0",
          "name": "ai_statx_wrapper",
          "original_name": "statx"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "statx",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0xfffffffffffffee0",
        "0x110",
        "0x404be0",
        "0xfffff00000000000",
        "0xfffffffffffffef4",
        "0xfffffffffffffee4",
        "0xfff00",
        "0xffffff00000",
        "0xfffffffffffffefc",
        "0xfffffffffffffef8",
        "0xffffffffffffff00",
        "0xfffffffffffffef0",
        "0x800",
        "0xfffffffffffffee1",
        "0x4048f0"
      ],
      "snippets": {
        "asm": "  0x40b9e0  endbr64 \n  0x40b9e4  push    rbp {__saved_rbp}\n  0x40b9e5  or      ch, 0x8\n  0x40b9e8  mov     rbp, rsp {__saved_rbp}\n  0x40b9eb  push    r12 {__saved_r12}\n  0x40b9ed  mov     r12d, r8d\n  0x40b9f0  push    rbx {__saved_rbx}\n  0x40b9f1  lea     r8, [rbp-0x120 {var_128}]\n  0x40b9f8  mov     rbx, rdx\n  0x40b9fb  mov     edx, ecx\n  0x40b9fd  mov     ecx, r12d\n  0x40ba00  sub     rsp, 0x110\n  0x40ba07  mov     rax, qword [fs:0x28]\n  0x40ba10  mov     qword [rbp-0x18 {var_20}], rax\n  0x40ba14  xor     eax, eax  {0x0}\n  0x40ba16  call    statx\n  0x40ba1b  test    eax, eax\n  0x40ba1d  jns     0x40ba40\n  0x40ba40  mov     ecx, dword [rbp-0x98 {var_a0}]\n  0x40ba46  mov     edx, dword [rbp-0x94 {var_9c}]\n  0x40ba4c  mov     rsi, 0xfffff00000000000\n  0x40ba56  movd    xmm2, dword [rbp-0x10c {var_114}]\n  0x40ba5e  movd    xmm1, dword [rbp-0x11c {var_124}]\n  0x40ba66  mov     rdi, rcx\n  0x40ba69  shl     rcx, 0x20\n  0x40ba6d  shl     rdi, 0x8\n  0x40ba71  and     rcx, rsi\n  0x40ba74  and     edi, 0xfff00\n  0x40ba7a  or      rcx, rdi\n  0x40ba7d  movzx   edi, dl\n  ... (450 bytes total, truncated)",
        "hlil": "arg4:1.b |= 8\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nint32_t result = statx(arg1, arg2, arg4, arg5)\nif (result s>= 0)\nint32_t var_a0\nuint64_t rcx_1 = zx.q(var_a0)\nint32_t var_9c\nuint64_t rdx_3 = zx.q(var_9c)\nint64_t var_108\n*arg3 = ((zx.o(rdx_3 << 0xc) & 0xffffff00000) | (zx.o(rcx_1 << 0x20) & -0x100000000000) | (zx.o((rcx_1 << 8).d) & 0xfff00) | zx.o(rdx_3.b))[0].q | var_108 << 0x40\nint32_t var_110\narg3[2][0] = var_110\nint32_t var_a4\nuint64_t rdx_8 = zx.q(var_a4)\nint32_t var_114\nint16_t var_10c\nint32_t temp0_2[0x4] = _mm_unpacklo_epi32(zx.o(var_10c), zx.q(var_114))\nint32_t var_118\narg3[1][0].q = zx.q(var_118)\nint32_t var_a8\nuint64_t rcx_8 = zx.q(var_a8)\n*(arg3 + 0x18) = temp0_2[0].q\nint32_t var_124\nint64_t var_100\nint32_t temp0_3[0x4] = _mm_unpacklo_epi64(zx.o(var_100), zx.q(var_124))\narg3[3] = temp0_3\n*(arg3 + 0x28) = (rdx_8 << 0xc & 0xffffff00000) | (rcx_8 << 0x20 & 0xfffff00000000000) | (zx.q((rcx_8 << 8).d) & 0xfff00) | zx.q(rdx_8.b)\nint32_t var_e0\narg3[5][0].q = zx.q(var_e0)\nint64_t var_f8\narg3[4][0].q = var_f8\nint32_t var_b0\narg3[6][0].q = zx.q(var_b0)\nint64_t var_e8\n*(arg3 + 0x48) = var_e8\nint32_t var_c0\narg3[7][0].q = zx.q(var_c0)\nint64_t var_b8\n*(arg3 + 0x58) = var_b8\n// ... truncated",
        "pseudoc": "{\n    *(uint8_t*)((char*)&arg4 + 1) |= 8;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int32_t result = statx(arg1, arg2, arg4, arg5);\n    \n    if (result >= 0)\n    {\n        int32_t var_a0;\n        uint64_t rcx_1 = (uint64_t)var_a0;\n        int32_t var_9c;\n        uint64_t rdx_3 = (uint64_t)var_9c;\n        int64_t var_108;\n        *(uint128_t*)arg3 = (((uint128_t)(rdx_3 << 0xc) & 0xffffff00000)\n            | ((uint128_t)(rcx_1 << 0x20) & -0x100000000000)\n            | ((uint128_t)(uint32_t)(rcx_1 << 8) & 0xfff00) | (uint128_t)(uint8_t)rdx_3)[0]\n            | var_108 << 0x40;\n        int32_t var_110;\n        arg3[2][0] = var_110;\n        int32_t var_a4;\n        uint64_t rdx_8 = (uint64_t)var_a4;\n        int32_t var_114;\n        int16_t var_10c;\n        int32_t temp0_2[0x4] = _mm_unpacklo_epi32((uint128_t)var_10c, (uint64_t)var_114);\n        int32_t var_118;\n        arg3[1][0] = (uint64_t)var_118;\n        int32_t var_a8;\n        uint64_t rcx_8 = (uint64_t)var_a8;\n        *(uint64_t*)((char*)arg3 + 0x18) = *(uint64_t*)&temp0_2[0];\n        int32_t var_124;\n        int64_t var_100;\n        int32_t temp0_3[0x4] = _mm_unpacklo_epi64((uint128_t)var_100, (uint64_t)var_124);\n        arg3[3] = temp0_3;\n        *(uint64_t*)((char*)arg3 + 0x28) = (rdx_8 << 0xc & 0xffffff00000)\n            | (rcx_8 << 0x20 & 0xfffff00000000000) | ((uint64_t)(uint32_t)(rcx_8 << 8) & 0xfff00)\n            | (uint64_t)(uint8_t)rdx_8;\n        int32_t var_e0;\n        arg3[5][0] = (uint64_t)var_e0;\n        int64_t var_f8;\n        arg3[4][0] = var_f8;\n        int32_t var_b0;\n        arg3[6][0] = (uint64_t)var_b0;\n        int64_t var_e8;\n        *(uint64_t*)((char*)arg3 + 0x48) = var_e8;\n        int32_t var_c0;\n        arg3[7][0] = (uint64_t)var_c0;\n        int64_t var_b8;\n        *(uint64_t*)((char*)arg3 + 0x58) = var_b8;\n        int64_t var_c8;\n        *(uint64_t*)((char*)arg3 + 0x68) = var_c8;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_collect_file_metadata",
          "confidence": 0.86,
          "rationale": "The function calls statx to retrieve file information and then packs various fields (size, timestamps, attributes) into a custom structure, indicating it gathers and formats file metadata.",
          "evidence_refs": [
            "imports:statx",
            "call:0x404be0",
            "call:0x4048f0",
            "constants:0xffffff00000"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_get_file_stat",
            "ai_build_file_info_struct"
          ]
        },
        "explain": {
          "summary": "sub_40b9e0 is a wrapper around the Linux statx syscall that gathers file metadata and packs selected fields into a custom output structure. It first sets a flag in the provided options, invokes statx, and on success extracts mode, uid, gid, size, timestamps and other attributes, applying bit masks and shifts before storing them in the buffer pointed by arg3.",
          "details": [
            "The function modifies arg4 (likely the flags argument) by OR-ing the value 8 before calling statx with arg1, arg2, arg4, and arg5.",
            "After a successful statx call, it reads various fields from the statx result (e.g., mode, uid, gid, size, timestamps) and assembles them into a packed structure using bitwise masks such as 0xffffff00000, 0xfff00, and shifts, storing the result in the memory region referenced by arg3.",
            "It uses SSE intrinsics like _mm_unpacklo_epi32/_mm_unpacklo_epi64 to combine 32bit and 64bit parts of the statx data before writing them to the output buffer.",
            "Stack protection is present, referencing __stack_chk_fail in case of canary violation."
          ],
          "evidence_refs": [
            "imports:statx",
            "imports:__stack_chk_fail",
            "call:0x404be0",
            "call:0x4048f0",
            "constants:0xffffff00000",
            "constants:0xfff00"
          ],
          "unknowns": [
            "Exact layout and purpose of the custom structure pointed by arg3",
            "Meaning of some intermediate local variables (var_a0, var_9c, etc.)",
            "Whether the function returns a status code or a pointer"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40bbb0",
      "original_name": "sub_40bbb0",
      "final_name": "ai_get_config_option",
      "score": 42.4,
      "bb_count": 8,
      "insn_est": 28,
      "callers": 24,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x4230c0"
      ],
      "snippets": {
        "asm": "  0x40bbb0  endbr64 \n  0x40bbb4  mov     edi, edi\n  0x40bbb6  lea     rax, [rel data_4230c0]\n  0x40bbbd  xor     ecx, ecx  {0x0}\n  0x40bbbf  shl     rdi, 0x4\n  0x40bbc3  add     rax, rdi\n  0x40bbc6  mov     rdx, qword [rax]\n  0x40bbc9  test    rdx, rdx\n  0x40bbcc  je      0x40bbf7\n  0x40bbf7  mov     eax, ecx\n  0x40bbf9  retn     {__return_addr}\n  0x40bbce  mov     rsi, qword [rax+0x8]\n  0x40bbd2  cmp     rdx, 0x1\n  0x40bbd6  je      0x40bc00\n  0x40bc00  cmp     byte [rsi], 0x30\n  0x40bc03  setne   cl\n  0x40bc06  mov     eax, ecx\n  0x40bc08  retn     {__return_addr}\n  0x40bbd8  mov     ecx, 0x1\n  0x40bbdd  cmp     rdx, 0x2\n  0x40bbe1  jne     0x40bbf7\n  0x40bbe3  movzx   eax, byte [rsi]\n  0x40bbe6  sub     eax, 0x30\n  0x40bbe9  jne     0x40bbf2\n  0x40bbf2  test    eax, eax\n  0x40bbf4  setne   cl\n  0x40bbeb  movzx   eax, byte [rsi+0x1]\n  0x40bbef  sub     eax, 0x30",
        "hlil": "int32_t rcx = 0\nint64_t rdx = (&data_4230c0)[zx.q(arg1) * 2]\nif (rdx != 0)\nchar* rsi_1 = (&data_4230c8)[zx.q(arg1) * 2]\nif (rdx == 1)\nrcx.b = *rsi_1 != 0x30\nreturn zx.q(rcx)\nrcx = 1\nif (rdx == 2)\nuint32_t rax_1 = zx.d(*rsi_1)\nint32_t rax_2 = rax_1 - 0x30\nif (rax_1 == 0x30)\nrax_2 = zx.d(rsi_1[1]) - 0x30\nrcx.b = rax_2 != 0\nreturn zx.q(rcx)",
        "pseudoc": "{\n    int32_t rcx = 0;\n    int64_t rdx = (&data_4230c0)[(uint64_t)arg1 * 2];\n    \n    if (rdx)\n    {\n        char* rsi_1 = (&data_4230c8)[(uint64_t)arg1 * 2];\n        \n        if (rdx == 1)\n        {\n            (uint8_t)rcx = *(uint8_t*)rsi_1 != 0x30;\n            return (uint64_t)rcx;\n        }\n        \n        rcx = 1;\n        \n        if (rdx == 2)\n        {\n            uint32_t rax_1 = (uint32_t)*(uint8_t*)rsi_1;\n            int32_t rax_2 = rax_1 - 0x30;\n            \n            if (rax_1 == 0x30)\n                rax_2 = (uint32_t)rsi_1[1] - 0x30;\n            \n            (uint8_t)rcx = rax_2;\n        }\n    }\n    \n    return (uint64_t)rcx;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_config_option",
          "confidence": 0.78,
          "rationale": "The function indexes a configuration table (data_4230c0) and based on a type code (1 or 2) returns a boolean or numeric value derived from a string pointer (data_4230c8), indicating it parses or checks configuration options.",
          "evidence_refs": [
            "constants:0x4230c0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_parse_config_flag",
            "ai_get_option_value"
          ]
        },
        "explain": {
          "summary": "The function indexes two parallel tables using the provided index, checks a control value from the first table, and based on that either validates a character against '0' or extracts a digit value from a character pointer in the second table, returning a boolean or numeric result.",
          "details": [
            "It reads a control byte (rdx) from a table at data_4230c0 indexed by arg1*2.",
            "If the control byte is 1, it returns whether the character at the corresponding address in data_4230c8 is not '0' (0x30).",
            "If the control byte is 2, it computes a digit value by subtracting '0' from the character; if the first character is '0', it uses the next character instead.",
            "If the control byte is zero or any other value, the function returns 0."
          ],
          "evidence_refs": [
            "constants:0x4230c0",
            "constants:0x4230c8"
          ],
          "unknowns": [
            "Exact semantic meaning of the control values (1 and 2) and the broader context of the tables.",
            "What higher-level logic calls this function and how its return value is used."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40bc10",
      "original_name": "sub_40bc10",
      "final_name": "ai_report_error",
      "score": 60.4,
      "bb_count": 7,
      "insn_est": 48,
      "callers": 9,
      "callees": [
        {
          "addr": "0x4248e8"
        },
        {
          "addr": "0x413ce0",
          "name": "ai_dynamic_array_ensure_and_process",
          "original_name": "sub_413ce0"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__errno_location",
        "error",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x413ce0",
        "0x404760",
        "0x404c30",
        "0x42372c",
        "0x4048f0"
      ],
      "snippets": {
        "asm": "  0x40bc10  endbr64 \n  0x40bc14  push    rbp {__saved_rbp}\n  0x40bc15  pxor    xmm0, xmm0\n  0x40bc19  mov     rbp, rsp {__saved_rbp}\n  0x40bc1c  push    r13 {__saved_r13}\n  0x40bc1e  push    r12 {__saved_r12}\n  0x40bc20  mov     r12, rsi\n  0x40bc23  mov     rsi, rdx\n  0x40bc26  lea     rdx, [rbp-0x60 {var_68}]\n  0x40bc2a  push    rbx {__saved_rbx}\n  0x40bc2b  mov     ebx, edi\n  0x40bc2d  xor     edi, edi  {0x0}\n  0x40bc2f  sub     rsp, 0x48\n  0x40bc33  mov     rax, qword [fs:0x28]\n  0x40bc3c  mov     qword [rbp-0x28 {var_30}], rax\n  0x40bc40  xor     eax, eax  {0x0}\n  0x40bc42  movups  xmmword [rbp-0x58], xmm0\n  0x40bc46  movups  xmmword [rbp-0x48 {var_50}], xmm0\n  0x40bc4a  pxor    xmm0, xmm0\n  0x40bc4e  movups  xmmword [rbp-0x38 {var_40}], xmm0\n  0x40bc52  mov     qword [rbp-0x60 {var_68}], 0x4\n  0x40bc5a  call    sub_413ce0\n  0x40bc5f  mov     r13, rax\n  0x40bc62  call    __errno_location\n  0x40bc67  xor     edi, edi  {0x0}\n  0x40bc69  mov     rcx, r13\n  0x40bc6c  mov     rdx, r12\n  0x40bc6f  mov     esi, dword [rax]\n  0x40bc71  xor     eax, eax  {0x0}\n  0x40bc73  call    error\n  ... (171 bytes total, truncated)",
        "hlil": "void* fsbase\nint64_t rax = *(fsbase + 0x28)\nint128_t var_60\n__builtin_memset(&var_60, 0, 0x30)\nint64_t var_68 = 4\nchar* rax_2 = sub_413ce0(0, arg3, &var_68)\nerror(0, zx.q(*__errno_location()), arg2, rax_2)\nif (arg1 != 0)\ndata_42372c = 2\nif (data_42372c == 0)\ndata_42372c = 1\nif (rax == *(fsbase + 0x28))\nreturn rax - *(fsbase + 0x28)\n__stack_chk_fail()\nnoreturn",
        "pseudoc": "{\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int128_t var_60;\n    __builtin_memset(&var_60, 0, 0x30);\n    int64_t var_68 = 4;\n    char* rax_2 = sub_413ce0(0, arg3, &var_68);\n    error(0, (uint64_t)*(uint32_t*)__errno_location(), arg2, rax_2);\n    \n    if (arg1)\n        data_42372c = 2;\n    else if (!data_42372c)\n        data_42372c = 1;\n    \n    if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n        return rax - *(uint64_t*)((char*)fsbase + 0x28);\n    \n    __stack_chk_fail();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_report_error",
          "confidence": 0.85,
          "rationale": "Function wraps a call to the C library error() to report an error message, uses errno, updates a global status flag, and includes stack canary protection, indicating it is an error handling/reporting routine.",
          "evidence_refs": [
            "imports:error",
            "imports:__errno_location",
            "imports:__stack_chk_fail",
            "call:0x413ce0"
          ],
          "tags": [],
          "alt_names": [
            "ai_error_report",
            "ai_log_error"
          ]
        },
        "explain": {
          "summary": "sub_40bc10 logs an error message, updates a global status flag, and enforces stack canary protection before returning.",
          "details": [
            "Retrieves the current stack canary from the FS segment and stores it in rax for later verification.",
            "Calls sub_413ce0 with a fixed size argument (var_68 = 4) to obtain a formatted error string, then invokes error(0, errno, arg2, formatted_string).",
            "Updates global variable data_42372c based on arg1: sets it to 2 if arg1 is true, otherwise sets it to 1 if it was previously zero.",
            "Verifies the stack canary after execution; if altered, calls __stack_chk_fail to abort."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:error",
            "imports:__stack_chk_fail",
            "call:0x413ce0",
            "call:0x404760",
            "call:0x4248e8"
          ],
          "unknowns": [
            "Exact semantics of arg1, arg2, arg3 beyond their use in error handling",
            "The content and purpose of the buffer var_60 and constant values referenced",
            "The full behavior of sub_413ce0 which generates the error string"
          ],
          "confidence": 0.82
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40bcc0",
      "original_name": "sub_40bcc0",
      "final_name": "ai_validate_string_prefix_length",
      "score": 53.6,
      "bb_count": 6,
      "insn_est": 52,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x412790",
          "name": "ai_locale_string_validator",
          "original_name": "sub_412790"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__errno_location",
        "strlen",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x4235a0",
        "0x4232e0",
        "0x404760",
        "0x412790",
        "0x4048e0",
        "0x4048f0"
      ],
      "snippets": {
        "asm": "  0x40bcc0  endbr64 \n  0x40bcc4  push    rbp {__saved_rbp}\n  0x40bcc5  mov     rbp, rsp {__saved_rbp}\n  0x40bcc8  push    r14 {__saved_r14}\n  0x40bcca  push    r13 {__saved_r13}\n  0x40bccc  push    r12 {__saved_r12}\n  0x40bcce  mov     r12, rdi\n  0x40bcd1  push    rbx {__saved_rbx}\n  0x40bcd2  sub     rsp, 0x10\n  0x40bcd6  mov     rbx, qword [rel data_4235a0]\n  0x40bcdd  mov     rax, qword [fs:0x28]\n  0x40bce6  mov     qword [rbp-0x28 {var_30}], rax\n  0x40bcea  xor     eax, eax  {0x0}\n  0x40bcec  lea     rax, [rel data_4232e0]\n  0x40bcf3  test    rbx, rbx\n  0x40bcf6  cmove   rbx, rax  {data_4232e0}\n  0x40bcfa  call    __errno_location\n  0x40bcff  mov     rdx, r12\n  0x40bd02  mov     esi, 0x2\n  0x40bd07  mov     r14d, dword [rax]\n  0x40bd0a  mov     ecx, dword [rbx]\n  0x40bd0c  mov     r13, rax\n  0x40bd0f  lea     rdi, [rbp-0x2a {var_32}]\n  0x40bd13  mov     r8d, dword [rbx+0x4]\n  0x40bd17  push    qword [rbx+0x30] {var_40}\n  0x40bd1a  lea     r9, [rbx+0x8]\n  0x40bd1e  push    qword [rbx+0x28] {var_48}\n  0x40bd21  call    sub_412790\n  0x40bd26  mov     dword [r13], r14d\n  0x40bd2a  movzx   esi, byte [rbp-0x2a {var_32}]\n  ... (175 bytes total, truncated)",
        "hlil": "int32_t* rbx = data_4235a0\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nif (rbx == 0)\nrbx = &data_4232e0\nint32_t* rax_1 = __errno_location()\nint32_t r14 = *rax_1\nchar var_32\nchar* rax_2 = sub_412790(&var_32, 2, arg1, *rbx, rbx[1], &rbx[2], *(rbx + 0x28), *(rbx + 0x30))\n*rax_1 = r14\nuint64_t result\nif (*arg1 == var_32)\nresult.b = strlen(arg1) != rax_2\nresult = 1\n*(fsbase + 0x28)\nif (rax == *(fsbase + 0x28))\nreturn result\n__stack_chk_fail()\nnoreturn",
        "pseudoc": "{\n    int32_t* rbx = data_4235a0;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (!rbx)\n        rbx = &data_4232e0;\n    \n    int32_t* rax_1 = __errno_location();\n    int32_t r14 = *(uint32_t*)rax_1;\n    char var_32;\n    char* rax_2 = sub_412790(&var_32, 2, arg1, *(uint32_t*)rbx, rbx[1], &rbx[2], \n        *(uint64_t*)((char*)rbx + 0x28), *(uint64_t*)((char*)rbx + 0x30));\n    *(uint32_t*)rax_1 = r14;\n    uint64_t result;\n    \n    if (*(uint8_t*)arg1 == var_32)\n        (uint8_t)result = strlen(arg1) != rax_2;\n    else\n        result = 1;\n    \n    *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n        return result;\n    \n    __stack_chk_fail();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_validate_string_prefix_length",
          "confidence": 0.68,
          "rationale": "The function preserves errno, calls a helper (sub_412790) to compute a reference character and length, then checks the first byte of the input string against that character and compares its length, returning a boolean error flag. This indicates a validation of string format/prefix and length.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strlen",
            "call:0x412790"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_check_string_integrity",
            "ai_verify_input_format"
          ]
        },
        "explain": {
          "summary": "sub_40bcc0 validates a provided string against configuration data, preserving errno, and returns a boolean indicating whether the string matches expected criteria; it also includes a stack canary check for integrity.",
          "details": [
            "Loads a global configuration pointer (data_4235a0 or fallback data_4232e0) and saves the current stack canary.",
            "Preserves the current errno value across a call to sub_412790, which processes the input string with parameters from the configuration.",
            "Compares the first byte of the input string to a value returned in var_32 and checks if the string length matches the length returned by sub_412790; returns 1 on mismatch or when the first byte differs.",
            "Restores errno, verifies the stack canary, and calls __stack_chk_fail on corruption."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:strlen",
            "imports:__stack_chk_fail",
            "call:0x412790",
            "call:0x404760",
            "call:0x4048e0",
            "call:0x4048f0"
          ],
          "unknowns": [
            "Exact meaning of the data structures referenced by data_4235a0/data_4232e0",
            "Precise semantics of sub_412790's return value and its internal logic",
            "Purpose of the constant argument '2' passed to sub_412790"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40bd80",
      "original_name": "sub_40bd80",
      "final_name": "ai_map_status_code",
      "score": 60.3,
      "bb_count": 24,
      "insn_est": 61,
      "callers": 4,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0xf000",
        "0x8000",
        "0x4000",
        "0x423334",
        "0xa000",
        "0x1000"
      ],
      "snippets": {
        "asm": "  0x40bd80  endbr64 \n  0x40bd84  test    dil, dil\n  0x40bd87  je      0x40be00\n  0x40be00  xor     eax, eax  {0x0}\n  0x40be02  cmp     edx, 0x5\n  0x40be05  je      0x40bda8\n  0x40bd89  mov     edx, esi\n  0x40bd8b  and     edx, 0xf000\n  0x40bd91  cmp     edx, 0x8000\n  0x40bd97  jne     0x40bdb0\n  0x40bda8  retn     {__return_addr}\n  0x40be07  cmp     edx, 0x3\n  0x40be0a  je      0x40be58\n  0x40bdb0  mov     eax, 0x2f\n  0x40bdb5  cmp     edx, 0x4000\n  0x40bdbb  je      0x40be40\n  0x40bd99  xor     eax, eax  {0x0}\n  0x40bd9b  cmp     dword [rel data_423334], 0x3\n  0x40bda2  je      0x40be48\n  0x40be58  mov     eax, 0x2f\n  0x40be5d  retn     {__return_addr}\n  0x40be0c  cmp     edx, 0x9\n  0x40be0f  sete    cl\n  0x40be12  je      0x40be58\n  0x40be40  retn     {__return_addr}\n  0x40bdc1  xor     eax, eax  {0x0}\n  0x40bdc3  cmp     dword [rel data_423334], 0x1\n  0x40bdca  je      0x40bda8\n  0x40be48  and     esi, 0x49\n  0x40be4b  neg     esi\n  ... (203 bytes total, truncated)",
        "hlil": "if (arg1 != 0)\nint32_t rdx_1 = arg2 & 0xf000\nif (rdx_1 != 0x8000)\nif (rdx_1 == 0x4000)\nreturn 0x2f\nif (data_423334 != 1)\nif (rdx_1 == 0xa000)\nreturn 0x40\nif (rdx_1 == 0x1000)\nreturn 0x7c\nif (rdx_1 != 0xc000)\nreturn 0\nreturn 0x3d\nif (data_423334 == 3)\nint32_t rax\nrax.b = sbb.b(0, 0, (arg2 & 0x49) != 0)\nreturn zx.q(rax) & 0x2a\nif (arg3 != 5)\nif (arg3 != 3)\nint32_t rcx\nrcx.b = arg3 == 9\nif (arg3 != 9)\nif (data_423334 == 1)\nreturn 0\nif (arg3 == 6)\nreturn 0x40\nif (arg3 == 1)\nreturn 0x7c\nif (arg3 != 7)\nreturn zx.q(rcx)\nreturn 0x3d\nreturn 0x2f\nreturn 0",
        "pseudoc": "{\n    if (arg1)\n    {\n        int32_t rdx_1 = arg2 & 0xf000;\n        \n        if (rdx_1 != 0x8000)\n        {\n            if (rdx_1 == 0x4000)\n                return 0x2f;\n            \n            if (data_423334 != 1)\n            {\n                if (rdx_1 == 0xa000)\n                    return 0x40;\n                \n                if (rdx_1 == 0x1000)\n                    return 0x7c;\n                \n                if (rdx_1 != 0xc000)\n                    return 0;\n                \n                return 0x3d;\n            }\n        }\n        else if (data_423334 == 3)\n        {\n            int32_t rax;\n            (uint8_t)rax = 0 - 0;\n            return (uint64_t)rax & 0x2a;\n        }\n    }\n    else if (arg3 != 5)\n    {\n        if (arg3 != 3)\n        {\n            int32_t rcx;\n            (uint8_t)rcx = arg3 == 9;\n            \n            if (arg3 != 9)\n            {\n                if (data_423334 == 1)\n                    return 0;\n                \n                if (arg3 == 6)\n                    return 0x40;\n                \n                if (arg3 == 1)\n                    return 0x7c;\n                \n                if (arg3 != 7)\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_map_status_code",
          "confidence": 0.78,
          "rationale": "The function examines masked bits of an input value and a global mode flag to return specific constant codes, acting as a lookup/decoder for status or error codes.",
          "evidence_refs": [
            "constants:0xf000",
            "constants:0x8000",
            "constants:0x4000",
            "constants:0xa000",
            "constants:0x1000",
            "constants:0xc000"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_decode_flag",
            "ai_status_lookup"
          ]
        },
        "explain": {
          "summary": "sub_40bd80 is a small lookup routine that returns specific constant values based on masked bits of arg2 when arg1 is true, or based on arg3 when arg1 is false. The returned constants (0x2f, 0x40, 0x7c, 0x3d, or 0) are further conditioned by a global flag data_423334, suggesting it selects formatting widths or type identifiers for later processing.",
          "details": [
            "If arg1 is nonzero, the function masks arg2 with 0xf000 and returns values: 0x2f for 0x4000, 0x40 for 0xa000, 0x7c for 0x1000, 0x3d for 0xc000, otherwise 0; special handling for 0x8000 when data_423334 equals 3 returns 0.",
            "If arg1 is zero, the function examines arg3 and returns similar constants (0x40 for 6, 0x7c for 1, etc.) unless data_423334 equals 1, in which case it returns 0.",
            "The global variable data_423334 influences several branches, acting as a mode flag that can suppress or alter the returned values."
          ],
          "evidence_refs": [
            "call:0x40bd80",
            "constants:0xf000",
            "constants:0x8000",
            "constants:0x4000",
            "constants:0xa000",
            "constants:0x1000",
            "constants:0xc000",
            "data:423334"
          ],
          "unknowns": [
            "Exact semantic meaning of arg1, arg2, arg3 and the global data_423334",
            "How the returned constants are used by the rest of the program"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40be90",
      "original_name": "sub_40be90",
      "final_name": "ai_lazy_stdout_write",
      "score": 79.8,
      "bb_count": 7,
      "insn_est": 36,
      "callers": 21,
      "callees": [
        {
          "addr": "0x404b90",
          "name": "ai_write_buffer_to_file",
          "original_name": "fwrite_unlocked"
        },
        {
          "addr": "0x404b10",
          "name": "ai_get_process_group_id",
          "original_name": "tcgetpgrp"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x408a60",
          "name": "ai_signal_handler_setup",
          "original_name": "sub_408a60"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        }
      ],
      "import_refs": [
        "fwrite_unlocked",
        "tcgetpgrp"
      ],
      "string_refs": [],
      "constants": [
        "0x4237c0",
        "0x404b10",
        "0x422fa8",
        "0x404b90",
        "0x408a60",
        "0x4230e8",
        "0x4230c0",
        "0x40be90",
        "0x4230f0",
        "0x4230d0",
        "0x4230e0"
      ],
      "snippets": {
        "asm": "  0x40be90  endbr64 \n  0x40be94  push    rbp {__saved_rbp}\n  0x40be95  mov     rbp, rsp {__saved_rbp}\n  0x40be98  push    rbx {__saved_rbx}\n  0x40be99  mov     rbx, rdi\n  0x40be9c  sub     rsp, 0x8\n  0x40bea0  cmp     byte [rel data_4237c0], 0x0\n  0x40bea7  je      0x40bed0\n  0x40bed0  mov     edi, 0x1\n  0x40bed5  mov     byte [rel data_4237c0], 0x1\n  0x40bedc  call    tcgetpgrp\n  0x40bee1  test    eax, eax\n  0x40bee3  jns     0x40bf00\n  0x40bea9  mov     rax, qword [rel stdout]\n  0x40beb0  mov     rsi, qword [rbx]\n  0x40beb3  mov     edx, 0x1\n  0x40beb8  mov     rdi, qword [rbx+0x8]\n  0x40bebc  mov     rbx, qword [rbp-0x8 {__saved_rbx}]\n  0x40bec0  mov     rcx, qword [rax]\n  0x40bec3  leave    {__saved_rbp}\n  0x40bec4  jmp     fwrite_unlocked\n  0x40bf00  mov     edi, 0x1\n  0x40bf05  call    sub_408a60\n  0x40bf0a  jmp     0x40bee5\n  0x40bee5  cmp     qword [rel data_4230e8], 0x0\n  0x40beed  je      0x40bf10\n  0x40bf10  lea     rdi, [rel data_4230c0]\n  0x40bf17  call    sub_40be90\n  0x40bf1c  lea     rdi, [rel data_4230f0]\n  0x40bf23  call    sub_40be90\n  ... (155 bytes total, truncated)",
        "hlil": "if (data_4237c0 == 0)\ndata_4237c0 = 1\nif (tcgetpgrp(1) s>= 0)\nsub_408a60(1)\nif (data_4230e8 == 0)\nsub_40be90(&data_4230c0)\nsub_40be90(&data_4230f0)\nsub_40be90(&data_4230d0)\nsub_40be90(&data_4230e0)\nreturn fwrite_unlocked(arg1[1], *arg1, 1, *stdout) __tailcall",
        "pseudoc": "{\n    if (!data_4237c0)\n    {\n        data_4237c0 = 1;\n        \n        if (tcgetpgrp(1) >= 0)\n            sub_408a60(1);\n        \n        if (!data_4230e8)\n        {\n            sub_40be90(&data_4230c0);\n            sub_40be90(&data_4230f0);\n            sub_40be90(&data_4230d0);\n        }\n        else\n            sub_40be90(&data_4230e0);\n    }\n    \n    /* tailcall */\n    return fwrite_unlocked(arg1[1], *(uint64_t*)arg1, 1, *(uint64_t*)stdout);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_lazy_stdout_write",
          "confidence": 0.78,
          "rationale": "The function performs a onetime initialization (checking a flag, calling tcgetpgrp and sub_408a60) then writes data to stdout using fwrite_unlocked. It appears to lazily set up output handling before writing buffers.",
          "evidence_refs": [
            "imports:fwrite_unlocked",
            "imports:tcgetpgrp",
            "call:0x408a60"
          ],
          "tags": [
            "file_io",
            "process"
          ],
          "alt_names": [
            "ai_init_and_write_stdout",
            "ai_stdout_output_handler"
          ]
        },
        "explain": {
          "summary": "sub_40be90 performs a onetime initialization guarded by data_4237c0, checks the process group of stdout via tcgetpgrp and may invoke sub_408a60, then recursively processes a set of data structures before finally writing a buffer to stdout using fwrite_unlocked.",
          "details": [
            "If data_4237c0 is not set, it is marked as initialized and tcgetpgrp(1) is called; on success sub_408a60(1) is invoked.",
            "Depending on the flag data_4230e8, the function recursively calls itself on three or one global data blocks (data_4230c0, data_4230f0, data_4230d0, or data_4230e0).",
            "The function ends with a tail call to fwrite_unlocked, writing one item of size *(uint64_t*)arg1 from buffer arg1[1] to stdout."
          ],
          "evidence_refs": [
            "imports:fwrite_unlocked",
            "imports:tcgetpgrp",
            "call:0x408a60",
            "call:0x404b90",
            "call:0x404b10"
          ],
          "unknowns": [
            "Exact semantics of the data structures referenced by data_4230c0, data_4230f0, data_4230d0, data_4230e0",
            "Purpose of sub_408a60 and its effect on the environment",
            "What content is being written to stdout (e.g., configuration data, color definitions)"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io",
        "process"
      ]
    },
    {
      "addr": "0x40bf40",
      "original_name": "sub_40bf40",
      "final_name": "ai_signal_suspension_loop",
      "score": 98.5,
      "bb_count": 12,
      "insn_est": 65,
      "callers": 5,
      "callees": [
        {
          "addr": "0x404cf0",
          "name": "ai_flush_file_stream",
          "original_name": "fflush_unlocked"
        },
        {
          "addr": "0x404710",
          "name": "ai_signal_mask_control",
          "original_name": "sigprocmask"
        },
        {
          "addr": "0x404730",
          "name": "ai_raise_signal",
          "original_name": "raise"
        },
        {
          "addr": "0x404710",
          "name": "ai_signal_mask_control",
          "original_name": "sigprocmask"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x404a70",
          "name": "ai_set_signal_handler",
          "original_name": "signal"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "fflush_unlocked",
        "sigprocmask",
        "raise",
        "sigprocmask",
        "signal",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x4230c0",
        "0x4230d0",
        "0x423740",
        "0x4237c8",
        "0x4237c0",
        "0x4237c4",
        "0x422fa8",
        "0x404cf0",
        "0x404710",
        "0x40be90",
        "0x404a70",
        "0x4048f0",
        "0x404730"
      ],
      "snippets": {
        "asm": "  0x40bf40  push    rbp {__saved_rbp}\n  0x40bf41  mov     rbp, rsp {__saved_rbp}\n  0x40bf44  push    r15 {__saved_r15}\n  0x40bf46  push    r14 {__saved_r14}\n  0x40bf48  lea     r14, [rel data_4230c0]\n  0x40bf4f  push    r13 {__saved_r13}\n  0x40bf51  lea     r13, [r14+0x10]\n  0x40bf55  push    r12 {__saved_r12}\n  0x40bf57  lea     r12, [rel data_423740]\n  0x40bf5e  push    rbx {__saved_rbx}\n  0x40bf5f  lea     rbx, [rbp-0xc0 {var_c8}]\n  0x40bf66  sub     rsp, 0x98\n  0x40bf6d  mov     rax, qword [fs:0x28]\n  0x40bf76  mov     qword [rbp-0x38 {var_40}], rax\n  0x40bf7a  xor     eax, eax  {0x0}\n  0x40bf7c  jmp     0x40bfd3\n  0x40bfd3  mov     eax, dword [rel data_4237c8]\n  0x40bfd9  test    eax, eax\n  0x40bfdb  jne     0x40bfe7\n  0x40bfe7  cmp     byte [rel data_4237c0], 0x0\n  0x40bfee  je      0x40bf80\n  0x40bfdd  mov     eax, dword [rel data_4237c4]\n  0x40bfe3  test    eax, eax\n  0x40bfe5  je      0x40c018\n  0x40bf80  mov     rax, qword [rel stdout]\n  0x40bf87  mov     rdi, qword [rax]\n  0x40bf8a  call    fflush_unlocked\n  0x40bf8f  mov     rdx, rbx {var_c8}\n  0x40bf92  mov     rsi, r12  {data_423740}\n  0x40bf95  xor     edi, edi  {0x0}\n  ... (245 bytes total, truncated)",
        "hlil": "void* fsbase\nint64_t rax = *(fsbase + 0x28)\nwhile (data_4237c8 != 0 || data_4237c4 != 0)\nif (data_4237c0 != 0)\nsub_40be90(&data_4230c0)\nsub_40be90(&data_4230d0)\nfflush_unlocked(*stdout)\nsigset_t var_c8\nsigprocmask(0, &data_423740, &var_c8)\nint32_t sig = data_4237c8\nint32_t rax_2 = data_4237c4\nif (rax_2 == 0)\nsignal(sig, nullptr)\nsig = 0x13\ndata_4237c4 = rax_2 - 1\nraise(sig)\nsigprocmask(2, &var_c8, nullptr)\nif (rax == *(fsbase + 0x28))\nreturn rax - *(fsbase + 0x28)\n__stack_chk_fail()\nnoreturn",
        "pseudoc": "{\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    while (data_4237c8 || data_4237c4)\n    {\n        if (data_4237c0)\n        {\n            sub_40be90(&data_4230c0);\n            sub_40be90(&data_4230d0);\n        }\n        \n        fflush_unlocked(*(uint64_t*)stdout);\n        sigset_t var_c8;\n        sigprocmask(0, &data_423740, &var_c8);\n        int32_t sig = data_4237c8;\n        int32_t rax_2 = data_4237c4;\n        \n        if (!rax_2)\n            signal(sig, nullptr);\n        else\n        {\n            sig = 0x13;\n            data_4237c4 = rax_2 - 1;\n        }\n        \n        raise(sig);\n        sigprocmask(2, &var_c8, nullptr);\n    }\n    \n    if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n        return rax - *(uint64_t*)((char*)fsbase + 0x28);\n    \n    __stack_chk_fail();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_signal_suspension_loop",
          "confidence": 0.78,
          "rationale": "The function repeatedly manipulates signal masks, raises signals (including SIGSTOP), and checks global flags, indicating a loop that suspends or controls execution via signals, a common anti-debug/anti-analysis technique.",
          "evidence_refs": [
            "imports:sigprocmask",
            "imports:raise",
            "imports:signal",
            "imports:__stack_chk_fail",
            "call:0x40be90"
          ],
          "tags": [
            "anti_debug",
            "process",
            "evasion"
          ],
          "alt_names": [
            "ai_signal_suspension",
            "ai_signal_control_loop"
          ]
        },
        "explain": {
          "summary": "sub_40bf40 implements a loop that repeatedly blocks signals, flushes stdout, and raises either a configurable signal or SIGPIPE based on two global counters, performing cleanup calls when a flag is set, and finally checks the stack canary before exiting.",
          "details": [
            "The function reads the stack canary from the FS segment and later verifies it to detect stack corruption.",
            "It loops while either data_4237c8 or data_4237c4 is nonzero, optionally invoking sub_40be90 on two global buffers when data_4237c0 is set.",
            "Within each iteration it flushes stdout, blocks signals with sigprocmask, determines which signal to raise (either the value in data_4237c8 or SIGPIPE if data_4237c4 is nonzero), raises the signal, then restores the original signal mask."
          ],
          "evidence_refs": [
            "imports:fflush_unlocked",
            "imports:sigprocmask",
            "imports:raise",
            "imports:signal",
            "imports:__stack_chk_fail",
            "call:0x404cf0",
            "call:0x404710",
            "call:0x404730",
            "call:0x40be90"
          ],
          "unknowns": [
            "Exact semantics of the global variables data_4237c8, data_4237c4, data_4237c0, and the buffers at data_4230c0/data_4230d0.",
            "Purpose of sub_40be90 and how it interacts with the rest of the program."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "anti_debug",
        "process",
        "evasion"
      ]
    },
    {
      "addr": "0x40c040",
      "original_name": "sub_40c040",
      "final_name": "ai_argument_error_report",
      "score": 74.0,
      "bb_count": 6,
      "insn_est": 55,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x413ce0",
          "name": "ai_dynamic_array_ensure_and_process",
          "original_name": "sub_413ce0"
        },
        {
          "addr": "0x4248e8"
        },
        {
          "addr": "0x413ce0",
          "name": "ai_dynamic_array_ensure_and_process",
          "original_name": "sub_413ce0"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "dcgettext",
        "error",
        "dcgettext",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "invalid argument %s for %s",
        "ambiguous argument %s for %s"
      ],
      "constants": [
        "0x41ae9e",
        "0x4048c0",
        "0x41aeb9",
        "0x423040",
        "0x413ce0",
        "0x4048f0",
        "0x404c30"
      ],
      "snippets": {
        "asm": "  0x40c040  endbr64 \n  0x40c044  push    rbp {__saved_rbp}\n  0x40c045  mov     rbp, rsp {__saved_rbp}\n  0x40c048  push    r13 {__saved_r13}\n  0x40c04a  push    r12 {__saved_r12}\n  0x40c04c  mov     r12, rdi\n  0x40c04f  push    rbx {__saved_rbx}\n  0x40c050  mov     rbx, rsi\n  0x40c053  sub     rsp, 0x48\n  0x40c057  mov     rax, qword [fs:0x28]\n  0x40c060  mov     qword [rbp-0x28 {var_30}], rax\n  0x40c064  xor     eax, eax  {0x0}\n  0x40c066  cmp     rdx, 0xffffffffffffffff\n  0x40c06a  mov     edx, 0x5\n  0x40c06f  je      0x40c0f0\n  0x40c0f0  lea     rsi, [rel data_41ae9e]  {\"invalid argument %s for %s\"}\n  0x40c0f7  xor     edi, edi  {0x0}\n  0x40c0f9  call    dcgettext\n  0x40c0fe  mov     r13, rax\n  0x40c101  jmp     0x40c082\n  0x40c071  lea     rsi, [rel data_41aeb9]  {\"ambiguous argument %s for %s\"}\n  0x40c078  xor     edi, edi  {0x0}\n  0x40c07a  call    dcgettext\n  0x40c07f  mov     r13, rax\n  0x40c082  mov     rsi, r12\n  0x40c085  lea     rdx, [rel data_423040]\n  0x40c08c  mov     edi, 0x1\n  0x40c091  call    sub_413ce0\n  0x40c096  pxor    xmm0, xmm0\n  0x40c09a  lea     rdx, [rbp-0x60 {var_68}]\n  ... (203 bytes total, truncated)",
        "hlil": "void* fsbase\nint64_t rax = *(fsbase + 0x28)\nchar* r13\nif (arg3 == -1)\nr13 = dcgettext(nullptr, \"invalid argument %s for %s\", 5)\nr13 = dcgettext(nullptr, \"ambiguous argument %s for %s\", 5)\nchar* rax_3 = sub_413ce0(1, arg1, &data_423040)\nint128_t var_60\n__builtin_memset(&var_60, 0, 0x30)\nint64_t var_68 = 8\nchar* rax_4 = sub_413ce0(0, arg2, &var_68)\n*(fsbase + 0x28)\nif (rax == *(fsbase + 0x28))\nreturn error(0, 0, r13, rax_4, rax_3) __tailcall\n__stack_chk_fail()\nnoreturn",
        "pseudoc": "{\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    char* r13;\n    \n    if (arg3 == -1)\n        r13 = dcgettext(nullptr, \"invalid argument %s for %s\", 5);\n    else\n        r13 = dcgettext(nullptr, \"ambiguous argument %s for %s\", 5);\n    \n    char* rax_3 = sub_413ce0(1, arg1, &data_423040);\n    int128_t var_60;\n    __builtin_memset(&var_60, 0, 0x30);\n    int64_t var_68 = 8;\n    char* rax_4 = sub_413ce0(0, arg2, &var_68);\n    *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n        /* tailcall */\n        return error(0, 0, r13, rax_4, rax_3);\n    \n    __stack_chk_fail();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_argument_error_report",
          "confidence": 0.92,
          "rationale": "The function formats and emits localized error messages for invalid or ambiguous command-line arguments, using dcgettext and error functions.",
          "evidence_refs": [
            "strings:invalid argument %s for %s",
            "strings:ambiguous argument %s for %s",
            "imports:error",
            "imports:dcgettext",
            "call:0x413ce0"
          ],
          "tags": [],
          "alt_names": [
            "ai_invalid_argument_error",
            "ai_ambiguous_argument_error"
          ]
        },
        "explain": {
          "summary": "sub_40c040 formats and reports an argument error, selecting between \"invalid\" and \"ambiguous\" messages based on a flag, localizing the text via dcgettext, and then invoking the GNU error() function. It builds string representations of the offending argument and its context using sub_413ce0, checks the stack canary for integrity, and aborts on mismatch.",
          "details": [
            "If arg3 equals -1 the function chooses the \"invalid argument %s for %s\" template; otherwise it uses \"ambiguous argument %s for %s\" (strings evidence).",
            "It calls sub_413ce0 twice to format arg1 and arg2 into printable strings (calls evidence).",
            "The localized format string and the two formatted arguments are passed to error(0,0,...) which prints the message and exits.",
            "A stack canary read from FS:0x28 is verified after the calls; on mismatch __stack_chk_fail() is invoked."
          ],
          "evidence_refs": [
            "strings:invalid argument %s for %s",
            "strings:ambiguous argument %s for %s",
            "imports:dcgettext",
            "imports:error",
            "imports:__stack_chk_fail",
            "call:0x413ce0",
            "call:0x4048c0"
          ],
          "unknowns": [
            "Exact meaning of arg1 and arg2 (likely option name and value) is inferred but not confirmed.",
            "The return value of error() and whether the function ever returns normally."
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40c110",
      "original_name": "sub_40c110",
      "final_name": "ai_validate_dot_extension",
      "score": 59.6,
      "bb_count": 25,
      "insn_est": 67,
      "callers": 2,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x40c110  endbr64 \n  0x40c114  mov     rcx, rdi\n  0x40c117  xor     eax, eax  {0x0}\n  0x40c119  mov     rdi, qword [rsi]\n  0x40c11c  xor     r9d, r9d  {0x0}\n  0x40c11f  jmp     0x40c12d\n  0x40c12d  test    rdi, rdi\n  0x40c130  js      0x40c19c\n  0x40c19c  cmp     byte [rcx+rax], 0x0\n  0x40c1a0  je      0x40c1b8\n  0x40c132  cmp     rdi, rax\n  0x40c135  je      0x40c1b8\n  0x40c1b8  mov     qword [rsi], rax\n  0x40c1bb  mov     rax, r9\n  0x40c1be  retn     {__return_addr}\n  0x40c1a2  lea     r9, [rax+0x1]\n  0x40c1a6  add     rax, 0x2\n  0x40c1aa  cmp     rax, rdi\n  0x40c1ad  jb      0x40c14c\n  0x40c13b  lea     r9, [rax+0x1]\n  0x40c13f  add     rax, 0x2\n  0x40c143  cmp     rax, rdi\n  0x40c146  jae     0x40c1da\n  0x40c14c  mov     rax, r9\n  0x40c14f  nop     \n  0x40c1af  mov     rax, r9\n  0x40c1b2  cmp     byte [rcx+rax], 0x0\n  0x40c1b6  jne     0x40c1a2\n  0x40c1da  mov     rax, r9\n  0x40c1dd  jmp     0x40c132\n  ... (202 bytes total, truncated)",
        "hlil": "int64_t result_1 = 0\nint64_t rdi = *arg2\nint64_t result = 0\nlabel_40c12d:\nif (rdi s>= 0)\nwhile (true)\nif (rdi == result_1)\ngoto label_40c1b8\nresult = result_1 + 1\nif (result_1 + 2 u>= rdi)\nresult_1 = result\nlabel_40c14c:\nresult_1 = result\nlabel_40c150:\nif (arg1[result_1] != 0x2e)\ngoto label_40c12d\nchar rdx_1 = arg1[result_1 + 1]\nif (rdx_1 s<= 0x5a)\nif (rdx_1 s<= 0x40)\ngoto label_40c12d\nif (rdx_1 - 0x61 u> 0x19 && rdx_1 != 0x7e)\ngoto label_40c12d\nresult_1 += 2\nif (result_1 u< rdi)\nlabel_40c178:\nchar rdx_2 = arg1[result_1]\nif (rdx_2 s> 0x5a)\nif (rdx_2 - 0x61 u<= 0x19 || rdx_2 == 0x7e)\nlabel_40c1cf:\nresult_1 += 1\nif (result_1 u< rdi)\ngoto label_40c178\nif (rdx_2 s> 0x40 || rdx_2 - 0x30 u<= 9)\ngoto label_40c1cf\nif (result_1 + 1 u< rdi)\ngoto label_40c150\nif (rdi s< 0)\nbreak\nwhile (arg1[result_1] != 0)\nresult = result_1 + 1\n// ... truncated",
        "pseudoc": "{\n    int64_t result_1 = 0;\n    int64_t rdi = *(uint64_t*)arg2;\n    int64_t result = 0;\nlabel_40c12d:\n    \n    if (rdi >= 0)\n    {\n        while (true)\n        {\n            if (rdi == result_1)\n                goto label_40c1b8;\n            \n            result = result_1 + 1;\n            \n            if (result_1 + 2 >= rdi)\n                result_1 = result;\n            else\n            {\n            label_40c14c:\n                result_1 = result;\n            label_40c150:\n                \n                if (arg1[result_1] != 0x2e)\n                    goto label_40c12d;\n                \n                char rdx_1 = arg1[result_1 + 1];\n                \n                if (rdx_1 <= 0x5a)\n                {\n                    if (rdx_1 <= 0x40)\n                        goto label_40c12d;\n                }\n                else if (rdx_1 - 0x61 > 0x19 && rdx_1 != 0x7e)\n                    goto label_40c12d;\n                \n                result_1 += 2;\n                \n                if (result_1 < rdi)\n                {\n                label_40c178:\n                    char rdx_2 = arg1[result_1];\n                    \n                    if (rdx_2 > 0x5a)\n                    {\n                        if (rdx_2 - 0x61 <= 0x19 || rdx_2 == 0x7e)\n                        {\n                        label_40c1cf:\n                            result_1 += 1;\n                            \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_validate_dot_extension",
          "confidence": 0.78,
          "rationale": "The function scans a buffer for a '.' character followed by alphanumeric or '~' characters, typical of validating a file extension or dot-prefixed token.",
          "evidence_refs": [
            "strings:none",
            "imports:none",
            "call:0x40c110"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_check_dot_segment",
            "ai_is_valid_extension"
          ]
        },
        "explain": {
          "summary": "The function scans a buffer of length given by the second argument, looking for a '.' character followed by alphabetic characters (AZ, az) or a tilde '~', likely to detect or validate a file extension within the string.",
          "details": [
            "It reads the length of the input string from arg2 (rdi) and iterates over the buffer arg1 using an index (result_1).",
            "When a '.' (0x2e) is found, it checks the next character to ensure it is a letter or '~', then continues advancing the index over subsequent valid extension characters."
          ],
          "evidence_refs": [
            "strings:0x2e",
            "imports:none",
            "call:none"
          ],
          "unknowns": [
            "Exact return value or purpose of label_40c1b8 (e.g., whether it returns a boolean, index, or length).",
            "How the function handles strings without a dot or with invalid characters beyond the scanned portion."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40c1f0",
      "original_name": "sub_40c1f0",
      "final_name": "ai_is_digit_string",
      "score": 194.4,
      "bb_count": 82,
      "insn_est": 218,
      "callers": 2,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x100",
        "0xffffffff",
        "0x101",
        "0xfffffffe"
      ],
      "snippets": {
        "asm": "  0x40c1f0  endbr64 \n  0x40c1f4  push    rbp {__saved_rbp}\n  0x40c1f5  mov     r8, rdx\n  0x40c1f8  xor     eax, eax  {0x0}\n  0x40c1fa  xor     edx, edx  {0x0}\n  0x40c1fc  mov     rbp, rsp {__saved_rbp}\n  0x40c1ff  push    r12 {__saved_r12}\n  0x40c201  push    rbx {__saved_rbx}\n  0x40c219  movsx   r10d, byte [rdi+rax]\n  0x40c21e  mov     r9d, r10d\n  0x40c221  sub     r10d, 0x30\n  0x40c225  cmp     r10d, 0x9\n  0x40c229  jbe     0x40c2c8\n  0x40c207  cmp     rdx, rcx\n  0x40c20a  jge     0x40c4d8\n  0x40c2c8  cmp     rdx, rcx\n  0x40c2cb  jge     0x40c2e4\n  0x40c22f  cmp     r9b, 0x5a\n  0x40c233  jg      0x40c290\n  0x40c4d8  xor     ebx, ebx  {0x0}\n  0x40c4da  jmp     0x40c2bb\n  0x40c210  cmp     rax, rsi\n  0x40c213  jge     0x40c2c8\n  0x40c2e4  cmp     rax, rsi\n  0x40c2e7  jl      0x40c2f9\n  0x40c2cd  movzx   r11d, byte [r8+rdx]\n  0x40c2d2  movsx   r10d, r11b\n  0x40c2d6  lea     r9d, [r10-0x30]\n  0x40c2da  cmp     r9d, 0x9\n  0x40c2de  ja      0x40c3b0\n  ... (807 bytes total, truncated)",
        "hlil": "int64_t rax = 0\nint64_t rdx = 0\nlabel_40c202:\nif (rax s< arg2)\ngoto label_40c219\nlabel_40c207:\nif (rdx s>= arg4)\nlabel_40c2c1:\nreturn 0\nint32_t rbx_1\nwhile (true)\nif (rax s>= arg2)\ngoto label_40c2cb\nlabel_40c219:\nint32_t r10_1 = sx.d(arg1[rax])\nchar r9_1 = r10_1.b\nint32_t r10_5\nchar r12_1\nif (r10_1 - 0x30 u<= 9)\nlabel_40c2cb:\nuint32_t r11_1\nif (rdx s< arg4)\nr11_1 = zx.d(arg3[rdx])\nr10_5 = sx.d(r11_1.b)\nif (rdx s>= arg4 || r10_5 - 0x30 u<= 9)\nif (rax s>= arg2)\nif (rdx s< arg4)\nbreak\ngoto label_40c202\nlabel_40c2f9:\nif (arg1[rax] == 0x30)\nrax += 1\nif (arg2 != rax)\ngoto label_40c2f9\nif (rdx s< arg4)\ngoto label_40c31d\nrbx_1 = 0\nif (rax s< arg2)\ngoto label_40c37e\ngoto label_40c207\n// ... truncated",
        "pseudoc": "{\n    int64_t rax = 0;\n    int64_t rdx = 0;\nlabel_40c202:\n    \n    if (rax < arg2)\n        goto label_40c219;\n    \nlabel_40c207:\n    \n    if (rdx >= arg4)\n    {\n    label_40c2c1:\n        return 0;\n    }\n    \n    int32_t rbx_1;\n    \n    while (true)\n    {\n        if (rax >= arg2)\n            goto label_40c2cb;\n        \n    label_40c219:\n        int32_t r10_1 = (int32_t)arg1[rax];\n        char r9_1 = (uint8_t)r10_1;\n        int32_t r10_5;\n        char r12_1;\n        \n        if (r10_1 - 0x30 <= 9)\n        {\n        label_40c2cb:\n            uint32_t r11_1;\n            \n            if (rdx < arg4)\n            {\n                r11_1 = (uint32_t)arg3[rdx];\n                r10_5 = (int32_t)(char)r11_1;\n            }\n            \n            if (rdx >= arg4 || r10_5 - 0x30 <= 9)\n            {\n                if (rax >= arg2)\n                {\n                    if (rdx < arg4)\n                        break;\n                    \n                    goto label_40c202;\n                }\n                \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_is_digit_string",
          "confidence": 0.86,
          "rationale": "The function iterates over two buffers, checking each byte to see if it falls within the ASCII range for digits (0x30-0x39), indicating a numeric string validation routine.",
          "evidence_refs": [],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_validate_numeric",
            "ai_check_digit_buffer"
          ]
        },
        "explain": {
          "summary": "The function iterates over two input buffers, using indices rax and rdx, and checks each character to see if it is a decimal digit (0x30-0x39). It stops when either buffer length is reached or a nondigit is encountered, returning 0 in the termination case.",
          "details": [
            "The loop compares characters from arg1[rax] and arg3[rdx] against the digit range by testing r10_1 - 0x30 <= 9.",
            "If the index rdx reaches arg4 (the length of the second buffer), the function jumps to a return of 0."
          ],
          "evidence_refs": [],
          "unknowns": [
            "Exact behavior when both characters are digits (e.g., whether it computes a numeric comparison or just validates).",
            "The purpose of the constants 0x100, 0xffffffff, 0x101, 0xfffffffe which are not referenced in the shown snippet."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40c560",
      "original_name": "sub_40c560",
      "final_name": "ai_buffer_grow",
      "score": 44.9,
      "bb_count": 8,
      "insn_est": 38,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        }
      ],
      "import_refs": [
        "free",
        "malloc",
        "__errno_location"
      ],
      "string_refs": [],
      "constants": [
        "0x4046b0",
        "0x404760",
        "0x4046d0",
        "0x400"
      ],
      "snippets": {
        "asm": "  0x40c560  endbr64 \n  0x40c564  push    rbp {__saved_rbp}\n  0x40c565  mov     rbp, rsp {__saved_rbp}\n  0x40c568  push    r13 {__saved_r13}\n  0x40c56a  push    r12 {__saved_r12}\n  0x40c56c  push    rbx {__saved_rbx}\n  0x40c56d  mov     rbx, rdi\n  0x40c570  lea     r13, [rbx+0x10]\n  0x40c574  sub     rsp, 0x8\n  0x40c578  mov     rax, qword [rdi+0x8]\n  0x40c57c  mov     rdi, qword [rdi]\n  0x40c57f  lea     r12, [rax+rax]\n  0x40c583  cmp     rdi, r13\n  0x40c586  je      0x40c591\n  0x40c591  cmp     r12, rax\n  0x40c594  jb      0x40c5c0\n  0x40c588  call    free\n  0x40c58d  mov     rax, qword [rbx+0x8]\n  0x40c5c0  call    __errno_location\n  0x40c5c5  mov     dword [rax], 0xc\n  0x40c596  mov     rdi, r12\n  0x40c599  call    malloc\n  0x40c59e  test    rax, rax\n  0x40c5a1  je      0x40c5cb\n  0x40c5a8  mov     qword [rbx], rax\n  0x40c5ab  mov     eax, edx\n  0x40c5ad  mov     qword [rbx+0x8], r12\n  0x40c5b1  add     rsp, 0x8\n  0x40c5b5  pop     rbx {__saved_rbx}\n  0x40c5b6  pop     r12 {__saved_r12}\n  ... (116 bytes total, truncated)",
        "hlil": "int64_t rax = arg1[1]\nint64_t rdi = *arg1\nsize_t n = rax * 2\nif (rdi != &arg1[2])\nfree(rdi)\nrax = arg1[1]\nvoid* rax_1\nint32_t rdx\nif (n u< rax)\n*__errno_location() = 0xc\nlabel_40c5cb:\nrax_1 = &arg1[2]\nn = 0x400\nrdx = 0\nrax_1 = malloc(n)\nif (rax_1 == 0)\ngoto label_40c5cb\nrdx = 1\n*arg1 = rax_1\narg1[1] = n\nreturn zx.q(rdx)",
        "pseudoc": "{\n    int64_t rax = arg1[1];\n    int64_t rdi = *(uint64_t*)arg1;\n    size_t n = rax * 2;\n    \n    if (rdi != &arg1[2])\n    {\n        free(rdi);\n        rax = arg1[1];\n    }\n    \n    void* rax_1;\n    int32_t rdx;\n    \n    if (n < rax)\n    {\n        *(uint32_t*)__errno_location() = 0xc;\n    label_40c5cb:\n        rax_1 = &arg1[2];\n        n = 0x400;\n        rdx = 0;\n    }\n    else\n    {\n        rax_1 = malloc(n);\n        \n        if (!rax_1)\n            goto label_40c5cb;\n        \n        rdx = 1;\n    }\n    \n    *(uint64_t*)arg1 = rax_1;\n    arg1[1] = n;\n    return (uint64_t)rdx;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_buffer_grow",
          "confidence": 0.92,
          "rationale": "The function checks a buffer pointer, frees existing memory if needed, doubles the allocated size, allocates new memory with malloc, falls back to a static buffer on failure, and updates the buffer metadata. This matches typical buffer resizing/growth logic.",
          "evidence_refs": [
            "imports:free",
            "imports:malloc",
            "imports:__errno_location",
            "call:0x4046b0",
            "call:0x4046d0",
            "call:0x404760"
          ],
          "tags": [],
          "alt_names": [
            "ai_buffer_resize",
            "ai_expand_buffer"
          ]
        },
        "explain": {
          "summary": "The function expands a buffer stored in a two-element structure, freeing any previously allocated memory, attempting to double its size, and falling back to a static 0x400-byte buffer on overflow or allocation failure, while setting errno on error.",
          "details": [
            "It reads the current buffer pointer (arg1[0]) and size (arg1[1]), computes a new size n = old_size * 2.",
            "If the current pointer is not the address of the internal static buffer (&arg1[2]), it frees the existing allocation.",
            "If the size calculation overflows (n < old_size) or malloc fails, it sets errno to ENOMEM (0xc), uses the static buffer at &arg1[2] with size 0x400, and returns 0.",
            "On successful allocation, it stores the new pointer and size in the structure and returns 1."
          ],
          "evidence_refs": [
            "imports:free",
            "imports:malloc",
            "imports:__errno_location",
            "call:0x4046b0",
            "call:0x4046d0",
            "call:0x404760"
          ],
          "unknowns": [
            "Exact semantics of the structure layout beyond the two fields used",
            "Whether the static buffer is preinitialized elsewhere"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40c5e0",
      "original_name": "sub_40c5e0",
      "final_name": "ai_expand_buffer",
      "score": 67.8,
      "bb_count": 11,
      "insn_est": 56,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404ba0",
          "name": "ai_memory_realloc_wrapper",
          "original_name": "realloc"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404aa0",
          "name": "ai_safe_memory_copy",
          "original_name": "__memcpy_chk"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        }
      ],
      "import_refs": [
        "realloc",
        "malloc",
        "__memcpy_chk",
        "__errno_location",
        "free"
      ],
      "string_refs": [],
      "constants": [
        "0x4046d0",
        "0x404aa0",
        "0x404760",
        "0x404ba0",
        "0x4046b0",
        "0x400"
      ],
      "snippets": {
        "asm": "  0x40c5e0  endbr64 \n  0x40c5e4  push    rbp {__saved_rbp}\n  0x40c5e5  mov     rbp, rsp {__saved_rbp}\n  0x40c5e8  push    r15 {__saved_r15}\n  0x40c5ea  lea     r15, [rdi+0x10]\n  0x40c5ee  push    r14 {__saved_r14}\n  0x40c5f0  push    r13 {__saved_r13}\n  0x40c5f2  push    r12 {__saved_r12}\n  0x40c5f4  push    rbx {__saved_rbx}\n  0x40c5f5  mov     rbx, rdi\n  0x40c5f8  sub     rsp, 0x8\n  0x40c5fc  mov     r14, qword [rdi+0x8]\n  0x40c600  mov     r13, qword [rdi]\n  0x40c603  lea     r12, [r14+r14]\n  0x40c607  cmp     r13, r15\n  0x40c60a  je      0x40c640\n  0x40c640  mov     rdi, r12\n  0x40c643  call    malloc\n  0x40c648  mov     rdi, rax\n  0x40c64b  test    rax, rax\n  0x40c64e  je      0x40c686\n  0x40c60c  cmp     r12, r14\n  0x40c60f  jb      0x40c668\n  0x40c686  xor     eax, eax  {0x0}\n  0x40c688  jmp     0x40c630\n  0x40c650  mov     rcx, r12\n  0x40c653  mov     rdx, r14\n  0x40c656  mov     rsi, r13\n  0x40c659  call    __memcpy_chk\n  0x40c65e  mov     rdi, rax\n  ... (169 bytes total, truncated)",
        "hlil": "uint64_t r14 = arg1[1]\nint64_t r13 = *arg1\nsize_t n = r14 * 2\nint64_t rdi_1\nif (r13 == &arg1[2])\nint64_t rax_2 = malloc(n)\nif (rax_2 == 0)\nreturn 0\nrdi_1 = __memcpy_chk(rax_2, r13, r14, n)\nif (n u< r14)\n*__errno_location() = 0xc\nlabel_40c676:\nfree(r13)\n*arg1 = &arg1[2]\narg1[1] = 0x400\nreturn 0\nint64_t rax = realloc(r13, n)\nrdi_1 = rax\nif (rax == 0)\nr13 = *arg1\ngoto label_40c676\n*arg1 = rdi_1\narg1[1] = n\nreturn 1",
        "pseudoc": "{\n    uint64_t r14 = arg1[1];\n    int64_t r13 = *(uint64_t*)arg1;\n    size_t n = r14 * 2;\n    int64_t rdi_1;\n    \n    if (r13 == &arg1[2])\n    {\n        int64_t rax_2 = malloc(n);\n        \n        if (!rax_2)\n            return 0;\n        \n        rdi_1 = __memcpy_chk(rax_2, r13, r14, n);\n    }\n    else\n    {\n        if (n < r14)\n        {\n            *(uint32_t*)__errno_location() = 0xc;\n        label_40c676:\n            free(r13);\n            *(uint64_t*)arg1 = &arg1[2];\n            arg1[1] = 0x400;\n            return 0;\n        }\n        \n        int64_t rax = realloc(r13, n);\n        rdi_1 = rax;\n        \n        if (!rax)\n        {\n            r13 = *(uint64_t*)arg1;\n            goto label_40c676;\n        }\n    }\n    \n    *(uint64_t*)arg1 = rdi_1;\n    arg1[1] = n;\n    return 1;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_expand_buffer",
          "confidence": 0.93,
          "rationale": "The function doubles the size of a buffer, allocating or reallocating memory and copying existing data, typical of a dynamic buffer growth routine.",
          "evidence_refs": [
            "imports:malloc",
            "imports:realloc",
            "imports:free",
            "imports:__memcpy_chk",
            "call:0x4046d0",
            "call:0x404ba0",
            "call:0x404aa0"
          ],
          "tags": [],
          "alt_names": [
            "ai_buffer_grow",
            "ai_dynamic_array_resize"
          ]
        },
        "explain": {
          "summary": "The function expands a buffer referenced by a two-element structure (pointer and size) by doubling its current length. It allocates a new block with malloc if the buffer is a static placeholder, otherwise attempts to resize with realloc, copying existing data when needed, and handles allocation failures by resetting to a default static buffer and setting errno.",
          "details": [
            "If the current buffer pointer equals the address of arg1[2] (a static buffer), it allocates a new block of size r14*2 using malloc and copies the existing data with __memcpy_chk.",
            "If the buffer is dynamically allocated, it checks for overflow, then attempts to enlarge it with realloc to double the size; on failure it frees the old buffer, resets the pointer to the static buffer, sets the size to 0x400, and records ENOMEM (error 12).",
            "On successful allocation or reallocation, it updates the structure's pointer and size fields and returns 1; otherwise it returns 0."
          ],
          "evidence_refs": [
            "imports:malloc",
            "imports:realloc",
            "imports:__memcpy_chk",
            "imports:free",
            "imports:__errno_location",
            "constants:0x400",
            "call:0x4046d0",
            "call:0x404ba0",
            "call:0x404aa0"
          ],
          "unknowns": [
            "Exact purpose and type of the structure pointed to by arg1 beyond pointer and size fields",
            "The meaning of the static buffer located at &arg1[2]"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40c6a0",
      "original_name": "sub_40c6a0",
      "final_name": "ai_check_posix_locale",
      "score": 97.7,
      "bb_count": 22,
      "insn_est": 74,
      "callers": 4,
      "callees": [
        {
          "addr": "0x404bc0",
          "name": "ai_set_locale_wrapper",
          "original_name": "setlocale"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x4248e0"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "setlocale",
        "strlen",
        "strcmp",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "POSIX"
      ],
      "constants": [
        "0x118",
        "0x404bc0",
        "0x4048e0",
        "0x100",
        "0x4048f0",
        "0xfffffffffffffee0",
        "0xfffffffffffffee1",
        "0x41aed6",
        "0x4046c0"
      ],
      "snippets": {
        "asm": "  0x40c6a0  endbr64 \n  0x40c6a4  push    rbp {__saved_rbp}\n  0x40c6a5  xor     esi, esi  {0x0}\n  0x40c6a7  mov     rbp, rsp {__saved_rbp}\n  0x40c6aa  push    rbx {__saved_rbx}\n  0x40c6ab  sub     rsp, 0x118\n  0x40c6b2  mov     rax, qword [fs:0x28]\n  0x40c6bb  mov     qword [rbp-0x18 {var_20}], rax\n  0x40c6bf  xor     eax, eax  {0x0}\n  0x40c6c1  call    setlocale\n  0x40c6c6  test    rax, rax\n  0x40c6c9  je      0x40c6de\n  0x40c6de  xor     eax, eax  {0x0}\n  0x40c6cb  mov     rdi, rax\n  0x40c6ce  mov     rbx, rax\n  0x40c6d1  call    strlen\n  0x40c6d6  cmp     rax, 0x100\n  0x40c6dc  jbe     0x40c700\n  0x40c7aa  call    __stack_chk_fail\n  0x40c7aa  { Does not return }\n  0x40c6f3  mov     rbx, qword [rbp-0x8 {__saved_rbx}]\n  0x40c6f7  leave    {__saved_rbp}\n  0x40c6f8  retn     {__return_addr}\n  0x40c700  lea     r8, [rbp-0x120 {var_128}]\n  0x40c707  add     rax, 0x1\n  0x40c70b  mov     rdi, r8 {var_128}\n  0x40c70e  cmp     eax, 0x8\n  0x40c711  jae     0x40c790\n  0x40c790  mov     ecx, eax\n  0x40c792  mov     rsi, rbx\n  ... (246 bytes total, truncated)",
        "hlil": "void* fsbase\nint64_t rax = *(fsbase + 0x28)\nint64_t entry_rcx\nint64_t entry_rdx\nuint64_t entry_r8\nssize_t entry_r9\nchar* rax_2 = setlocale(arg1, nullptr, entry_rdx, entry_rcx, entry_r8, entry_r9)\nint32_t result\nif (rax_2 == 0)\nresult = 0\nchar* rbx_1 = rax_2\nuint64_t rax_3 = strlen(rax_2)\nif (rax_3 u<= 0x100)\nchar var_128\nchar* rdi_1 = &var_128\nint64_t rdx_2\nif (rax_3.d + 1 u>= 8)\nrdx_2 = 0\nchar* rsi_2\nrdi_1, rsi_2 = __builtin_memcpy(&var_128, rbx_1, zx.q((rax_3.d + 1) u>> 3) << 3)\nrbx_1 = rsi_2\nif (((rax_3.d + 1).b & 4) == 0)\ngoto label_40c719\ngoto label_40c782\nrdx_2 = 0\nif (((rax_3.d + 1).b & 4) == 0)\nlabel_40c719:\nif (((rax_3.d + 1).b & 2) != 0)\ngoto label_40c76c\ngoto label_40c71d\nlabel_40c782:\n*rdi_1 = *rbx_1\nrdx_2 = 4\nif (((rax_3.d + 1).b & 2) != 0)\nlabel_40c76c:\n*(rdi_1 + rdx_2) = *(rbx_1 + rdx_2)\nrdx_2 += 2\nif (((rax_3.d + 1).b & 1) == 0)\ngoto label_40c721\ngoto label_40c754\n// ... truncated",
        "pseudoc": "{\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int64_t entry_rcx;\n    int64_t entry_rdx;\n    uint64_t entry_r8;\n    ssize_t entry_r9;\n    char* rax_2 = setlocale(arg1, nullptr, entry_rdx, entry_rcx, entry_r8, entry_r9);\n    int32_t result;\n    \n    if (!rax_2)\n        result = 0;\n    else\n    {\n        char* rbx_1 = rax_2;\n        uint64_t rax_3 = strlen(rax_2);\n        \n        if (rax_3 <= 0x100)\n        {\n            char var_128;\n            char* rdi_1 = &var_128;\n            int64_t rdx_2;\n            \n            if ((uint32_t)rax_3 + 1 >= 8)\n            {\n                rdx_2 = 0;\n                char* rsi_2;\n                rdi_1 =\n                    __builtin_memcpy(&var_128, rbx_1, (uint64_t)(((uint32_t)rax_3 + 1) >> 3) << 3);\n                rbx_1 = rsi_2;\n                \n                if (!(((uint32_t)rax_3 + 1) & 4))\n                    goto label_40c719;\n                \n                goto label_40c782;\n            }\n            \n            rdx_2 = 0;\n            \n            if (!(((uint32_t)rax_3 + 1) & 4))\n            {\n            label_40c719:\n                \n                if (((uint32_t)rax_3 + 1) & 2)\n                    goto label_40c76c;\n                \n                goto label_40c71d;\n            }\n            \n        label_40c782:\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_check_posix_locale",
          "confidence": 0.78,
          "rationale": "The function calls setlocale, retrieves the locale string, checks its length, copies it, and likely compares it against the 'POSIX' string, indicating it checks if the current locale is POSIX.",
          "evidence_refs": [
            "strings:POSIX",
            "imports:setlocale",
            "imports:strcmp",
            "call:0x404bc0",
            "call:0x4048e0"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_is_posix_locale",
            "ai_detect_locale"
          ]
        },
        "explain": {
          "summary": "sub_40c6a0 obtains the current locale string via setlocale, ensures it is not longer than 256 bytes, copies it into a local buffer, and compares it against the literal \"POSIX\" to determine if the process is running in the POSIX locale.",
          "details": [
            "Calls setlocale with a NULL locale argument to retrieve the current locale string.",
            "If the returned pointer is NULL the function returns 0; otherwise it measures the string length with strlen.",
            "The length is limited to 0x100 bytes and the string is copied into a stack buffer (var_128) using memcpy with alignment handling.",
            "The copied string is then compared to the constant \"POSIX\" using strcmp, and the result of this comparison is returned as a boolean indicator."
          ],
          "evidence_refs": [
            "strings:POSIX",
            "imports:setlocale",
            "imports:strlen",
            "imports:strcmp",
            "call:0x404bc0",
            "call:0x4048e0",
            "call:0x4046c0"
          ],
          "unknowns": [
            "Exact return value semantics (whether 1 indicates POSIX or nonPOSIX).",
            "Any additional locale handling beyond the POSIX check."
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x40c7b0",
      "original_name": "sub_40c7b0",
      "final_name": "ai_validate_float_bounds",
      "score": 62.4,
      "bb_count": 11,
      "insn_est": 33,
      "callers": 3,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x419600",
        "0x419004",
        "0x3dcccccd",
        "0x419008",
        "0x3f666666",
        "0x41900c",
        "0x3f8ccccd",
        "0x419010",
        "0x3f800000"
      ],
      "snippets": {
        "asm": "  0x40c7b0  endbr64 \n  0x40c7b4  mov     rax, qword [rdi+0x28]\n  0x40c7b8  lea     rdx, [rel data_419600]\n  0x40c7bf  cmp     rax, rdx\n  0x40c7c2  je      0x40c830\n  0x40c830  mov     eax, 0x1\n  0x40c7c4  movss   xmm0, dword [rax+0x8]\n  0x40c7c9  comiss  xmm0, dword [rel data_419004]\n  0x40c7d0  jbe     0x40c823\n  0x40c823  mov     qword [rdi+0x28], rdx  {data_419600}\n  0x40c827  xor     eax, eax  {0x0}\n  0x40c829  retn     {__return_addr}\n  0x40c7d2  movss   xmm1, dword [rel data_419008]  {0x3f666666}\n  0x40c7da  comiss  xmm1, xmm0\n  0x40c7dd  jbe     0x40c823\n  0x40c7df  movss   xmm1, dword [rax+0xc]\n  0x40c7e4  comiss  xmm1, dword [rel data_41900c]\n  0x40c7eb  jbe     0x40c823\n  0x40c7ed  movss   xmm1, dword [rax]\n  0x40c7f1  pxor    xmm2, xmm2\n  0x40c7f5  comiss  xmm1, xmm2\n  0x40c7f8  jb      0x40c823\n  0x40c7fa  addss   xmm1, dword [rel data_419004]\n  0x40c802  movss   xmm2, dword [rax+0x4]\n  0x40c807  comiss  xmm2, xmm1\n  0x40c80a  jbe     0x40c823\n  0x40c80c  movss   xmm3, dword [rel data_419010]  {0x3f800000}\n  0x40c814  comiss  xmm3, xmm2\n  0x40c817  jb      0x40c823\n  0x40c819  comiss  xmm0, xmm1\n  ... (128 bytes total, truncated)",
        "hlil": "int32_t* rax = *(arg1 + 0x28)\nif (rax != &data_419600)\nfloat zmm0 = rax[2]\nif (zmm0 <= 0.100000001f || 0.899999976f <= zmm0 || rax[3] f<= 1.10000002f)\n*(arg1 + 0x28) = &data_419600\nreturn 0\nfloat zmm1 = *rax\nif (zmm1 < 0f)\n*(arg1 + 0x28) = &data_419600\nreturn 0\nzmm1 = zmm1 + 0.100000001f\nint32_t zmm2 = rax[1]\nif (zmm2 f<= zmm1 || 1f f< zmm2 || not(zmm0 > zmm1))\n*(arg1 + 0x28) = &data_419600\nreturn 0\nreturn 1",
        "pseudoc": "{\n    int32_t* rax = *(uint64_t*)((char*)arg1 + 0x28);\n    \n    if (rax != &data_419600)\n    {\n        float zmm0 = rax[2];\n        \n        if (zmm0 <= 0.100000001f || 0.899999976f <= zmm0 || rax[3] <= 1.10000002f)\n        {\n            *(uint64_t*)((char*)arg1 + 0x28) = &data_419600;\n            return 0;\n        }\n        \n        float zmm1 = *(uint32_t*)rax;\n        \n        if (zmm1 < 0f)\n        {\n            *(uint64_t*)((char*)arg1 + 0x28) = &data_419600;\n            return 0;\n        }\n        \n        zmm1 = zmm1 + 0.100000001f;\n        int32_t zmm2 = rax[1];\n        \n        if (zmm2 <= zmm1 || 1f < zmm2 || !(zmm0 > zmm1))\n        {\n            *(uint64_t*)((char*)arg1 + 0x28) = &data_419600;\n            return 0;\n        }\n    }\n    \n    return 1;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_validate_float_bounds",
          "confidence": 0.86,
          "rationale": "The function checks a structure of floating-point values against specific range thresholds (0.1, 0.9, 1.0, 1.1) and resets the pointer on failure, indicating it validates parameter bounds.",
          "evidence_refs": [],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_check_parameter_constraints",
            "ai_validate_numeric_range"
          ]
        },
        "explain": {
          "summary": "The function validates a floatingpoint configuration structure referenced at arg1+0x28, ensuring its fields lie within specific ranges; if any check fails it resets the pointer to a default data block and returns false, otherwise it returns true.",
          "details": [
            "If the pointer does not already point to the default data_419600, the function reads several float values from the structure (offsets 0, 1, 2, 3) and checks that they satisfy range constraints (e.g., field2 between 0.1 and 0.9, field4 > 1.1, field1 >= 0, field1+0.1 < field2 <= 1.0, and field3 > field1+0.1).",
            "When any constraint is violated, the pointer is overwritten with the address of data_419600 and the function returns 0; otherwise it returns 1."
          ],
          "evidence_refs": [
            "call:0x40c7b0"
          ],
          "unknowns": [
            "Exact semantic meaning of each float field in the structure",
            "Origin and layout of the data_419600 block"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40c840",
      "original_name": "sub_40c840",
      "final_name": "ai_cleanup_linked_structure",
      "score": 84.7,
      "bb_count": 21,
      "insn_est": 79,
      "callers": 3,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        }
      ],
      "import_refs": [
        "__errno_location",
        "free",
        "free",
        "free",
        "free"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x4046b0"
      ],
      "snippets": {
        "asm": "  0x40c840  endbr64 \n  0x40c844  push    rbp {__saved_rbp}\n  0x40c845  mov     rbp, rsp {__saved_rbp}\n  0x40c848  push    r15 {__saved_r15}\n  0x40c84a  push    r14 {__saved_r14}\n  0x40c84c  push    r13 {__saved_r13}\n  0x40c84e  mov     r13, rdi\n  0x40c851  push    r12 {__saved_r12}\n  0x40c853  push    rbx {__saved_rbx}\n  0x40c854  sub     rsp, 0x8\n  0x40c858  call    __errno_location\n  0x40c85d  cmp     qword [r13+0x40], 0x0\n  0x40c862  mov     r12, qword [r13]\n  0x40c866  mov     r15d, dword [rax]\n  0x40c869  mov     r14, rax\n  0x40c86c  mov     rax, qword [r13+0x8]\n  0x40c870  je      0x40c8c0\n  0x40c8c0  mov     r12, qword [r13]\n  0x40c8c4  cmp     r12, rax\n  0x40c8c7  jae     0x40c8fb\n  0x40c872  cmp     qword [r13+0x20], 0x0\n  0x40c877  je      0x40c8c0\n  0x40c8fb  mov     rbx, qword [r13+0x48]\n  0x40c8ff  test    rbx, rbx\n  0x40c902  je      0x40c919\n  0x40c8c9  nop     dword [rax]\n  0x40c879  cmp     r12, rax\n  0x40c87c  jb      0x40c88d\n  0x40c919  mov     rdi, qword [r13]\n  0x40c91d  call    free\n  ... (247 bytes total, truncated)",
        "hlil": "int32_t* rax = __errno_location()\nint64_t* i_4 = *arg1\nint32_t r15 = *rax\nint64_t rax_1 = arg1[1]\nif (arg1[8] == 0 || arg1[4] == 0)\nlabel_40c8c0:\nvoid* i = *arg1\nif (i u< rax_1)\nvoid* j = *(i + 8)\nwhile (j != 0)\nvoid* j_1 = j\nj = *(j + 8)\nfree(j_1)\ni += 0x10\ndo while (i u< arg1[1])\nif (i_4 u< rax_1)\nwhile (true)\nif (*i_4 == 0)\nrax_1 = arg1[1]\ni_4 = &i_4[2]\nif (i_4 u>= rax_1)\nbreak\nint64_t* i_1 = i_4\narg1[8]()\ni_1 = i_1[1]\ndo while (i_1 != 0)\nrax_1 = arg1[1]\ni_4 = &i_4[2]\nif (i_4 u>= rax_1)\nbreak\ngoto label_40c8c0\nvoid* i_2 = arg1[9]\nwhile (i_2 != 0)\nvoid* i_3 = i_2\ni_2 = *(i_2 + 8)\nfree(i_3)\nfree(*arg1)\nint64_t result = free(arg1)\n*rax = r15\nreturn result\n// ... truncated",
        "pseudoc": "{\n    int32_t* rax = __errno_location();\n    int64_t* i_4 = *(uint64_t*)arg1;\n    int32_t r15 = *(uint32_t*)rax;\n    int64_t rax_1 = arg1[1];\n    \n    if (!arg1[8] || !arg1[4])\n    {\n    label_40c8c0:\n        void* i = *(uint64_t*)arg1;\n        \n        if (i < rax_1)\n        {\n            do\n            {\n                void* j = *(uint64_t*)((char*)i + 8);\n                \n                while (j)\n                {\n                    void* j_1 = j;\n                    j = *(uint64_t*)((char*)j + 8);\n                    free(j_1);\n                }\n                \n                i += 0x10;\n            } while (i < arg1[1]);\n        }\n    }\n    else if (i_4 < rax_1)\n    {\n        while (true)\n        {\n            if (!*(uint64_t*)i_4)\n            {\n                rax_1 = arg1[1];\n                i_4 = &i_4[2];\n                \n                if (i_4 >= rax_1)\n                    break;\n            }\n            else\n            {\n                int64_t* i_1 = i_4;\n                \n                do\n                {\n                    arg1[8]();\n                    i_1 = i_1[1];\n                } while (i_1);\n                \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_cleanup_linked_structure",
          "confidence": 0.78,
          "rationale": "The function iterates over a collection of pointers, freeing nested linked lists and associated memory, indicating a cleanup/deallocation routine for a data structure.",
          "evidence_refs": [
            "imports:free",
            "imports:__errno_location",
            "call:0x404760",
            "call:0x4046b0"
          ],
          "tags": [],
          "alt_names": [
            "ai_free_nested_list",
            "ai_deallocate_structure"
          ]
        },
        "explain": {
          "summary": "sub_40c840 walks a container structure passed in arg1 and frees all allocated elements, handling two cleanup paths depending on flags at offsets 4 and 8. It iterates over an array of entries, freeing linked lists within each entry, and finally frees the array itself.",
          "details": [
            "The function obtains the current errno pointer via __errno_location but does not modify it in the shown code.",
            "If either arg1[8] or arg1[4] is zero, it treats the structure as a simple array of pointers and frees each linked list found at offset 8 of each entry.",
            "If both flags are non-zero, it iterates over the entries, calling a function pointer stored at arg1[8] to free each node in a linked list until the list ends.",
            "Memory is released using the imported free function throughout the loops."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:free",
            "call:0x404760",
            "call:0x4046b0"
          ],
          "unknowns": [
            "Exact meaning of arg1[4] and arg1[8] fields and the overall data structure type",
            "What additional cleanup may occur after the truncated portion of the function"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40c940",
      "original_name": "sub_40c940",
      "final_name": "ai_safe_malloc",
      "score": 141.1,
      "bb_count": 33,
      "insn_est": 132,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        },
        {
          "addr": "0x409a50",
          "name": "ai_hash_table_lookup",
          "original_name": "sub_409a50"
        },
        {
          "addr": "0x40c7b0",
          "name": "ai_validate_float_bounds",
          "original_name": "sub_40c7b0"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x40b590",
          "name": "ai_ensure_capacity",
          "original_name": "sub_40b590"
        },
        {
          "addr": "0x409a50",
          "name": "ai_hash_table_lookup",
          "original_name": "sub_409a50"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "abort",
        "__errno_location",
        "malloc",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x404750",
        "0x409a50",
        "0x4048f0",
        "0x40c7b0",
        "0x419014",
        "0x5f800000",
        "0x4046d0",
        "0x419018",
        "0x5f000000",
        "0x404760",
        "0x8000000000000000",
        "0xffffffff",
        "0x40b590"
      ],
      "snippets": {
        "asm": "  0x40c940  endbr64 \n  0x40c944  push    rbp {__saved_rbp}\n  0x40c945  mov     rbp, rsp {__saved_rbp}\n  0x40c948  push    r14 {__saved_r14}\n  0x40c94a  push    r13 {__saved_r13}\n  0x40c94c  push    r12 {__saved_r12}\n  0x40c94e  push    rbx {__saved_rbx}\n  0x40c94f  sub     rsp, 0x10\n  0x40c953  mov     rax, qword [fs:0x28]\n  0x40c95c  mov     qword [rbp-0x28 {var_30}], rax\n  0x40c960  xor     eax, eax  {0x0}\n  0x40c962  test    rsi, rsi\n  0x40c965  je      0x404d7f\n  0x404d7f  call    abort\n  0x404d7f  { Does not return }\n  0x40c96b  lea     r14, [rbp-0x30 {var_38}]\n  0x40c96f  mov     r13, rdx\n  0x40c972  xor     ecx, ecx  {0x0}\n  0x40c974  mov     rbx, rdi\n  0x40c977  mov     rdx, r14 {var_38}\n  0x40c97a  mov     r12, rsi\n  0x40c97d  call    sub_409a50\n  0x40c982  test    rax, rax\n  0x40c985  je      0x40c9b0\n  0x40c9b0  mov     rax, qword [rbx+0x18]\n  0x40c9b4  test    rax, rax\n  0x40c9b7  js      0x40ca38\n  0x40c987  mov     qword [r13], rax\n  0x40c98b  xor     eax, eax  {0x0}\n  0x40ca38  mov     rdx, rax\n  ... (523 bytes total, truncated)",
        "hlil": "void* fsbase\nint64_t rax = *(fsbase + 0x28)\nif (arg2 != 0)\nint64_t* var_38\nint64_t rax_2 = sub_409a50(arg1, arg2, &var_38, 0)\nint64_t result\nif (rax_2 != 0)\n*arg3 = rax_2\nresult = 0\nlabel_40c991:\n*(fsbase + 0x28)\nif (rax == *(fsbase + 0x28))\nreturn result\n__stack_chk_fail()\nnoreturn\nint64_t rax_3 = arg1[3]\nfloat zmm4_1\nint32_t zmm5_1\nint64_t rax_4\nif (rax_3 s< 0)\nrax_4 = arg1[2]\nzmm5_1 = float.s(rax_3 u>> 1 | (zx.q(rax_3.d) & 1))\nzmm5_1 = zmm5_1 f+ zmm5_1\nif (rax_4 s>= 0)\nzmm4_1 = float.s(rax_4)\nzmm4_1 = float.s(rax_4 u>> 1 | (zx.q(rax_4.d) & 1))\nzmm4_1 = zmm4_1 + zmm4_1\nzmm5_1 = float.s(rax_3)\nrax_4 = arg1[2]\nif (rax_4 s< 0)\nzmm4_1 = float.s(rax_4 u>> 1 | (zx.q(rax_4.d) & 1))\nzmm4_1 = zmm4_1 + zmm4_1\nzmm4_1 = float.s(rax_4)\nuint128_t zmm0_1\nzmm0_1.d = (*(arg1[5] + 8)).d f* zmm4_1\nif (not(zmm5_1 f> zmm0_1.d))\nlabel_40c9ee:\nint64_t* r13_2 = var_38\nif (*r13_2 == 0)\nzmm0_1 = __paddq_xmmdq_memdq(*(arg1 + 0x18), data_41dad0)\n// ... truncated",
        "pseudoc": "{\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (arg2)\n    {\n        int64_t* var_38;\n        int64_t rax_2 = sub_409a50(arg1, arg2, &var_38, 0);\n        int64_t result;\n        \n        if (rax_2)\n        {\n            *(uint64_t*)arg3 = rax_2;\n            result = 0;\n        label_40c991:\n            *(uint64_t*)((char*)fsbase + 0x28);\n            \n            if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n                return result;\n            \n            __stack_chk_fail();\n            /* no return */\n        }\n        \n        int64_t rax_3 = arg1[3];\n        float zmm4_1;\n        int32_t zmm5_1;\n        int64_t rax_4;\n        \n        if (rax_3 < 0)\n        {\n            rax_4 = arg1[2];\n            zmm5_1 = (float)(rax_3 >> 1 | ((uint64_t)(uint32_t)rax_3 & 1));\n            zmm5_1 = zmm5_1 + zmm5_1;\n            \n            if (rax_4 >= 0)\n                zmm4_1 = (float)rax_4;\n            else\n            {\n                zmm4_1 = (float)(rax_4 >> 1 | ((uint64_t)(uint32_t)rax_4 & 1));\n                zmm4_1 = zmm4_1 + zmm4_1;\n            }\n        }\n        else\n        {\n            zmm5_1 = (float)rax_3;\n            rax_4 = arg1[2];\n            \n            if (rax_4 < 0)\n            {\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_safe_malloc",
          "confidence": 0.78,
          "rationale": "The function imports malloc, abort, __errno_location and __stack_chk_fail, indicating it performs memory allocation with error checking and aborts on failure, typical of a safe malloc wrapper.",
          "evidence_refs": [
            "imports:malloc",
            "imports:abort",
            "imports:__errno_location",
            "imports:__stack_chk_fail",
            "call:0x404750",
            "call:0x409a50"
          ],
          "tags": [],
          "alt_names": [
            "ai_malloc_wrapper",
            "ai_allocate_buffer"
          ]
        },
        "explain": {
          "summary": "sub_40c940 performs a conditional lookup followed by numeric processing of fields in a data structure. If a nonnull second argument is supplied it calls sub_409a50 to retrieve a cached entry; on success it stores the result in the third argument and returns. When the lookup fails it extracts two integer fields from the first argument, converts them to floatingpoint values (handling negative values specially), and proceeds with further calculations before returning a status code, with stackcanary protection throughout.",
          "details": [
            "Checks a stack canary at entry and exit using the FS segment guard (fsbase+0x28) and calls __stack_chk_fail on mismatch.",
            "If arg2 is nonzero, calls sub_409a50(arg1, arg2, &var_38, 0) to perform a lookup; on a nonzero return stores the pointer in *arg3 and returns 0.",
            "If the lookup returns zero, reads arg1[3] and arg1[2] (likely integer coordinates), converts them to floats with special handling for negative values, and computes derived floatingpoint values (zmm5_1, zmm4_1).",
            "The function likely uses these computed values for further processing (e.g., validation via sub_40c7b0) before returning a result."
          ],
          "evidence_refs": [
            "imports:__stack_chk_fail",
            "call:0x409a50",
            "call:0x40c7b0",
            "call:0x404760",
            "call:0x404750",
            "strings:none"
          ],
          "unknowns": [
            "Exact purpose of the floatingpoint calculations and the final return value.",
            "What the overall data structure pointed to by arg1 represents.",
            "The role of subsequent calls (e.g., sub_404760) not shown in the truncated code."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40cb80",
      "original_name": "sub_40cb80",
      "final_name": "ai_locale_number_format",
      "score": 425.5,
      "bb_count": 166,
      "insn_est": 779,
      "callers": 7,
      "callees": [
        {
          "addr": "0x404810",
          "name": "ai_localeconv_wrapper",
          "original_name": "localeconv"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404aa0",
          "name": "ai_safe_memory_copy",
          "original_name": "__memcpy_chk"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404c20",
          "name": "ai_memmove_wrapper",
          "original_name": "memmove"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "localeconv",
        "strlen",
        "strlen",
        "strlen",
        "__memcpy_chk",
        "memcpy",
        "memcpy",
        "__sprintf_chk",
        "strlen",
        "__sprintf_chk",
        "strlen",
        "__sprintf_chk",
        "strlen",
        "__sprintf_chk",
        "strlen",
        "memmove",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "%.0Lf",
        "%.1Lf"
      ],
      "constants": [
        "0xffffffe8",
        "0x400",
        "0x404810",
        "0x4048e0",
        "0x41aedc",
        "0x41af54",
        "0x287",
        "0x419014",
        "0x5f800000",
        "0xffffffff",
        "0x41aede",
        "0x404d60",
        "0x404c20",
        "0xcccccccccccccccd",
        "0x41aee4",
        "0x404aa0",
        "0x8000000000000000",
        "0x4048f0",
        "0x100",
        "0x404ad0",
        "0x288",
        "0xfffffff8",
        "0x286",
        "0x4195e8"
      ],
      "snippets": {
        "asm": "  0x40cb80  endbr64 \n  0x40cb84  push    rbp {__saved_rbp}\n  0x40cb85  mov     rbp, rsp {__saved_rbp}\n  0x40cb88  push    r15 {__saved_r15}\n  0x40cb8a  push    r14 {__saved_r14}\n  0x40cb8c  push    r13 {__saved_r13}\n  0x40cb8e  push    r12 {__saved_r12}\n  0x40cb90  mov     r12, rcx\n  0x40cb93  push    rbx {__saved_rbx}\n  0x40cb94  mov     rbx, rdi\n  0x40cb97  sub     rsp, 0xa8\n  0x40cb9e  mov     qword [rbp-0x88 {var_90}], rsi\n  0x40cba5  mov     qword [rbp-0x98 {var_a0}], r8\n  0x40cbac  mov     dword [rbp-0x78 {var_80}], edx\n  0x40cbaf  mov     rax, qword [fs:0x28]\n  0x40cbb8  mov     qword [rbp-0x38 {var_40}], rax\n  0x40cbbc  mov     eax, edx\n  0x40cbbe  and     edx, 0x20\n  0x40cbc1  mov     dword [rbp-0xb8 {var_c0}], edx\n  0x40cbc7  and     eax, 0x3\n  0x40cbca  cmp     edx, 0x1\n  0x40cbcd  mov     dword [rbp-0xa0 {var_a8}], eax\n  0x40cbd3  sbb     eax, eax\n  0x40cbd5  and     eax, 0xffffffe8\n  0x40cbd8  add     eax, 0x400\n  0x40cbdd  mov     dword [rbp-0xb4 {var_bc}], eax\n  0x40cbe3  call    localeconv\n  0x40cbe8  mov     r15, qword [rax {lconv::decimal_point}]\n  0x40cbeb  mov     r14, rax\n  0x40cbee  mov     rdi, r15\n  ... (3125 bytes total, truncated)",
        "hlil": "void* fsbase\nint64_t rax = *(fsbase + 0x28)\nint32_t rdx = arg3 & 0x20\nint32_t rax_2 = arg3 & 3\nstruct lconv* rax_6 = localeconv()\nchar* decimal_point = rax_6->decimal_point\nuint64_t rax_7 = strlen(decimal_point)\nchar* grouping = rax_6->grouping\nchar* thousands_sep = rax_6->thousands_sep\nuint64_t rsi = rax_7\nif (rax_7 - 1 u>= 0x10)\nrsi = 1\nif (rax_7 - 1 u>= 0x10)\ndecimal_point = &data_41aedc\nchar* thousands_sep_1 = &data_41af54\nif (strlen(thousands_sep) u<= 0x10)\nthousands_sep_1 = thousands_sep\nchar* var_98 = &arg2[0x287]\nuint64_t i_4\nuint32_t rdi_4\nuint32_t r9_1\nint32_t r12_2\nif (arg4 u< arg5)\nint64_t rdx_1 = 0\nuint64_t temp0 = divu.dp.q(rdx_1:arg5, arg4)\nif (modu.dp.q(rdx_1:arg5, arg4) != 0)\ngoto label_40ce4c\nint64_t rdx_3 = 0\ni_4 = divu.dp.q(rdx_3:arg1, temp0)\nint64_t rdx_5 = 0\nuint64_t rax_17 = modu.dp.q(rdx_3:arg1, temp0) * 0xa\nuint64_t rdx_7 = modu.dp.q(rdx_5:rax_17, temp0) * 2\nr9_1 = (divu.dp.q(rdx_5:rax_17, temp0)).d\nif (rdx_7 u>= temp0)\nuint64_t rdi_3\nrdi_3.b = temp0 u< rdx_7\nrdi_4 = zx.d(rdi_3.b) + 2\nrdi_4.b = rdx_7 != 0\nr12_2 = arg3 & 0x10\nif (r12_2 == 0)\n// ... truncated",
        "pseudoc": "{\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int32_t rdx = arg3 & 0x20;\n    int32_t rax_2 = arg3 & 3;\n    struct lconv* rax_6 = localeconv();\n    char* decimal_point = rax_6->decimal_point;\n    uint64_t rax_7 = strlen(decimal_point);\n    char* grouping = rax_6->grouping;\n    char* thousands_sep = rax_6->thousands_sep;\n    uint64_t rsi = rax_7;\n    \n    if (rax_7 - 1 >= 0x10)\n        rsi = 1;\n    \n    if (rax_7 - 1 >= 0x10)\n        decimal_point = &data_41aedc;\n    \n    char* thousands_sep_1 = &data_41af54;\n    \n    if (strlen(thousands_sep) <= 0x10)\n        thousands_sep_1 = thousands_sep;\n    \n    char* var_98 = &arg2[0x287];\n    uint64_t i_4;\n    uint32_t rdi_4;\n    uint32_t r9_1;\n    int32_t r12_2;\n    \n    if (arg4 < arg5)\n    {\n        int64_t rdx_1 = 0;\n        uint64_t temp0 = COMBINE(rdx_1, arg5) / arg4;\n        \n        if (COMBINE(rdx_1, arg5) % arg4)\n            goto label_40ce4c;\n        \n        int64_t rdx_3 = 0;\n        i_4 = COMBINE(rdx_3, arg1) / temp0;\n        int64_t rdx_5 = 0;\n        uint64_t rax_17 = COMBINE(rdx_3, arg1) % temp0 * 0xa;\n        uint64_t rdx_7 = COMBINE(rdx_5, rax_17) % temp0 * 2;\n        r9_1 = (int32_t)(COMBINE(rdx_5, rax_17) / temp0);\n        \n        if (rdx_7 >= temp0)\n        {\n            uint64_t rdi_3;\n            (uint8_t)rdi_3 = temp0 < rdx_7;\n            rdi_4 = (uint32_t)(uint8_t)rdi_3 + 2;\n        }\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_locale_number_format",
          "confidence": 0.86,
          "rationale": "The function retrieves locale information (decimal point, thousands separator) via localeconv, uses format strings like '%.0Lf' and '%.1Lf', and performs numeric division/modulo to format numbers according to locale settings.",
          "evidence_refs": [
            "strings:%.0Lf",
            "strings:%.1Lf",
            "imports:localeconv",
            "imports:__sprintf_chk",
            "call:0x404810"
          ],
          "tags": [],
          "alt_names": [
            "ai_format_number_locale",
            "ai_number_to_string_locale"
          ]
        },
        "explain": {
          "summary": "sub_40cb80 formats a numeric value into a localeaware string, applying grouping, decimal point, and precision based on the current locale and flag arguments. It retrieves locale information via localeconv, calculates integer and fractional parts using division and modulo, then emits the result with sprintf using \"%.0Lf\" or \"%.1Lf\" patterns. The function also respects formatting flags (e.g., arg3 bits) and writes the output into a callerprovided buffer.",
          "details": [
            "Calls localeconv() to obtain decimal_point, thousands_sep, and grouping strings, falling back to defaults if they exceed length limits.",
            "Uses strlen() to determine the length of locale strings and adjusts internal pointers accordingly.",
            "Performs integer arithmetic on arg1, arg4, and arg5 to compute quotient, remainder, and scaled fractional parts, handling rounding when needed.",
            "Selects format strings \"%.0Lf\" or \"%.1Lf\" (via __sprintf_chk) based on flag bits (arg3) to produce the final textual representation.",
            "Copies the formatted result into a buffer (arg2) using memcpy/__memcpy_chk, respecting buffer offsets (e.g., var_98 at arg2+0x287)."
          ],
          "evidence_refs": [
            "strings:'%.0Lf'",
            "strings:'%.1Lf'",
            "imports:localeconv",
            "imports:strlen",
            "imports:__sprintf_chk",
            "call:0x404810",
            "call:0x4048e0"
          ],
          "unknowns": [
            "Exact meaning of arg3 flag bits beyond the checked 0x20 and low two bits",
            "Purpose of the large buffer offset (0x287) and how the result is later used",
            "Why the function may branch to label_40ce4c on division remainder conditions"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40d850",
      "original_name": "sub_40d850",
      "final_name": "ai_process_config_flags",
      "score": 138.1,
      "bb_count": 28,
      "insn_est": 112,
      "callers": 2,
      "callees": [
        {
          "addr": "0x40bd80",
          "name": "ai_map_status_code",
          "original_name": "sub_40bd80"
        },
        {
          "addr": "0x40cb80",
          "name": "ai_locale_number_format",
          "original_name": "sub_40cb80"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "strlen",
        "strlen",
        "strlen",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x2a8",
        "0x423348",
        "0x423349",
        "0x423344",
        "0x423333",
        "0xfffffffffffffd54",
        "0xcccccccccccccccd",
        "0x4232c4",
        "0x4232c0",
        "0x4048e0",
        "0x4232ac",
        "0x4235a0",
        "0x40b040",
        "0x423334",
        "0x4232d0",
        "0xfffffffffffffd40",
        "0x200",
        "0x4232dc",
        "0x40cb80",
        "0x40bd80",
        "0x4048f0"
      ],
      "snippets": {
        "asm": "  0x40d850  push    rbp {__saved_rbp}\n  0x40d851  mov     rbp, rsp {__saved_rbp}\n  0x40d854  push    r13 {__saved_r13}\n  0x40d856  push    r12 {__saved_r12}\n  0x40d858  mov     r12, rdi\n  0x40d85b  push    rbx {__saved_rbx}\n  0x40d85c  sub     rsp, 0x2a8\n  0x40d863  movzx   r13d, byte [rel data_423348]\n  0x40d86b  mov     rax, qword [fs:0x28]\n  0x40d874  mov     qword [rbp-0x28 {var_30}], rax\n  0x40d878  xor     eax, eax  {0x0}\n  0x40d87a  cmp     byte [rel data_423349], 0x0\n  0x40d881  je      0x40d930\n  0x40d930  xor     ebx, ebx  {0x0}\n  0x40d932  test    r13b, r13b\n  0x40d935  je      0x40d8b6\n  0x40d887  cmp     dword [rel data_423344], 0x4\n  0x40d88e  je      0x40d9f0\n  0x40d8b6  cmp     byte [rel data_423333], 0x0\n  0x40d8bd  jne     0x40d990\n  0x40d93b  cmp     dword [rel data_423344], 0x4\n  0x40d942  jne     0x40d8a8\n  0x40d9f0  mov     byte [rbp-0x2ac {var_2b4}], 0x0\n  0x40d9f7  mov     rcx, qword [rdi+0x20]\n  0x40d9fb  mov     r8, 0xcccccccccccccccd\n  0x40da05  lea     rdi, [rbp-0x2ac {var_2b4}]\n  0x40da0c  nop     dword [rax]\n  0x40d894  movsxd  rbx, dword [rel data_4232c4]\n  0x40d89b  add     rbx, 0x1\n  0x40d89f  test    r13b, r13b\n  ... (536 bytes total, truncated)",
        "hlil": "char r13 = data_423348\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nif (data_423349 == 0)\nif (r13 != 0)\nif (data_423344 != 4)\nlabel_40d8a8:\ndata_4232c0\nlabel_40d948:\nif (arg1[0x17].b != 0)\nchar var_2c8[0x14]\nchar* rax_10\nint16_t x87control\nint80_t st0_1\nst0_1, rax_10 = sub_40cb80(arg1[0xb], &var_2c8, data_4232dc, 0x200, data_4232d0, x87control)\nstrlen(rax_10)\ngoto label_40d8b6\nlabel_40d8b6:\nif (data_423333 != 0)\nif (data_423344 != 4)\ngoto label_40d99d\nlabel_40da68:\nstrlen(arg1[0x16])\ngoto label_40d9b3\nlabel_40d8cb:\nif (arg1[0x19] == 0)\nsub_40b040(*arg1, data_4235a0, *(arg1 + 0xc4))\nif (data_423344 == 4)\nchar var_2b4 = 0\nuint64_t i_1 = arg1[4]\nchar* rdi_4 = &var_2b4\nuint64_t i\nrdi_4 -= 1\nuint64_t i_2 = i_1 u/ 0xa\n*rdi_4 = i_1.b - (i_2.b + (i_2 << 2).b) * 2 + 0x30\ni = i_1\ni_1 = i_2\ndo while (i u> 9)\nstrlen(rdi_4)\nif (r13 != 0)\n// ... truncated",
        "pseudoc": "{\n    char r13 = data_423348;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (!data_423349)\n    {\n        if (r13)\n        {\n            if (data_423344 != 4)\n            {\n            label_40d8a8:\n                data_4232c0;\n            }\n            else\n            {\n            label_40d948:\n                \n                if (arg1[0x17])\n                {\n                    char var_2c8[0x14];\n                    char* rax_10;\n                    int16_t x87control;\n                    int80_t st0_1;\n                    st0_1 = sub_40cb80(arg1[0xb], &var_2c8, data_4232dc, 0x200, data_4232d0, \n                        x87control);\n                    strlen(rax_10);\n                    goto label_40d8b6;\n                }\n            }\n        }\n        \n    label_40d8b6:\n        \n        if (data_423333)\n        {\n            if (data_423344 != 4)\n                goto label_40d99d;\n            \n        label_40da68:\n            strlen(arg1[0x16]);\n            goto label_40d9b3;\n        }\n        \n    label_40d8cb:\n        \n        if (!arg1[0x19])\n            sub_40b040(*(uint64_t*)arg1, data_4235a0, *(uint32_t*)((char*)arg1 + 0xc4));\n    }\n    else\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_process_config_flags",
          "confidence": 0.66,
          "rationale": "The function checks several global configuration variables, conditionally calls formatting and processing routines (sub_40cb80) and a handler (sub_40b040), and uses strlen on fields, indicating it processes configuration or state flags rather than network or cryptographic operations.",
          "evidence_refs": [
            "imports:strlen",
            "call:0x40cb80",
            "call:0x40b040",
            "call:0x40bd80"
          ],
          "tags": [
            "config",
            "file_io",
            "process"
          ],
          "alt_names": [
            "ai_handle_global_settings",
            "ai_evaluate_config_entries"
          ]
        },
        "explain": {
          "summary": "sub_40d850 conditionally formats and processes fields of a data structure based on several global configuration flags. It invokes a locale-aware formatting routine (sub_40cb80) when certain flags are set, measures resulting string lengths with strlen, and may call sub_40b040 for further handling of a specific field. Stack protection is present via __stack_chk_fail.",
          "details": [
            "The function checks global flags data_423349, data_423348, data_423344, and data_423333 to decide which processing path to take.",
            "When data_423348 is true and data_423344 equals 4, it calls sub_40cb80 with arg1[0xb] and a local buffer, then calls strlen on the returned string.",
            "If data_423333 is set and data_423344 equals 4, it calls strlen on arg1[0x16] (likely another string field).",
            "If arg1[0x19] is zero, it invokes sub_40b040 with values extracted from the structure and a global data_4235a0.",
            "The function includes a stack canary check (via __stack_chk_fail) to detect stack corruption."
          ],
          "evidence_refs": [
            "imports:strlen",
            "imports:__stack_chk_fail",
            "call:0x40cb80",
            "call:0x40bd80",
            "call:0x40b040",
            "call:0x4048e0"
          ],
          "unknowns": [
            "Exact semantics of the global variables data_423348, data_423349, data_423344, data_423333",
            "The higherlevel purpose of the structure referenced by arg1 and the meaning of its indexed fields",
            "What sub_40b040 ultimately does with the processed data"
          ],
          "confidence": 0.73
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "file_io",
        "process"
      ]
    },
    {
      "addr": "0x40da80",
      "original_name": "sub_40da80",
      "final_name": "ai_print_data_array_stdout",
      "score": 102.4,
      "bb_count": 23,
      "insn_est": 118,
      "callers": 0,
      "callees": [
        {
          "addr": "0x418b20",
          "name": "ai_print_formatted_config_value",
          "original_name": "sub_418b20"
        },
        {
          "addr": "0x40d850",
          "name": "ai_process_config_flags",
          "original_name": "sub_40d850"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        }
      ],
      "import_refs": [
        "__overflow",
        "__overflow",
        "__overflow"
      ],
      "string_refs": [],
      "constants": [
        "0x422fa8",
        "0x404960",
        "0x423450",
        "0x40d850",
        "0x418b20",
        "0x423318",
        "0x423478",
        "0x423078"
      ],
      "snippets": {
        "asm": "  0x40da80  push    rbp {__saved_rbp}\n  0x40da81  mov     rbp, rsp {__saved_rbp}\n  0x40da84  push    r15 {__saved_r15}\n  0x40da86  push    r14 {__saved_r14}\n  0x40da88  push    r13 {__saved_r13}\n  0x40da8a  push    r12 {__saved_r12}\n  0x40da8c  push    rbx {__saved_rbx}\n  0x40da8d  sub     rsp, 0x18\n  0x40da91  cmp     qword [rel data_423318], 0x0\n  0x40da99  mov     byte [rbp-0x31 {var_39}], dil\n  0x40da9d  je      0x40dbf0\n  0x40dbf0  mov     r14, qword [rel stdout]\n  0x40dbf7  nop     word [rax+rax]\n  0x40daa3  mov     r14, qword [rel stdout]\n  0x40daaa  xor     r13d, r13d  {0x0}\n  0x40daad  xor     ebx, ebx  {0x0}\n  0x40daaf  jmp     0x40dae0\n  0x40dc40  add     rsp, 0x18\n  0x40dc44  movzx   esi, dl\n  0x40dc47  pop     rbx {__saved_rbx}\n  0x40dc48  pop     r12 {__saved_r12}\n  0x40dc4a  pop     r13 {__saved_r13}\n  0x40dc4c  pop     r14 {__saved_r14}\n  0x40dc4e  pop     r15 {__saved_r15}\n  0x40dc50  pop     rbp {__saved_rbp}\n  0x40dc51  jmp     __overflow\n  0x40dc14  lea     rcx, [rax+0x1]\n  0x40dc18  mov     qword [rdi+0x28], rcx\n  0x40dc1c  mov     byte [rax], dl\n  0x40dc1e  add     rsp, 0x18\n  ... (432 bytes total, truncated)",
        "hlil": "if (data_423318 != 0)\nint64_t r13_1 = 0\nint64_t i = 0\nint64_t* r15_1 = *(data_423450 + (i << 3))\nint64_t r12_1\nint16_t top\nchar* _IO_write_ptr\nchar rcx_3\nFILE* f\nint32_t r8_1\nif (data_423478 == 0)\nr12_1 = r13_1\nif (i != 0)\nr12_1 = r13_1 + 2\nr13_1 = r12_1\nlabel_40db38:\nf = *stdout\nr8_1 = 0x20\nrcx_3 = 0x20\n_IO_write_ptr = f->_IO_write_ptr\nchar* _IO_write_ptr_1\nFILE* f_1\nif (_IO_write_ptr u>= f->_IO_write_end)\nlabel_40dbb9:\n__overflow(f, sx.d(arg1))\nf_1 = *stdout\n_IO_write_ptr_1 = f_1->_IO_write_ptr\nif (_IO_write_ptr_1 u< f_1->_IO_write_end)\nf_1->_IO_write_ptr = &_IO_write_ptr_1[1]\n*_IO_write_ptr_1 = rcx_3\n__overflow(f_1, zx.d(r8_1.b))\nlabel_40db58:\nf->_IO_write_ptr = &_IO_write_ptr[1]\n*_IO_write_ptr = arg1\nf_1 = *stdout\n_IO_write_ptr_1 = f_1->_IO_write_ptr\nif (_IO_write_ptr_1 u>= f_1->_IO_write_end)\n__overflow(f_1, zx.d(r8_1.b))\nf_1->_IO_write_ptr = &_IO_write_ptr_1[1]\n*_IO_write_ptr_1 = rcx_3\n// ... truncated",
        "pseudoc": "{\n    if (data_423318)\n    {\n        int64_t r13_1 = 0;\n        int64_t i = 0;\n        \n        do\n        {\n            int64_t* r15_1 = *(uint64_t*)(data_423450 + (i << 3));\n            int64_t r12_1;\n            int16_t top;\n            char* _IO_write_ptr;\n            char rcx_3;\n            FILE* f;\n            int32_t r8_1;\n            \n            if (!data_423478)\n            {\n                r12_1 = r13_1;\n                \n                if (i)\n                {\n                    r12_1 = r13_1 + 2;\n                    r13_1 = r12_1;\n                label_40db38:\n                    f = *(uint64_t*)stdout;\n                    r8_1 = 0x20;\n                    rcx_3 = 0x20;\n                    _IO_write_ptr = f->_IO_write_ptr;\n                    char* _IO_write_ptr_1;\n                    FILE* f_1;\n                    \n                    if (_IO_write_ptr >= f->_IO_write_end)\n                    {\n                    label_40dbb9:\n                        __overflow(f, (int32_t)arg1);\n                        f_1 = *(uint64_t*)stdout;\n                        _IO_write_ptr_1 = f_1->_IO_write_ptr;\n                        \n                        if (_IO_write_ptr_1 < f_1->_IO_write_end)\n                        {\n                            f_1->_IO_write_ptr = &_IO_write_ptr_1[1];\n                            *(uint8_t*)_IO_write_ptr_1 = rcx_3;\n                        }\n                        else\n                            __overflow(f_1, (uint32_t)(uint8_t)r8_1);\n                    }\n                    else\n                    {\n                    label_40db58:\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_data_array_stdout",
          "confidence": 0.78,
          "rationale": "The function iterates over a data array (data_423450) and writes characters (including spaces) to stdout using __overflow, indicating it prints or dumps data to the console.",
          "evidence_refs": [
            "imports:__overflow",
            "strings:none",
            "call:0x404960"
          ],
          "tags": [
            "file_io",
            "process"
          ],
          "alt_names": [
            "ai_stdout_dump",
            "ai_print_buffer"
          ]
        },
        "explain": {
          "summary": "sub_40da80 checks a global flag (data_423318) and, if set, iterates over an array of pointers (data_423450). For each entry it conditionally writes a space character (0x20) to stdout using the lowlevel __overflow routine, adjusting the write pointer as needed. The loop also updates a counter (r13_1) and may invoke other helper functions (sub_418b20, sub_40d850) to output additional data, suggesting it formats and prints a list of values.",
          "details": [
            "The function begins with a guard on data_423318; if false the routine does nothing.",
            "It loops over indices i, fetching pointers from data_423450 and using a counter r13_1 that increments by 2 after the first iteration.",
            "When data_423478 is false, it writes a space (0x20) to stdout, handling buffer overflow via __overflow.",
            "Calls to sub_418b20 and sub_40d850 (not shown in the snippet) indicate further processing or printing of the array elements."
          ],
          "evidence_refs": [
            "imports:__overflow",
            "call:0x404960",
            "call:0x418b20",
            "call:0x40d850",
            "strings:none"
          ],
          "unknowns": [
            "Exact content and purpose of the data structures referenced by data_423450, data_423318, and data_423478.",
            "What additional output is produced by the calls to sub_418b20 and sub_40d850."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": false,
      "tags": [
        "file_io",
        "process"
      ]
    },
    {
      "addr": "0x40dc60",
      "original_name": "_obstack_begin",
      "final_name": "ai_obstack_init",
      "score": 9.5,
      "bb_count": 1,
      "insn_est": 5,
      "callers": 3,
      "callees": [
        {
          "addr": "0x407ed0",
          "name": "ai_obstack_new_chunk",
          "original_name": "sub_407ed0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x407ed0"
      ],
      "snippets": {
        "asm": "  0x40dc60  endbr64 \n  0x40dc64  and     byte [rdi+0x50], 0xfe\n  0x40dc68  mov     qword [rdi+0x38], rcx\n  0x40dc6c  mov     qword [rdi+0x40], r8\n  0x40dc70  jmp     sub_407ed0",
        "hlil": "arg1[0xa].b &= 0xfe\narg1[7] = arg4\narg1[8] = arg5\nreturn sub_407ed0(arg1, arg2, arg3) __tailcall",
        "pseudoc": "{\n    arg1[0xa] &= 0xfe;\n    arg1[7] = arg4;\n    arg1[8] = arg5;\n    /* tailcall */\n    return sub_407ed0(arg1, arg2, arg3);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_obstack_init",
          "confidence": 0.86,
          "rationale": "The function sets up fields of a structure and then tail-calls sub_407ed0 which performs the core initialization of an obstack (memory allocation stack), indicating it initializes an obstack data structure.",
          "evidence_refs": [
            "call:0x407ed0"
          ],
          "tags": [],
          "alt_names": [
            "ai_obstack_initialize",
            "ai_memory_stack_init"
          ]
        },
        "explain": {
          "summary": "The _obstack_begin function initializes an obstack control structure by clearing a flag byte, storing two parameters, and then delegating to sub_407ed0 which performs the full obstack setup (chunk size, alignment, allocation function selection).",
          "details": [
            "arg1[0xa] &= 0xfe clears the leastsignificant bit of a flag field in the obstack structure.",
            "arg1[7] and arg1[8] are populated with arg4 and arg5, likely pointers to allocation and deallocation callbacks or user data.",
            "The function then tailcalls sub_407ed0(arg1, arg2, arg3), which contains the logic for setting chunk size, alignment, and initializing internal pointers of the obstack."
          ],
          "evidence_refs": [
            "call:0x407ed0"
          ],
          "unknowns": [
            "Exact semantics of arg4 and arg5 (e.g., specific callback functions or context values).",
            "Full behavior of sub_407ed0 beyond the truncated snippet, especially error handling paths."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": true,
      "tags": []
    },
    {
      "addr": "0x40dc80",
      "original_name": "_obstack_begin_1",
      "final_name": "ai_obstack_initialize",
      "score": 6.8,
      "bb_count": 1,
      "insn_est": 6,
      "callers": 0,
      "callees": [
        {
          "addr": "0x407ed0",
          "name": "ai_obstack_new_chunk",
          "original_name": "sub_407ed0"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x407ed0"
      ],
      "snippets": {
        "asm": "  0x40dc80  endbr64 \n  0x40dc84  or      byte [rdi+0x50], 0x1\n  0x40dc88  mov     qword [rdi+0x38], rcx\n  0x40dc8c  mov     qword [rdi+0x40], r8\n  0x40dc90  mov     qword [rdi+0x48], r9\n  0x40dc94  jmp     sub_407ed0",
        "hlil": "arg1[0xa].b |= 1\narg1[7] = arg4\narg1[8] = arg5\narg1[9] = arg6\nreturn sub_407ed0(arg1, arg2, arg3) __tailcall",
        "pseudoc": "{\n    arg1[0xa] |= 1;\n    arg1[7] = arg4;\n    arg1[8] = arg5;\n    arg1[9] = arg6;\n    /* tailcall */\n    return sub_407ed0(arg1, arg2, arg3);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_obstack_initialize",
          "confidence": 0.87,
          "rationale": "The function sets flags and fields in a structure then tail-calls sub_407ed0 which performs typical GNU obstack initialization (setting chunk size, allocating memory). This matches behavior of initializing an obstack memory allocator.",
          "evidence_refs": [
            "call:0x407ed0"
          ],
          "tags": [],
          "alt_names": [
            "ai_obstack_begin",
            "ai_memory_obstack_init"
          ]
        },
        "explain": {
          "summary": "The function configures an obstack control structure by setting a flag and storing initialization parameters, then delegates to sub_407ed0 which performs the actual obstack setup and allocation.",
          "details": [
            "Sets bit 0 of the flags field at offset 0xa in the obstack struct (arg1[0xa] |= 1).",
            "Stores the provided arguments arg4, arg5, and arg6 into fields at offsets 7, 8, and 9 of the struct.",
            "Tailcalls sub_407ed0 with the same arguments to complete the obstack initialization, including chunk size handling and allocation."
          ],
          "evidence_refs": [
            "call:0x407ed0"
          ],
          "unknowns": [
            "Exact meaning of arg2, arg3, arg5, and arg6 in the context of the obstack configuration.",
            "Detailed behavior of sub_407ed0 beyond the truncated snippet, such as alignment calculations and error handling."
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40dca0",
      "original_name": "_obstack_newchunk",
      "final_name": "ai_memory_chunk_allocate",
      "score": 61.1,
      "bb_count": 13,
      "insn_est": 92,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x40dde0",
          "name": "ai_obstack_write_global_counter",
          "original_name": "sub_40dde0"
        }
      ],
      "import_refs": [
        "memcpy"
      ],
      "string_refs": [],
      "constants": [
        "0x4230a0",
        "0x40dde0",
        "0x404ad0"
      ],
      "snippets": {
        "asm": "  0x40dca0  endbr64 \n  0x40dca4  push    rbp {__saved_rbp}\n  0x40dca5  xor     ecx, ecx  {0x0}\n  0x40dca7  mov     rbp, rsp {__saved_rbp}\n  0x40dcaa  push    r15 {__saved_r15}\n  0x40dcac  push    r14 {__saved_r14}\n  0x40dcae  push    r13 {__saved_r13}\n  0x40dcb0  push    r12 {__saved_r12}\n  0x40dcb2  push    rbx {__saved_rbx}\n  0x40dcb3  mov     rbx, rdi\n  0x40dcb6  sub     rsp, 0x8\n  0x40dcba  mov     r14, qword [rdi+0x18]\n  0x40dcbe  sub     r14, qword [rdi+0x10]\n  0x40dcc2  mov     rdx, qword [rbx]\n  0x40dcc5  add     rsi, r14\n  0x40dcc8  mov     rax, r14\n  0x40dccb  mov     r12, qword [rdi+0x8]\n  0x40dccf  setb    cl\n  0x40dcd2  add     rsi, qword [rdi+0x30]\n  0x40dcd6  setb    dil\n  0x40dcda  shr     rax, 0x3\n  0x40dcde  cmp     rsi, rdx\n  0x40dce1  lea     rax, [rsi+rax+0x64]\n  0x40dce6  cmovb   rsi, rdx\n  0x40dcea  cmp     rax, rsi\n  0x40dced  cmovae  rsi, rax\n  0x40dcf1  test    rcx, rcx\n  0x40dcf4  jne     0x40ddd7\n  0x40ddd7  lea     rax, [rel obstack_alloc_failed_handler]\n  0x40ddde  call    qword [rax]  {obstack_alloc_failed_handler}  {sub_40dde0}\n  ... (307 bytes total, truncated)",
        "hlil": "int64_t* rbx = arg1\nuint64_t r14_1 = arg1[3] - arg1[2]\nint64_t rdx = *rbx\nint64_t rsi = arg2 + r14_1\nvoid* r12 = arg1[1]\nint64_t rcx\nrcx.b = arg2 + r14_1 u< arg2\nint64_t rsi_1 = rsi + arg1[6]\narg1.b = rsi + arg1[6] u< rsi\nint64_t rax_2 = rsi_1 + (r14_1 u>> 3) + 0x64\nif (rsi_1 u< rdx)\nrsi_1 = rdx\nif (rax_2 u>= rsi_1)\nrsi_1 = rax_2\nif (rcx == 0 && zx.q(arg1.b) == 0)\nint64_t rax_3 = rbx[7]\nint64_t* r13_1\nif ((rbx[0xa].b & 1) != 0)\nr13_1 = rax_3(rbx[9])\nr13_1 = rax_3(rsi_1)\nif (r13_1 != 0)\nvoid* rax_5 = r13_1 + rsi_1\nrbx[1] = r13_1\nint64_t rsi_2 = rbx[2]\nr13_1[1] = r12\nrbx[4] = rax_5\n*r13_1 = rax_5\nint64_t rax_6 = rbx[6]\nvoid* r15_3 = (r13_1 + rax_6 + 0x10) & not.q(rax_6)\nvoid* result = memcpy(r15_3, rsi_2, r14_1)\nuint32_t rdx_2 = zx.d(rbx[0xa].b)\nif ((rdx_2.b & 2) == 0)\nint64_t rax_8 = rbx[6]\nresult = not.q(rax_8) & (r12 + rax_8 + 0x10)\nif (rbx[2] == result)\nint32_t rdx_3 = rdx_2 & 1\nr13_1[1] = *(r12 + 8)\nint64_t rax_12 = rbx[8]\nif (rdx_3 == 0)\nresult = rax_12(r12)\n// ... truncated",
        "pseudoc": "{\n    int64_t* rbx = arg1;\n    uint64_t r14_1 = arg1[3] - arg1[2];\n    int64_t rdx = *(uint64_t*)rbx;\n    int64_t rsi = arg2 + r14_1;\n    void* r12 = arg1[1];\n    int64_t rcx;\n    (uint8_t)rcx = arg2 + r14_1 < arg2;\n    int64_t rsi_1 = rsi + arg1[6];\n    (uint8_t)arg1 = rsi + arg1[6] < rsi;\n    int64_t rax_2 = rsi_1 + (r14_1 >> 3) + 0x64;\n    \n    if (rsi_1 < rdx)\n        rsi_1 = rdx;\n    \n    if (rax_2 >= rsi_1)\n        rsi_1 = rax_2;\n    \n    if (!rcx && !(uint64_t)(uint8_t)arg1)\n    {\n        int64_t rax_3 = rbx[7];\n        int64_t* r13_1;\n        \n        if (rbx[0xa] & 1)\n            r13_1 = rax_3(rbx[9]);\n        else\n            r13_1 = rax_3(rsi_1);\n        \n        if (r13_1)\n        {\n            void* rax_5 = (char*)r13_1 + rsi_1;\n            rbx[1] = r13_1;\n            int64_t rsi_2 = rbx[2];\n            r13_1[1] = r12;\n            rbx[4] = rax_5;\n            *(uint64_t*)r13_1 = rax_5;\n            int64_t rax_6 = rbx[6];\n            void* r15_3 = ((char*)r13_1 + rax_6 + 0x10) & ~rax_6;\n            void* result = memcpy(r15_3, rsi_2, r14_1);\n            uint32_t rdx_2 = (uint32_t)rbx[0xa];\n            \n            if (!((uint8_t)rdx_2 & 2))\n            {\n                int64_t rax_8 = rbx[6];\n                result = ~rax_8 & ((char*)r12 + rax_8 + 0x10);\n                \n                if (rbx[2] == result)\n                {\n                    int32_t rdx_3 = rdx_2 & 1;\n                    r13_1[1] = *(uint64_t*)((char*)r12 + 8);\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memory_chunk_allocate",
          "confidence": 0.96,
          "rationale": "The function implements the GNU obstack new chunk logic, allocating and linking a new memory chunk, using memcpy for data movement. It is a generic dynamic memory allocation routine.",
          "evidence_refs": [
            "imports:memcpy",
            "call:0x404ad0"
          ],
          "tags": [],
          "alt_names": [
            "ai_obstack_newchunk",
            "ai_dynamic_memory_expand"
          ]
        },
        "explain": {
          "summary": "The _obstack_newchunk function implements the allocation of a new memory chunk for a GNU obstack, calculating the required size, handling overflow checks, invoking a custom allocator, aligning the new chunk, copying existing data, and updating the obstack's internal pointers.",
          "details": [
            "Computes the needed chunk size based on the requested allocation (arg2) plus current used space (r14_1) and adds extra space for alignment and overhead.",
            "Performs overflow checks using unsigned addition flags (rcx and arg1 flag) to ensure the size calculations do not wrap.",
            "Selects an allocation routine from the obstack structure (rbx[7]) and calls it with either a default size or a size derived from the obstack flags (rbx[0xa]).",
            "If allocation succeeds, updates the obstack's chunk base (rbx[1]), end pointer (rbx[4]), and alignment pointer using the returned pointer and the alignment mask stored in rbx[6].",
            "Copies the existing data from the old chunk to the new one with memcpy (call to 0x404ad0) and adjusts internal bookkeeping fields.",
            "Handles special flag bits in rbx[0xa] to decide whether to use a custom size or default allocation and to manage alignment semantics."
          ],
          "evidence_refs": [
            "imports:memcpy",
            "call:0x404ad0",
            "call:0x40dde0",
            "constants:0x4230a0",
            "constants:0x40dde0",
            "constants:0x404ad0"
          ],
          "unknowns": [
            "Exact semantics of the flag bits in rbx[0xa] beyond the observed checks",
            "The precise allocator function signature and how it handles failure cases",
            "The purpose of the truncated code after the memcpy call"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40dde0",
      "original_name": "sub_40dde0",
      "final_name": "ai_obstack_write_global_counter",
      "score": 19.0,
      "bb_count": 3,
      "insn_est": 20,
      "callers": 3,
      "callees": [
        {
          "addr": "0x40dca0",
          "name": "ai_memory_chunk_allocate",
          "original_name": "_obstack_newchunk"
        }
      ],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x40dca0",
        "0x423350"
      ],
      "snippets": {
        "asm": "  0x40dde0  push    rbp {__saved_rbp}\n  0x40dde1  mov     rbp, rsp {__saved_rbp}\n  0x40dde4  push    rbx {__saved_rbx}\n  0x40dde5  mov     rbx, rdi\n  0x40dde8  sub     rsp, 0x8\n  0x40ddec  mov     rdx, qword [rdi+0x18]\n  0x40ddf0  mov     rax, qword [rdi+0x20]\n  0x40ddf4  sub     rax, rdx\n  0x40ddf7  cmp     rax, 0x7\n  0x40ddfb  jbe     0x40de18\n  0x40de18  mov     esi, 0x8\n  0x40de1d  call    _obstack_newchunk\n  0x40de22  mov     rdx, qword [rbx+0x18]\n  0x40de26  jmp     0x40ddfd\n  0x40ddfd  mov     rax, qword [rel data_423350]\n  0x40de04  mov     qword [rdx], rax\n  0x40de07  add     qword [rbx+0x18], 0x8\n  0x40de0c  mov     rbx, qword [rbp-0x8 {__saved_rbx}]\n  0x40de10  leave    {__saved_rbp}\n  0x40de11  retn     {__return_addr}",
        "hlil": "int64_t* rdx = arg1[3]\nif (arg1[4] - rdx u<= 7)\n_obstack_newchunk(arg1, 8)\nrdx = arg1[3]\nint64_t result = data_423350\n*rdx = result\narg1[3] += 8\nreturn result",
        "pseudoc": "{\n    int64_t* rdx = arg1[3];\n    \n    if (arg1[4] - rdx <= 7)\n    {\n        _obstack_newchunk(arg1, 8);\n        rdx = arg1[3];\n    }\n    \n    int64_t result = data_423350;\n    *(uint64_t*)rdx = result;\n    arg1[3] += 8;\n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_obstack_write_global_counter",
          "confidence": 0.78,
          "rationale": "The function checks obstack space, calls _obstack_newchunk to allocate more memory if needed, then writes a global constant (data_423350) into the buffer, typical of an obstack push operation for a 64-bit value.",
          "evidence_refs": [
            "call:0x40dca0",
            "constants:0x423350"
          ],
          "tags": [],
          "alt_names": [
            "ai_obstack_push_uint64",
            "ai_write_global_counter"
          ]
        },
        "explain": {
          "summary": "sub_40dde0 pushes a global 64bit value onto an obstack, allocating a new chunk when the current one lacks at least 8 bytes, updates the obstack pointer, and returns the stored value.",
          "details": [
            "It checks the remaining space in the obstack (arg1[4] - arg1[3]) and calls _obstack_newchunk(arg1, 8) if less than 8 bytes are available.",
            "It writes the global variable data_423350 into the current obstack position, advances the obstack's top pointer by 8, and returns the written value."
          ],
          "evidence_refs": [
            "call:0x40dca0",
            "constants:0x423350"
          ],
          "unknowns": [
            "Exact semantics of the global data_423350 (counter, identifier, etc.)",
            "Full layout and purpose of the obstack structure referenced by arg1"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40de30",
      "original_name": "_obstack_allocated_p",
      "final_name": "ai_obstack_address_check",
      "score": 22.1,
      "bb_count": 8,
      "insn_est": 17,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [
        "H90s"
      ],
      "constants": [],
      "snippets": {
        "asm": "  0x40de30  endbr64 \n  0x40de34  mov     rax, qword [rdi+0x8]\n  0x40de38  test    rax, rax\n  0x40de3b  je      0x40de66\n  0x40de66  retn     {__return_addr}\n  0x40de3d  nop     dword [rax]\n  0x40de4a  mov     rax, qword [rax+0x8]\n  0x40de4e  test    rax, rax\n  0x40de51  jne     0x40de40\n  0x40de45  cmp     qword [rax], rsi\n  0x40de48  jae     0x40de60\n  0x40de40  cmp     rax, rsi\n  0x40de43  jae     0x40de4a\n  0x40de53  xor     eax, eax  {0x0}\n  0x40de55  retn     {__return_addr}\n  0x40de60  mov     eax, 0x1\n  0x40de65  retn     {__return_addr}",
        "hlil": "int64_t* i = *(arg1 + 8)\nif (i == 0)\nreturn i\nif (i u< arg2 && *i u>= arg2)\nreturn 1\ni = i[1]\ndo while (i != 0)\nreturn 0",
        "pseudoc": "{\n    int64_t* i = *(uint64_t*)((char*)arg1 + 8);\n    \n    if (!i)\n        return i;\n    \n    do\n    {\n        if (i < arg2 && *(uint64_t*)i >= arg2)\n            return 1;\n        \n        i = i[1];\n    } while (i);\n    \n    return 0;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_obstack_address_check",
          "confidence": 0.86,
          "rationale": "The function iterates over a linked list of memory blocks stored in an obstack structure and checks if a given address falls within any allocated range, returning true/false.",
          "evidence_refs": [
            "strings:H90s"
          ],
          "tags": [],
          "alt_names": [
            "ai_check_obstack_allocation",
            "ai_obstack_range_check"
          ]
        },
        "explain": {
          "summary": "The function walks a linked list of memory blocks stored in a structure at arg1 and checks whether the address arg2 falls within any of those blocks, returning true (1) if it does and false (0) otherwise.",
          "details": [
            "Loads a pointer from offset 8 of arg1, treating it as the head of a linked list of block descriptors.",
            "Iterates through each block: if arg2 is greater than the block's start address (i) and less than or equal to the block's end address stored at *i, it returns 1.",
            "Continues traversal via the second field of each block (i[1]) until the list ends, then returns 0 if no matching block is found."
          ],
          "evidence_refs": [
            "strings:H90s"
          ],
          "unknowns": [
            "Exact layout and meaning of the structure pointed to by arg1",
            "What the stored values at *i represent (size, end address, etc.)",
            "Potential side effects or calling conventions beyond the observed logic"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40de70",
      "original_name": "_obstack_free",
      "final_name": "ai_obstack_free_memory",
      "score": 45.4,
      "bb_count": 12,
      "insn_est": 53,
      "callers": 0,
      "callees": [
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        }
      ],
      "import_refs": [
        "abort"
      ],
      "string_refs": [
        "L9(s9L"
      ],
      "constants": [
        "0x404750"
      ],
      "snippets": {
        "asm": "  0x40de70  endbr64 \n  0x40de74  push    rbp {__saved_rbp}\n  0x40de75  mov     rbp, rsp {__saved_rbp}\n  0x40de78  push    r13 {__saved_r13}\n  0x40de7a  mov     r13, rsi\n  0x40de7d  push    r12 {__saved_r12}\n  0x40de7f  push    rbx {__saved_rbx}\n  0x40de80  mov     rbx, rdi\n  0x40de83  sub     rsp, 0x8\n  0x40de87  mov     rax, qword [rdi+0x8]\n  0x40de8b  test    rax, rax\n  0x40de8e  jne     0x40dead\n  0x40dead  cmp     rax, r13\n  0x40deb0  jae     0x40deb7\n  0x40de90  jmp     0x40ded3\n  0x40deb7  mov     r12, qword [rax+0x8]\n  0x40debb  mov     rdx, qword [rbx+0x40]\n  0x40debf  test    byte [rbx+0x50], 0x1\n  0x40dec3  jne     0x40de98\n  0x40deb2  cmp     qword [rax], r13\n  0x40deb5  jae     0x40def0\n  0x40ded3  test    r13, r13\n  0x40ded6  jne     0x404d84\n  0x40de98  mov     rdi, qword [rbx+0x48]\n  0x40de9c  mov     rsi, rax\n  0x40de9f  call    rdx\n  0x40dea1  or      byte [rbx+0x50], 0x2\n  0x40dea5  test    r12, r12\n  0x40dea8  je      0x40ded3\n  0x40dec5  mov     rdi, rax\n  ... (148 bytes total, truncated)",
        "hlil": "int64_t* result = *(arg1 + 8)\nif (result != 0)\nwhile (true)\nif (result u< arg2 && *result u>= arg2)\nint64_t rdx_2 = *result\n*(arg1 + 0x18) = arg2\n*(arg1 + 0x10) = arg2\n*(arg1 + 0x20) = rdx_2\n*(arg1 + 8) = result\nreturn result\nint64_t* result_1 = result[1]\nint64_t rdx_1 = *(arg1 + 0x40)\nif ((*(arg1 + 0x50) & 1) != 0)\nresult = rdx_1(*(arg1 + 0x48), result)\n*(arg1 + 0x50) |= 2\nif (result_1 == 0)\nbreak\nresult = rdx_1(result)\n*(arg1 + 0x50) |= 2\nif (result_1 == 0)\nbreak\nresult = result_1\nif (arg2 == 0)\nreturn result\nabort()\nnoreturn",
        "pseudoc": "{\n    int64_t* result = *(uint64_t*)((char*)arg1 + 8);\n    \n    if (result)\n    {\n        while (true)\n        {\n            if (result < arg2 && *(uint64_t*)result >= arg2)\n            {\n                int64_t rdx_2 = *(uint64_t*)result;\n                *(uint64_t*)((char*)arg1 + 0x18) = arg2;\n                *(uint64_t*)((char*)arg1 + 0x10) = arg2;\n                *(uint64_t*)((char*)arg1 + 0x20) = rdx_2;\n                *(uint64_t*)((char*)arg1 + 8) = result;\n                return result;\n            }\n            \n            int64_t* result_1 = result[1];\n            int64_t rdx_1 = *(uint64_t*)((char*)arg1 + 0x40);\n            \n            if (*(uint8_t*)((char*)arg1 + 0x50) & 1)\n            {\n                result = rdx_1(*(uint64_t*)((char*)arg1 + 0x48), result);\n                *(uint8_t*)((char*)arg1 + 0x50) |= 2;\n                \n                if (!result_1)\n                    break;\n            }\n            else\n            {\n                result = rdx_1(result);\n                *(uint8_t*)((char*)arg1 + 0x50) |= 2;\n                \n                if (!result_1)\n                    break;\n            }\n            \n            result = result_1;\n        }\n    }\n    \n    if (!arg2)\n        return result;\n    \n    abort();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_obstack_free_memory",
          "confidence": 0.86,
          "rationale": "Function manipulates internal obstack structure pointers, updates allocation metadata, and aborts on invalid input, matching typical behavior of an obstack free routine.",
          "evidence_refs": [
            "imports:abort",
            "call:0x404750",
            "strings:L9(s9L"
          ],
          "tags": [],
          "alt_names": [
            "ai_obstack_free",
            "ai_memory_deallocator"
          ]
        },
        "explain": {
          "summary": "The function implements a custom free operation for an obstack-like allocator, locating the chunk containing the target pointer, updating the obstack's internal state, and invoking a stored deallocation callback. If the target pointer is null it returns silently; otherwise, if the pointer cannot be validated it aborts the program.",
          "details": [
            "It retrieves a linked list head from the obstack structure (arg1+8) and walks the list to find a chunk whose start address is less than arg2 and whose end address is greater or equal to arg2.",
            "When the appropriate chunk is found, it updates several obstack fields (offsets 0x10, 0x18, 0x20, and 0x8) to reflect the new top of the stack and returns the chunk pointer.",
            "If the chunk traversal reaches the end, it calls a function pointer stored at offset 0x40 of the obstack, passing either the obstack's custom free routine or a default routine, and sets a flag at offset 0x50.",
            "If arg2 is zero, the function simply returns; otherwise, it triggers abort() to terminate execution on an invalid free request."
          ],
          "evidence_refs": [
            "imports:abort",
            "call:0x404750",
            "strings:'L9(s9L'"
          ],
          "unknowns": [
            "Exact meaning of the flag bits at offset 0x50",
            "The specific deallocation routine referenced by the function pointer at offset 0x40",
            "The structure layout of the obstack beyond the accessed fields"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40df10",
      "original_name": "_obstack_memory_used",
      "final_name": "ai_obstack_memory_usage",
      "score": 10.2,
      "bb_count": 4,
      "insn_est": 14,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x40df10  endbr64 \n  0x40df14  mov     rax, qword [rdi+0x8]\n  0x40df18  xor     ecx, ecx  {0x0}\n  0x40df1a  test    rax, rax\n  0x40df1d  je      0x40df32\n  0x40df32  mov     rax, rcx\n  0x40df35  retn     {__return_addr}\n  0x40df1f  nop     \n  0x40df20  mov     rdx, qword [rax]\n  0x40df23  sub     rdx, rax\n  0x40df26  mov     rax, qword [rax+0x8]\n  0x40df2a  add     rcx, rdx\n  0x40df2d  test    rax, rax\n  0x40df30  jne     0x40df20",
        "hlil": "int64_t* i = *(arg1 + 8)\nvoid* result = nullptr\nwhile (i != 0)\nvoid* rdx_2 = *i - i\ni = i[1]\nresult += rdx_2\nreturn result",
        "pseudoc": "{\n    int64_t* i = *(uint64_t*)((char*)arg1 + 8);\n    void* result = nullptr;\n    \n    while (i)\n    {\n        void* rdx_2 = *(uint64_t*)i - i;\n        i = i[1];\n        result += rdx_2;\n    }\n    \n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_obstack_memory_usage",
          "confidence": 0.95,
          "rationale": "The function iterates over obstack chunks, summing the difference between allocated pointers and base addresses to compute total memory used by the obstack.",
          "evidence_refs": [],
          "tags": [],
          "alt_names": [
            "ai_obstack_total_memory",
            "ai_obstack_used_bytes"
          ]
        },
        "explain": {
          "summary": "The function walks a linked list of memory blocks stored in a structure at arg1+8, computes each block's size by subtracting its base address from its end address, accumulates the sizes, and returns the total memory used.",
          "details": [
            "It retrieves the head of the block list from offset 8 of the argument structure.",
            "In a loop, it calculates each block's size as *(uint64_t*)i - i, adds it to a running total, and moves to the next block via i[1].",
            "The loop terminates when the block pointer is null, and the accumulated total is returned."
          ],
          "evidence_refs": [],
          "unknowns": [
            "Exact layout of the block header and the meaning of the fields beyond the observed pointer arithmetic."
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40df40",
      "original_name": "sub_40df40",
      "final_name": "ai_detect_locale_charset",
      "score": 84.9,
      "bb_count": 19,
      "insn_est": 78,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404b50",
          "name": "ai_get_locale_info",
          "original_name": "nl_langinfo"
        },
        {
          "addr": "0x407f90",
          "name": "ai_case_insensitive_two_char_match",
          "original_name": "sub_407f90"
        }
      ],
      "import_refs": [
        "nl_langinfo"
      ],
      "string_refs": [
        "GB18030"
      ],
      "constants": [
        "0x404b50",
        "0x41afef",
        "0x41aef1",
        "0xffffffdf",
        "0x41aeea",
        "0x41aef7",
        "0x41aefb",
        "0x407f90",
        "0x41aeee",
        "0x41aef3"
      ],
      "snippets": {
        "asm": "  0x40df40  endbr64 \n  0x40df44  push    rbp {__saved_rbp}\n  0x40df45  mov     rbp, rsp {__saved_rbp}\n  0x40df48  push    r12 {__saved_r12}\n  0x40df4a  mov     r12d, esi\n  0x40df4d  push    rbx {__saved_rbx}\n  0x40df4e  mov     rbx, rdi\n  0x40df51  mov     edi, 0xe\n  0x40df56  call    nl_langinfo\n  0x40df5b  test    rax, rax\n  0x40df5e  je      0x40dfc7\n  0x40dfc7  cmp     r12d, 0x9\n  0x40dfcb  lea     rax, [rel data_41afd6[0x19]]  {\"'\"}\n  0x40dfd2  lea     rdx, [rel data_41aef1]\n  0x40dfd9  pop     rbx {__saved_rbx}\n  0x40dfda  cmove   rax, rdx  {data_41aef1}\n  0x40dfde  pop     r12 {__saved_r12}\n  0x40dfe0  pop     rbp {__saved_rbp}\n  0x40dfe1  retn     {__return_addr}\n  0x40df60  mov     rdi, rax\n  0x40df63  movzx   eax, byte [rax]\n  0x40df66  test    al, al\n  0x40df68  je      0x40dfc7\n  0x40df6a  and     eax, 0xffffffdf\n  0x40df6d  cmp     al, 0x55\n  0x40df6f  jne     0x40dfb8\n  0x40dfb8  cmp     al, 0x47\n  0x40dfba  jne     0x40dfc7\n  0x40df71  movzx   eax, byte [rdi+0x1]\n  0x40df75  and     eax, 0xffffffdf\n  ... (233 bytes total, truncated)",
        "hlil": "char* rax = nl_langinfo(0xe)\nif (rax != 0)\nchar rax_1 = *rax\nif (rax_1 != 0)\nchar rax_2 = rax_1 & 0xdf\nif (rax_2 != 0x55)\nif (rax_2 == 0x47 && (rax[1] & 0xdf) == 0x42 && rax[2] == 0x31 && rax[3] == 0x38 && rax[4] == 0x30 && rax[5] == 0x33 && rax[6] == 0x30 && sub_407f90(rax, \"GB18030\", 0, 0) != 0)\nif (*arg1 == 0x60)\nreturn &data_41aef3\nreturn &data_41aeee\nif ((rax[1] & 0xdf) == 0x54 && (rax[2] & 0xdf) == 0x46 && rax[3] == 0x2d && rax[4] == 0x38 && rax[5] == 0)\nif (*arg1 == 0x60)\nreturn &data_41aef7\nreturn &data_41aeea\nif (arg2 == 9)\nreturn &data_41aef1\nreturn \"'\"",
        "pseudoc": "{\n    char* rax = nl_langinfo(0xe);\n    \n    if (rax)\n    {\n        char rax_1 = *(uint8_t*)rax;\n        \n        if (rax_1)\n        {\n            char rax_2 = rax_1 & 0xdf;\n            \n            if (rax_2 != 0x55)\n            {\n                if (rax_2 == 0x47 && (rax[1] & 0xdf) == 0x42 && rax[2] == 0x31 && rax[3] == 0x38\n                    && rax[4] == 0x30 && rax[5] == 0x33 && rax[6] == 0x30\n                    && sub_407f90(rax, \"GB18030\", 0, 0))\n                {\n                    if (*(uint8_t*)arg1 == 0x60)\n                        return &data_41aef3;\n                    \n                    return &data_41aeee;\n                }\n            }\n            else if ((rax[1] & 0xdf) == 0x54 && (rax[2] & 0xdf) == 0x46 && rax[3] == 0x2d\n                && rax[4] == 0x38 && !rax[5])\n            {\n                if (*(uint8_t*)arg1 == 0x60)\n                    return &data_41aef7;\n                \n                return &data_41aeea;\n            }\n        }\n    }\n    \n    if (arg2 == 9)\n        return &data_41aef1;\n    \n    return \"'\";\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_detect_locale_charset",
          "confidence": 0.86,
          "rationale": "The function queries nl_langinfo for the current character set, checks for \"GB18030\" or \"UTF-8\" patterns, and returns data pointers based on the detected locale encoding.",
          "evidence_refs": [
            "strings:GB18030",
            "imports:nl_langinfo",
            "call:0x404b50",
            "call:0x407f90"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_get_charset",
            "ai_locale_charset_lookup"
          ]
        },
        "explain": {
          "summary": "The function queries the system's codeset via nl_langinfo and checks if it matches \"GB18030\" or \"UTF-8\". Depending on the match and the first byte of arg1, it returns pointers to specific data tables; if no match and arg2 equals 9 it returns another table, otherwise it returns a default literal.",
          "details": [
            "Calls nl_langinfo(0xe) to obtain the current locale's encoding string.",
            "If the string starts with 'G' and matches \"GB18030\" (caseinsensitive) and sub_407f90 confirms the pattern, it returns either data_41aeee or data_41aef3 based on arg1[0] == 0x60.",
            "If the string matches \"UTF-8\" (caseinsensitive) it returns either data_41aeea or data_41aef7 based on the same arg1 check.",
            "When no known encoding is detected, it falls back to returning data_41aef1 if arg2 == 9, otherwise a default string \"'\"."
          ],
          "evidence_refs": [
            "strings:GB18030",
            "imports:nl_langinfo",
            "call:0x407f90"
          ],
          "unknowns": [
            "Exact semantics of arg1 and arg2 beyond the observed checks",
            "What the returned data pointers (data_41aeee, etc.) represent in the broader program"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40e040",
      "original_name": "sub_40e040",
      "final_name": "ai_cleanup_unlabeled_label",
      "score": 56.3,
      "bb_count": 7,
      "insn_est": 36,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x404920",
          "name": "ai_free_security_context",
          "original_name": "freecon"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        }
      ],
      "import_refs": [
        "strcmp",
        "freecon",
        "__errno_location",
        "__errno_location"
      ],
      "string_refs": [
        "unlabeled"
      ],
      "constants": [
        "0x404760",
        "0xffffffff",
        "0x41af03",
        "0x4046c0",
        "0x404920"
      ],
      "snippets": {
        "asm": "  0x40e040  endbr64 \n  0x40e044  push    rbp {__saved_rbp}\n  0x40e045  mov     rbp, rsp {__saved_rbp}\n  0x40e048  push    r13 {__saved_r13}\n  0x40e04a  push    r12 {__saved_r12}\n  0x40e04c  push    rbx {__saved_rbx}\n  0x40e04d  sub     rsp, 0x8\n  0x40e051  test    edi, edi\n  0x40e053  je      0x40e0b0\n  0x40e0b0  call    __errno_location\n  0x40e0b5  mov     dword [rax], 0x5f\n  0x40e0bb  jmp     0x40e0a4\n  0x40e055  mov     ebx, edi\n  0x40e057  cmp     edi, 0xa\n  0x40e05a  je      0x40e070\n  0x40e0a4  mov     ebx, 0xffffffff\n  0x40e0a9  jmp     0x40e05c\n  0x40e070  mov     r13, qword [rsi]\n  0x40e073  mov     r12, rsi\n  0x40e076  lea     rsi, [rel data_41af03]  {\"unlabeled\"}\n  0x40e07d  mov     rdi, r13\n  0x40e080  call    strcmp\n  0x40e085  test    eax, eax\n  0x40e087  jne     0x40e05c\n  0x40e05c  add     rsp, 0x8\n  0x40e060  mov     eax, ebx\n  0x40e062  pop     rbx {__saved_rbx}\n  0x40e063  pop     r12 {__saved_r12}\n  0x40e065  pop     r13 {__saved_r13}\n  0x40e067  pop     rbp {__saved_rbp}\n  ... (113 bytes total, truncated)",
        "hlil": "int32_t rbx_1\nif (arg1 == 0)\n*__errno_location() = 0x5f\nrbx_1 = -1\nrbx_1 = arg1\nif (arg1 == 0xa)\nchar* r13_1 = *arg2\nif (strcmp(r13_1, \"unlabeled\") == 0)\nfreecon(r13_1)\n*arg2 = 0\n*__errno_location() = 0x3d\nrbx_1 = -1\nreturn zx.q(rbx_1)",
        "pseudoc": "{\n    int32_t rbx_1;\n    \n    if (!arg1)\n    {\n        *(uint32_t*)__errno_location() = 0x5f;\n        rbx_1 = -1;\n    }\n    else\n    {\n        rbx_1 = arg1;\n        \n        if (arg1 == 0xa)\n        {\n            char* r13_1 = *(uint64_t*)arg2;\n            \n            if (!strcmp(r13_1, \"unlabeled\"))\n            {\n                freecon(r13_1);\n                *(uint64_t*)arg2 = 0;\n                *(uint32_t*)__errno_location() = 0x3d;\n                rbx_1 = -1;\n            }\n        }\n    }\n    \n    return (uint64_t)rbx_1;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_cleanup_unlabeled_label",
          "confidence": 0.78,
          "rationale": "The function checks for a specific label string \"unlabeled\" when arg1 equals 10, frees the associated security context via freecon, clears the pointer, and sets errno. This behavior matches cleanup of an unlabeled security context.",
          "evidence_refs": [
            "strings:unlabeled",
            "imports:strcmp",
            "imports:freecon",
            "imports:__errno_location",
            "call:0x4046c0",
            "call:0x404920",
            "call:0x404760"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_handle_unlabeled_label",
            "ai_free_unlabeled_context"
          ]
        },
        "explain": {
          "summary": "The function validates its inputs, setting errno and returning -1 on error. If the first argument is NULL it sets errno to 0x5f and fails. If the first argument equals 10 and the second argument points to the string \"unlabeled\", it frees the string, clears the pointer, sets errno to 0x3d, and fails. Otherwise it returns the original first argument unchanged.",
          "details": [
            "Checks if arg1 is zero; on failure writes errno=0x5f (EOPNOTSUPP) and returns -1.",
            "When arg1 equals 0xa (10), it dereferences arg2 to get a string pointer and compares it to \"unlabeled\" using strcmp.",
            "If the string matches, it calls freecon to release the context, nulls the pointer at arg2, sets errno=0x3d (ENODATA), and returns -1.",
            "In all other cases it simply returns the original arg1 value."
          ],
          "evidence_refs": [
            "strings:unlabeled",
            "imports:strcmp",
            "imports:freecon",
            "imports:__errno_location",
            "call:0x4046c0",
            "call:0x404920",
            "call:0x404760"
          ],
          "unknowns": [
            "The semantic meaning of the numeric arg1 values beyond the observed case of 10.",
            "The broader context in which this function is called (e.g., SELinux label handling)."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40e0c0",
      "original_name": "sub_40e0c0",
      "final_name": "ai_add_string_to_list",
      "score": 94.8,
      "bb_count": 22,
      "insn_est": 86,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x408fc0",
          "name": "ai_allocate_string_struct",
          "original_name": "sub_408fc0"
        }
      ],
      "import_refs": [
        "strcmp",
        "strlen",
        "strcmp",
        "strlen",
        "memcpy"
      ],
      "string_refs": [],
      "constants": [
        "0x41af54",
        "0x4048e0",
        "0x4046c0",
        "0x408fc0",
        "0x404ad0"
      ],
      "snippets": {
        "asm": "  0x40e0c0  endbr64 \n  0x40e0c4  push    rbp {__saved_rbp}\n  0x40e0c5  mov     rbp, rsp {__saved_rbp}\n  0x40e0c8  push    r15 {__saved_r15}\n  0x40e0ca  push    r14 {__saved_r14}\n  0x40e0cc  push    r13 {__saved_r13}\n  0x40e0ce  push    r12 {__saved_r12}\n  0x40e0d0  push    rbx {__saved_rbx}\n  0x40e0d1  sub     rsp, 0x8\n  0x40e0d5  mov     r13, qword [rsi+0x30]\n  0x40e0d9  test    r13, r13\n  0x40e0dc  je      0x40e164\n  0x40e164  mov     eax, 0x1\n  0x40e0e2  mov     r12, rdi\n  0x40e0e5  mov     r14, rsi\n  0x40e0e8  cmp     r13, rsi\n  0x40e0eb  jb      0x40e0f6\n  0x40e0f6  cmp     byte [r13], 0x0\n  0x40e0fb  lea     rbx, [r12+0x9]\n  0x40e100  je      0x40e180\n  0x40e0ed  lea     rax, [rsi+0x38]\n  0x40e0f1  cmp     r13, rax\n  0x40e0f4  jb      0x40e164\n  0x40e180  lea     rbx, [rel data_41af54]\n  0x40e187  jmp     0x40e160\n  0x40e102  nop     word [rax+rax]\n  0x40e160  mov     qword [r14+0x30], rbx\n  0x40e117  cmp     byte [rbx], 0x0\n  0x40e11a  jne     0x40e12e\n  0x40e12e  mov     rdi, rbx\n  ... (280 bytes total, truncated)",
        "hlil": "char* r13 = *(arg2 + 0x30)\nif (r13 != 0)\nint64_t** r12_1 = arg1\nif (r13 u< arg2 || r13 u>= arg2 + 0x38)\nchar* rbx_1 = r12_1 + 9\nif (*r13 == 0)\nrbx_1 = &data_41af54\nwhile (strcmp(rbx_1, r13) != 0)\nwhile (true)\nif (*rbx_1 == 0 && (rbx_1 != r12_1 + 9 || r12_1[1].b == 0))\nuint64_t rax_8 = strlen(r13)\nif (&r12_1[0x10] - rbx_1 s<= rax_8 + 1)\nint64_t* rax_11 = sub_408fc0(r13)\n*r12_1 = rax_11\nif (rax_11 == 0)\nreturn 0\nrax_11[1].b = 0\nrbx_1 = rax_11 + 9\nmemcpy(rbx_1, r13, rax_8 + 1)\nrbx_1[rax_8 + 1] = 0\ngoto label_40e160\nrbx_1 = &rbx_1[strlen(rbx_1) + 1]\nif (*rbx_1 != 0)\nbreak\nint64_t* rax_5 = *r12_1\nif (rax_5 == 0)\nbreak\nrbx_1 = rax_5 + 9\nr12_1 = rax_5\nif (strcmp(rbx_1, r13) == 0)\ngoto label_40e160\nlabel_40e160:\n*(arg2 + 0x30) = rbx_1\nreturn 1",
        "pseudoc": "{\n    char* r13 = *(uint64_t*)((char*)arg2 + 0x30);\n    \n    if (r13)\n    {\n        int64_t** r12_1 = arg1;\n        \n        if (r13 < arg2 || r13 >= (char*)arg2 + 0x38)\n        {\n            char* rbx_1 = (char*)r12_1 + 9;\n            \n            if (!*(uint8_t*)r13)\n                rbx_1 = &data_41af54;\n            else\n            {\n                while (strcmp(rbx_1, r13))\n                {\n                    while (true)\n                    {\n                        if (!*(uint8_t*)rbx_1 && (rbx_1 != (char*)r12_1 + 9 || !r12_1[1]))\n                        {\n                            uint64_t rax_8 = strlen(r13);\n                            \n                            if (&r12_1[0x10] - rbx_1 <= rax_8 + 1)\n                            {\n                                int64_t* rax_11 = sub_408fc0(r13);\n                                *(uint64_t*)r12_1 = rax_11;\n                                \n                                if (!rax_11)\n                                    return 0;\n                                \n                                rax_11[1] = 0;\n                                rbx_1 = (char*)rax_11 + 9;\n                            }\n                            else\n                            {\n                                memcpy(rbx_1, r13, rax_8 + 1);\n                                rbx_1[rax_8 + 1] = 0;\n                            }\n                            \n                            goto label_40e160;\n                        }\n                        \n                        rbx_1 = &rbx_1[strlen(rbx_1) + 1];\n                        \n                        if (*(uint8_t*)rbx_1)\n                            break;\n                        \n                        int64_t* rax_5 = *(uint64_t*)r12_1;\n                        \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_add_string_to_list",
          "confidence": 0.78,
          "rationale": "The function iterates over a list of null-terminated strings, compares each entry with a target string using strcmp, and inserts or appends the string if not present, allocating memory when needed. This behavior matches adding a string to a configuration or string list.",
          "evidence_refs": [
            "imports:strcmp",
            "imports:strlen",
            "imports:memcpy",
            "call:0x408fc0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_insert_string",
            "ai_append_to_string_array"
          ]
        },
        "explain": {
          "summary": "sub_40e0c0 inserts a string referenced by arg2+0x30 into a nullterminated string list stored in the structure pointed to by arg1, avoiding duplicates and expanding the buffer when needed. It handles empty strings specially, uses strcmp to compare existing entries, and allocates a new buffer via sub_408fc0 if the current buffer lacks space.",
          "details": [
            "The function reads a pointer (r13) from arg2+0x30; if null it does nothing.",
            "It iterates over the existing string list (starting at arg1+9) using strcmp to find a matching entry.",
            "If the string is not found, it checks for space; if insufficient, it calls sub_408fc0 to allocate a larger buffer and updates the structure.",
            "When space is sufficient, it copies the new string with memcpy and updates the list termination.",
            "An empty string case redirects to a default string at data_41af54."
          ],
          "evidence_refs": [
            "imports:strcmp",
            "imports:strlen",
            "imports:memcpy",
            "call:0x408fc0",
            "strings:data_41af54"
          ],
          "unknowns": [
            "Exact layout of the structure pointed to by arg1 (fields beyond offsets used).",
            "The purpose of the return value and how callers interpret it.",
            "Full behavior after label_40e160 (truncated code)."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40e1f0",
      "original_name": "sub_40e1f0",
      "final_name": "ai_manage_timezone_env",
      "score": 102.5,
      "bb_count": 16,
      "insn_est": 80,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x408fc0",
          "name": "ai_allocate_string_struct",
          "original_name": "sub_408fc0"
        },
        {
          "addr": "0x404c50",
          "name": "ai_unset_environment_variable",
          "original_name": "unsetenv"
        },
        {
          "addr": "0x404af0",
          "name": "ai_set_timezone",
          "original_name": "tzset"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x408fc0",
          "name": "ai_allocate_string_struct",
          "original_name": "sub_408fc0"
        },
        {
          "addr": "0x404850",
          "name": "ai_set_environment_variable",
          "original_name": "setenv"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        }
      ],
      "import_refs": [
        "getenv",
        "unsetenv",
        "tzset",
        "strcmp",
        "setenv",
        "__errno_location",
        "free"
      ],
      "string_refs": [],
      "constants": [
        "0x41af0d",
        "0x404700",
        "0x408fc0",
        "0x4046c0",
        "0x404850",
        "0x404c50",
        "0x404af0",
        "0x404760",
        "0x4046b0"
      ],
      "snippets": {
        "asm": "  0x40e1f0  endbr64 \n  0x40e1f4  push    rbp {__saved_rbp}\n  0x40e1f5  mov     rbp, rsp {__saved_rbp}\n  0x40e1f8  push    r14 {__saved_r14}\n  0x40e1fa  lea     r14, [rel data_41af0d]\n  0x40e201  push    r13 {__saved_r13}\n  0x40e203  push    r12 {__saved_r12}\n  0x40e205  mov     r12, rdi\n  0x40e208  mov     rdi, r14  {data_41af0d}\n  0x40e20b  push    rbx {__saved_rbx}\n  0x40e20c  call    getenv\n  0x40e211  mov     r13, rax\n  0x40e214  test    rax, rax\n  0x40e217  je      0x40e2d8\n  0x40e2d8  cmp     byte [r12+0x8], 0x0\n  0x40e2de  mov     ebx, 0x1\n  0x40e2e3  jne     0x40e276\n  0x40e21d  cmp     byte [r12+0x8], 0x0\n  0x40e223  jne     0x40e260\n  0x40e276  mov     rdi, r13\n  0x40e279  call    sub_408fc0\n  0x40e27e  mov     rbx, rax\n  0x40e281  test    rax, rax\n  0x40e284  je      0x40e2c4\n  0x40e2e5  mov     rax, rbx  {0x1}\n  0x40e2e8  pop     rbx {__saved_rbx}\n  0x40e2e9  pop     r12 {__saved_r12}\n  0x40e2eb  pop     r13 {__saved_r13}\n  0x40e2ed  pop     r14 {__saved_r14}\n  0x40e2ef  pop     rbp {__saved_rbp}\n  ... (241 bytes total, truncated)",
        "hlil": "char* rax = getenv(\"TZ\")\nif (rax == 0)\nif (*(arg1 + 8) == 0)\nreturn 1\ngoto label_40e279\nint64_t* i\nif (*(arg1 + 8) != 0)\nif (strcmp(arg1 + 9, rax) == 0)\nreturn 1\nlabel_40e279:\nint64_t* i_2 = sub_408fc0(rax)\ni = i_2\nif (i_2 != 0)\nif (setenv(\"TZ\", arg1 + 9, 1) != 0)\ngoto label_40e29c\ntzset()\nreturn i\nint64_t* i_1 = sub_408fc0(rax)\ni = i_1\nif (i_1 != 0)\nif (unsetenv(\"TZ\") == 0)\ntzset()\nreturn i\nlabel_40e29c:\nint32_t* rax_5 = __errno_location()\nint32_t r13_1 = *rax_5\nif (i != 1)\nint64_t* i_3 = i\ni = *i\nfree(i_3)\ndo while (i != 0)\n*rax_5 = r13_1\nreturn 0",
        "pseudoc": "{\n    char* rax = getenv(\"TZ\");\n    \n    if (!rax)\n    {\n        if (!*(uint8_t*)((char*)arg1 + 8))\n            return 1;\n        \n        goto label_40e279;\n    }\n    \n    int64_t* i;\n    \n    if (*(uint8_t*)((char*)arg1 + 8))\n    {\n        if (!strcmp((char*)arg1 + 9, rax))\n            return 1;\n        \n    label_40e279:\n        int64_t* i_2 = sub_408fc0(rax);\n        i = i_2;\n        \n        if (i_2)\n        {\n            if (setenv(\"TZ\", (char*)arg1 + 9, 1))\n                goto label_40e29c;\n            \n            tzset();\n            return i;\n        }\n    }\n    else\n    {\n        int64_t* i_1 = sub_408fc0(rax);\n        i = i_1;\n        \n        if (i_1)\n        {\n            if (!unsetenv(\"TZ\"))\n            {\n                tzset();\n                return i;\n            }\n            \n        label_40e29c:\n            int32_t* rax_5 = __errno_location();\n            int32_t r13_1 = *(uint32_t*)rax_5;\n            \n            if (i != 1)\n            {\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_manage_timezone_env",
          "confidence": 0.92,
          "rationale": "The function reads, compares, sets, or unsets the TZ environment variable and calls tzset, indicating it manages timezone configuration via environment variables.",
          "evidence_refs": [
            "imports:getenv",
            "imports:setenv",
            "imports:unsetenv",
            "imports:tzset",
            "strings:TZ",
            "call:0x408fc0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_set_tz_env",
            "ai_timezone_config"
          ]
        },
        "explain": {
          "summary": "The function manages the TZ environment variable: it checks the current TZ, optionally compares it with a new value, sets or unsets TZ accordingly, calls tzset to apply changes, and returns a saved copy of the previous TZ string or a sentinel.",
          "details": [
            "Retrieves the current TZ value using getenv(\"TZ\").",
            "If a flag byte at arg1+8 is set, it compares the new TZ string at arg1+9 with the existing one using strcmp; if they match it returns 1.",
            "When a new TZ is provided, it allocates a copy of the old TZ via sub_408fc0, then sets the new TZ with setenv and calls tzset.",
            "When the flag is not set, it allocates a copy of the old TZ, then unsets TZ with unsetenv and calls tzset.",
            "On failure of setenv/unsetenv, it reads errno via __errno_location for error handling."
          ],
          "evidence_refs": [
            "strings:TZ",
            "imports:getenv",
            "imports:setenv",
            "imports:unsetenv",
            "imports:tzset",
            "imports:strcmp",
            "imports:__errno_location",
            "call:0x408fc0"
          ],
          "unknowns": [
            "Exact layout and purpose of the structure pointed to by arg1 beyond the flag and string offsets.",
            "Meaning of the return value 1 versus a pointer from sub_408fc0 in the broader program context."
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x40e300",
      "original_name": "sub_40e300",
      "final_name": "ai_set_tz_env_and_cleanup",
      "score": 62.6,
      "bb_count": 7,
      "insn_est": 42,
      "callers": 5,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404c50",
          "name": "ai_unset_environment_variable",
          "original_name": "unsetenv"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404850",
          "name": "ai_set_environment_variable",
          "original_name": "setenv"
        },
        {
          "addr": "0x404af0",
          "name": "ai_set_timezone",
          "original_name": "tzset"
        }
      ],
      "import_refs": [
        "__errno_location",
        "unsetenv",
        "free",
        "setenv",
        "tzset"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x41af0d",
        "0x404850",
        "0x404c50",
        "0x404af0",
        "0x4046b0"
      ],
      "snippets": {
        "asm": "  0x40e300  endbr64 \n  0x40e304  push    rbp {__saved_rbp}\n  0x40e305  mov     rbp, rsp {__saved_rbp}\n  0x40e308  push    r14 {__saved_r14}\n  0x40e30a  push    r13 {__saved_r13}\n  0x40e30c  push    r12 {__saved_r12}\n  0x40e30e  push    rbx {__saved_rbx}\n  0x40e30f  mov     rbx, rdi\n  0x40e312  call    __errno_location\n  0x40e317  cmp     byte [rbx+0x8], 0x0\n  0x40e31b  mov     r13d, dword [rax]\n  0x40e31e  mov     r12, rax\n  0x40e321  jne     0x40e360\n  0x40e360  lea     rsi, [rbx+0x9]\n  0x40e364  mov     edx, 0x1\n  0x40e369  lea     rdi, [rel data_41af0d]\n  0x40e370  call    setenv\n  0x40e375  test    eax, eax\n  0x40e377  jne     0x40e333\n  0x40e323  lea     rdi, [rel data_41af0d]\n  0x40e32a  call    unsetenv\n  0x40e32f  test    eax, eax\n  0x40e331  je      0x40e379\n  0x40e333  mov     r13d, dword [r12]\n  0x40e337  xor     r14d, r14d  {0x0}\n  0x40e33a  nop     word [rax+rax]\n  0x40e379  call    tzset\n  0x40e37e  mov     r14d, 0x1\n  0x40e384  jmp     0x40e340\n  0x40e340  mov     rdi, rbx\n  ... (134 bytes total, truncated)",
        "hlil": "int64_t* i = arg1\nint32_t* rax = __errno_location()\nint32_t r13 = *rax\nint32_t r14\nif (i[1].b != 0)\nif (setenv(\"TZ\", i + 9, 1) != 0)\nr13 = *rax\nr14 = 0\ntzset()\nr14 = 1\nif (unsetenv(\"TZ\") == 0)\ntzset()\nr14 = 1\nr13 = *rax\nr14 = 0\nint64_t* i_1 = i\ni = *i\nfree(i_1)\ndo while (i != 0)\n*rax = r13\nreturn zx.q(r14)",
        "pseudoc": "{\n    int64_t* i = arg1;\n    int32_t* rax = __errno_location();\n    int32_t r13 = *(uint32_t*)rax;\n    int32_t r14;\n    \n    if (i[1])\n    {\n        if (setenv(\"TZ\", (char*)i + 9, 1))\n        {\n            r13 = *(uint32_t*)rax;\n            r14 = 0;\n        }\n        else\n        {\n            tzset();\n            r14 = 1;\n        }\n    }\n    else if (!unsetenv(\"TZ\"))\n    {\n        tzset();\n        r14 = 1;\n    }\n    else\n    {\n        r13 = *(uint32_t*)rax;\n        r14 = 0;\n    }\n    \n    do\n    {\n        int64_t* i_1 = i;\n        i = *(uint64_t*)i;\n        free(i_1);\n    } while (i);\n    \n    *(uint32_t*)rax = r13;\n    return (uint64_t)r14;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_tz_env_and_cleanup",
          "confidence": 0.88,
          "rationale": "The function sets or unsets the TZ environment variable using setenv/unsetenv, calls tzset to apply changes, and then frees a linked list of allocated structures, preserving errno. This matches behavior of configuring timezone environment and cleaning up resources.",
          "evidence_refs": [
            "imports:setenv",
            "imports:unsetenv",
            "imports:tzset",
            "imports:free",
            "strings:TZ"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_set_tz_env",
            "ai_tz_env_cleanup"
          ]
        },
        "explain": {
          "summary": "The function updates the process timezone by setting or unsetting the TZ environment variable based on a linked list node, calls tzset to apply the change, restores the original errno, and frees the list.",
          "details": [
            "If the second field of the node is nonzero, it attempts setenv(\"TZ\", <string>), calling tzset() on success; otherwise it records the error.",
            "If the flag is zero, it attempts unsetenv(\"TZ\"), calling tzset() on success; otherwise it records the error.",
            "After handling the environment change, it iterates through the linked list, freeing each node, and finally restores the saved errno before returning a success flag."
          ],
          "evidence_refs": [
            "imports:setenv",
            "imports:unsetenv",
            "imports:tzset",
            "imports:__errno_location",
            "imports:free",
            "strings:TZ",
            "call:0x404760",
            "call:0x404c50",
            "call:0x4046b0"
          ],
          "unknowns": [
            "Exact layout of the linked list node and meaning of the flag at i[1]",
            "Source of the string at offset 9 from the node"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x40e390",
      "original_name": "sub_40e390",
      "final_name": "ai_set_timezone_and_get_localtime",
      "score": 60.6,
      "bb_count": 11,
      "insn_est": 57,
      "callers": 2,
      "callees": [
        {
          "addr": "0x40e1f0",
          "name": "ai_manage_timezone_env",
          "original_name": "sub_40e1f0"
        },
        {
          "addr": "0x404780",
          "name": "ai_localtime_wrapper",
          "original_name": "localtime_r"
        },
        {
          "addr": "0x40e0c0",
          "name": "ai_add_string_to_list",
          "original_name": "sub_40e0c0"
        },
        {
          "addr": "0x40e300",
          "name": "ai_set_tz_env_and_cleanup",
          "original_name": "sub_40e300"
        },
        {
          "addr": "0x40e300",
          "name": "ai_set_tz_env_and_cleanup",
          "original_name": "sub_40e300"
        },
        {
          "addr": "0x404980",
          "name": "ai_gmtime_wrapper",
          "original_name": "gmtime_r"
        }
      ],
      "import_refs": [
        "localtime_r",
        "gmtime_r"
      ],
      "string_refs": [],
      "constants": [
        "0x404980",
        "0x40e1f0",
        "0x404780",
        "0x40e0c0",
        "0x40e300"
      ],
      "snippets": {
        "asm": "  0x40e390  push    rbp {__saved_rbp}\n  0x40e391  mov     rbp, rsp {__saved_rbp}\n  0x40e394  push    r14 {__saved_r14}\n  0x40e396  mov     r14, rsi\n  0x40e399  push    r13 {__saved_r13}\n  0x40e39b  push    r12 {__saved_r12}\n  0x40e39d  push    rbx {__saved_rbx}\n  0x40e39e  mov     rbx, rdx\n  0x40e3a1  test    rdi, rdi\n  0x40e3a4  je      0x40e418\n  0x40e418  pop     rbx {__saved_rbx}\n  0x40e419  mov     rdi, r14\n  0x40e41c  pop     r12 {__saved_r12}\n  0x40e41e  mov     rsi, rdx\n  0x40e421  pop     r13 {__saved_r13}\n  0x40e423  pop     r14 {__saved_r14}\n  0x40e425  pop     rbp {__saved_rbp}\n  0x40e426  jmp     gmtime_r\n  0x40e3a6  mov     r13, rdi\n  0x40e3a9  call    sub_40e1f0\n  0x40e3ae  mov     r12, rax\n  0x40e3b1  test    rax, rax\n  0x40e3b4  je      0x40e406\n  0x40e406  pop     rbx {__saved_rbx}\n  0x40e407  xor     eax, eax  {0x0}\n  0x40e409  pop     r12 {__saved_r12}\n  0x40e40b  pop     r13 {__saved_r13}\n  0x40e40d  pop     r14 {__saved_r14}\n  0x40e40f  pop     rbp {__saved_rbp}\n  0x40e410  retn     {__return_addr}\n  ... (143 bytes total, truncated)",
        "hlil": "if (arg1 == 0)\nreturn gmtime_r(arg2, arg3) __tailcall\nint64_t* rax = sub_40e1f0(arg1)\nif (rax != 0)\nstruct tm* rax_1 = localtime_r(arg2, arg3)\nchar rax_2\nif (rax_1 != 0)\nrax_2 = sub_40e0c0(arg1, arg3)\nif (rax_1 != 0 && rax_2 != 0)\nchar rax_3\nif (rax != 1)\nrax_3 = sub_40e300(rax)\nif (rax == 1 || rax_3 != 0)\nreturn arg3\nif (rax != 1)\nsub_40e300(rax)\nreturn 0",
        "pseudoc": "{\n    if (!arg1)\n        /* tailcall */\n        return gmtime_r(arg2, arg3);\n    \n    int64_t* rax = sub_40e1f0(arg1);\n    \n    if (rax)\n    {\n        struct tm* rax_1 = localtime_r(arg2, arg3);\n        char rax_2;\n        \n        if (rax_1)\n            rax_2 = sub_40e0c0(arg1, arg3);\n        \n        if (rax_1 && rax_2)\n        {\n            char rax_3;\n            \n            if (rax != 1)\n                rax_3 = sub_40e300(rax);\n            \n            if (rax == 1 || rax_3)\n                return arg3;\n        }\n        else if (rax != 1)\n            sub_40e300(rax);\n    }\n    \n    return 0;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_set_timezone_and_get_localtime",
          "confidence": 0.78,
          "rationale": "The function checks a timezone configuration, manipulates the TZ environment variable via sub_40e1f0, then calls localtime_r or gmtime_r to obtain a struct tm, indicating it sets/adjusts timezone before returning a time structure.",
          "evidence_refs": [
            "imports:localtime_r",
            "imports:gmtime_r",
            "call:0x40e1f0",
            "call:0x40e0c0",
            "call:0x40e300"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_tz_localtime_wrapper",
            "ai_adjust_tz_and_get_time"
          ]
        },
        "explain": {
          "summary": "sub_40e390 selects a time conversion based on a timezone argument. If no timezone is provided it returns UTC via gmtime_r; otherwise it attempts to set the TZ environment using sub_40e1f0, obtains local time with localtime_r, validates the result with sub_40e0c0, and conditionally cleans up with sub_40e300 before returning the populated struct tm or NULL.",
          "details": [
            "When arg1 is NULL the function simply tailcalls gmtime_r(arg2, arg3) to produce a UTC time structure.",
            "If arg1 is nonNULL, sub_40e1f0 is called to adjust the TZ environment; a nonzero return indicates a successful timezone change.",
            "localtime_r(arg2, arg3) is then invoked to compute the local time according to the possibly modified TZ setting.",
            "sub_40e0c0 validates or adjusts the tm structure against the timezone data; if it succeeds and the earlier TZ change returned a special value (1) or sub_40e300 succeeds, the function returns arg3.",
            "If validation fails or the TZ change did not return the special value, sub_40e300 is called for cleanup and the function returns NULL."
          ],
          "evidence_refs": [
            "imports:localtime_r",
            "imports:gmtime_r",
            "call:0x40e1f0",
            "call:0x40e0c0",
            "call:0x40e300"
          ],
          "unknowns": [
            "Exact semantics of sub_40e300 (cleanup or state restoration)",
            "Precise structure and meaning of arg1 and arg2 buffers",
            "Full logic inside sub_40e0c0 that performs string comparison and memory operations"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x40e430",
      "original_name": "sub_40e430",
      "final_name": "ai_memory_exhausted_abort",
      "score": 54.1,
      "bb_count": 1,
      "insn_est": 17,
      "callers": 17,
      "callees": [
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        }
      ],
      "import_refs": [
        "dcgettext",
        "error",
        "abort"
      ],
      "string_refs": [
        "memory exhausted"
      ],
      "constants": [
        "0x41ae7b",
        "0x423088",
        "0x4048c0",
        "0x41b563",
        "0x404c30",
        "0x404750"
      ],
      "snippets": {
        "asm": "  0x40e430  endbr64 \n  0x40e434  push    rbp {var_8}\n  0x40e435  mov     edx, 0x5\n  0x40e43a  lea     rsi, [rel data_41ae7b]  {\"memory exhausted\"}\n  0x40e441  xor     edi, edi  {0x0}\n  0x40e443  mov     rbp, rsp {var_8}\n  0x40e446  push    rbx {var_10}\n  0x40e447  sub     rsp, 0x8\n  0x40e44b  mov     ebx, dword [rel data_423088]\n  0x40e451  call    dcgettext\n  0x40e456  lea     rdx, [rel data_41b561[2]]  {\"%s\"}\n  0x40e45d  xor     esi, esi  {0x0}\n  0x40e45f  mov     rcx, rax\n  0x40e462  mov     edi, ebx\n  0x40e464  xor     eax, eax  {0x0}\n  0x40e466  call    error\n  0x40e46b  call    abort\n  0x40e46b  { Does not return }",
        "hlil": "error(zx.q(data_423088), 0, \"%s\", dcgettext(nullptr, \"memory exhausted\", 5))\nabort()\nnoreturn",
        "pseudoc": "{\n    error((uint64_t)data_423088, 0, \"%s\", dcgettext(nullptr, \"memory exhausted\", 5));\n    abort();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_memory_exhausted_abort",
          "confidence": 0.96,
          "rationale": "The function logs a 'memory exhausted' error via error() and then calls abort(), indicating a fatal out-of-memory handler.",
          "evidence_refs": [
            "strings:memory exhausted",
            "imports:error",
            "imports:abort",
            "call:0x404c30",
            "call:0x404750"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_fatal_memory_error",
            "ai_out_of_memory_handler"
          ]
        },
        "explain": {
          "summary": "sub_40e430 is a fatal out-of-memory handler. It retrieves a localized \"memory exhausted\" message, reports it via the error() function, and then aborts the program execution.",
          "details": [
            "Calls dcgettext with \"memory exhausted\" to obtain a localized error string.",
            "Invokes error() with a status code from data_423088 and the formatted message.",
            "Calls abort() to terminate the process; the function does not return."
          ],
          "evidence_refs": [
            "strings:memory exhausted",
            "imports:error",
            "imports:abort",
            "imports:dcgettext",
            "call:0x4048c0",
            "call:0x404c30",
            "call:0x404750"
          ],
          "unknowns": [
            "Exact value and meaning of data_423088 used as the error status",
            "Whether any cleanup occurs before abort"
          ],
          "confidence": 0.97
        }
      },
      "is_boring": false,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x40e470",
      "original_name": "sub_40e470",
      "final_name": "ai_allocate_and_store_128bit",
      "score": 24.6,
      "bb_count": 3,
      "insn_est": 17,
      "callers": 3,
      "callees": [
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "malloc"
      ],
      "string_refs": [],
      "constants": [
        "0x4046d0",
        "0x40e430",
        "0x423458"
      ],
      "snippets": {
        "asm": "  0x40e470  push    rbp {__saved_rbp}\n  0x40e471  mov     rbp, rsp {__saved_rbp}\n  0x40e474  push    rbx {__saved_rbx}\n  0x40e475  mov     rbx, rdi\n  0x40e478  mov     edi, 0x10\n  0x40e47d  sub     rsp, 0x8\n  0x40e481  call    malloc\n  0x40e486  test    rax, rax\n  0x40e489  je      0x40e4a7\n  0x40e4a7  call    sub_40e430\n  0x40e4a7  { Does not return }\n  0x40e48b  movq    xmm0, rbx\n  0x40e490  movhps  xmm0, qword [rel data_423458]\n  0x40e497  mov     qword [rel data_423458], rax\n  0x40e49e  movups  xmmword [rax], xmm0\n  0x40e4a1  mov     rbx, qword [rbp-0x8 {__saved_rbx}]\n  0x40e4a5  leave    {__saved_rbp}\n  0x40e4a6  retn     {__return_addr}",
        "hlil": "uint128_t* result = malloc(0x10)\nif (result == 0)\nsub_40e430()\nnoreturn\nuint128_t zmm0 = arg1 | data_423458 << 0x40\ndata_423458 = result\n*result = zmm0\nreturn result",
        "pseudoc": "{\n    uint128_t* result = malloc(0x10);\n    \n    if (!result)\n    {\n        sub_40e430();\n        /* no return */\n    }\n    \n    uint128_t zmm0 = arg1 | data_423458 << 0x40;\n    data_423458 = result;\n    *(uint128_t*)result = zmm0;\n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_allocate_and_store_128bit",
          "confidence": 0.86,
          "rationale": "The function allocates a 16-byte block, combines a 128-bit value from an argument and a global, stores it, updates a global pointer, and handles allocation failure via an error routine.",
          "evidence_refs": [
            "imports:malloc",
            "call:0x40e430",
            "strings:memory exhausted"
          ],
          "tags": [],
          "alt_names": [
            "ai_alloc_128bit",
            "ai_set_global_128"
          ]
        },
        "explain": {
          "summary": "sub_40e470 allocates a 16byte block, aborts with a memoryexhausted error if allocation fails, packs the function argument together with a global pointer into a 128bit value, stores it in the new block, updates the global pointer, and returns the allocated block.",
          "details": [
            "Calls malloc(0x10) to obtain a 16byte buffer; on failure it calls sub_40e430 which prints \"memory exhausted\" and aborts.",
            "Creates a 128bit value where the lower 64 bits are the input argument and the upper 64 bits are the previous value of the global data_423458 (shifted left 64 bits).",
            "Writes this 128bit value into the allocated buffer, updates data_423458 to point to the new buffer, and returns the buffer pointer."
          ],
          "evidence_refs": [
            "imports:malloc",
            "call:0x40e430",
            "call:0x4046d0"
          ],
          "unknowns": [
            "Exact semantic meaning of the argument and the stored 128bit structure",
            "How the allocated nodes are later used by the program"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40e4b0",
      "original_name": "sub_40e4b0",
      "final_name": "ai_resize_sort_file_buffer",
      "score": 191.0,
      "bb_count": 36,
      "insn_est": 165,
      "callers": 4,
      "callees": [
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4047f0",
          "name": "ai_reallocarray_wrapper",
          "original_name": "reallocarray"
        },
        {
          "addr": "0x404a20",
          "name": "ai_setjmp_wrapper",
          "original_name": "_setjmp"
        },
        {
          "addr": "0x40b040",
          "name": "ai_compute_string_sort_key",
          "original_name": "sub_40b040"
        },
        {
          "addr": "0x408ce0",
          "name": "ai_sort_array_by_comparator",
          "original_name": "sub_408ce0"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        },
        {
          "addr": "0x4049a0",
          "name": "ai_assert_failure_handler",
          "original_name": "__assert_fail"
        }
      ],
      "import_refs": [
        "free",
        "reallocarray",
        "_setjmp",
        "__assert_fail"
      ],
      "string_refs": [
        "sort_files",
        "src/ls.c",
        "sort_type != sort_version"
      ],
      "constants": [
        "0x423318",
        "0x423448",
        "0x4243e0",
        "0x423450",
        "0x4046b0",
        "0x4047f0",
        "0x40e430",
        "0x423320",
        "0x423380",
        "0x404a20",
        "0x423478",
        "0x423344",
        "0x423701",
        "0x423488",
        "0x421f40",
        "0x4243e4",
        "0x419658",
        "0x1012",
        "0x41af10",
        "0x41af19",
        "0x4049a0",
        "0x4235a0",
        "0x40b040",
        "0x408ce0"
      ],
      "snippets": {
        "asm": "  0x40e4b0  push    rbp {__saved_rbp}\n  0x40e4b1  mov     rbp, rsp {__saved_rbp}\n  0x40e4b4  push    r15 {__saved_r15}\n  0x40e4b6  push    r14 {__saved_r14}\n  0x40e4b8  push    r13 {__saved_r13}\n  0x40e4ba  push    r12 {__saved_r12}\n  0x40e4bc  push    rbx {__saved_rbx}\n  0x40e4bd  sub     rsp, 0x8\n  0x40e4c1  mov     r13, qword [rel data_423318]\n  0x40e4c8  mov     rax, r13\n  0x40e4cb  shr     rax, 0x1\n  0x40e4ce  add     rax, r13\n  0x40e4d1  cmp     qword [rel data_423448], rax\n  0x40e4d8  jae     0x40e518\n  0x40e518  mov     r15d, dword [rel data_4243e0]\n  0x40e51f  test    r13, r13\n  0x40e522  je      0x40e768\n  0x40e4da  mov     rdi, qword [rel data_423450]\n  0x40e4e1  call    free\n  0x40e4e6  xor     edi, edi  {0x0}\n  0x40e4e8  mov     edx, 0x18\n  0x40e4ed  mov     rsi, r13\n  0x40e4f0  call    reallocarray\n  0x40e4f5  test    rax, rax\n  0x40e4f8  je      0x40e740\n  0x40e768  cmp     r15d, 0x2\n  0x40e76c  jne     0x40e588\n  0x40e528  mov     r14, qword [rel data_423450]\n  0x40e52f  xor     edx, edx  {0x0}\n  0x40e531  mov     rax, r14\n  ... (692 bytes total, truncated)",
        "hlil": "uint64_t nmemb = data_423318\nuint64_t i = (nmemb u>> 1) + nmemb\nif (data_423448 u< i)\nfree(data_423450)\nint64_t rax_2 = reallocarray(nullptr, nmemb, 0x18)\nif (rax_2 == 0)\nsub_40e430()\nnoreturn\nnmemb = data_423318\ndata_423450 = rax_2\ni = nmemb * 3\ndata_423448 = i\nint32_t r15 = data_4243e0\nif (nmemb != 0)\nuint64_t i_3 = data_423450\nint64_t rdx_1 = 0\ni = i_3\ni += 8\nint64_t rcx_2 = data_423320 + rdx_1\nrdx_1 += 0xd0\n*(i - 8) = rcx_2\ndo while (i_3 + (nmemb << 3) != i)\nif (r15 == 2)\ngoto label_40e65f\nif (data_423478 != 0)\ni = zx.q(data_423344 - 2)\nif (i.d u<= 1)\ni_3 = data_423450\nlabel_40e65f:\nint64_t rbx_1 = 0\nint64_t* r12_1 = *(i_3 + (rbx_1 << 3))\ni = r12_1[0x19]\nif (i == 0)\ni = sub_40b040(*r12_1, data_4235a0, *(r12_1 + 0xc4))\nrbx_1 += 1\nr12_1[0x19] = i\ndo while (rbx_1 u< nmemb)\nif (r15 != 6)\ngoto label_40e599\nif (r15 != 6)\n// ... truncated",
        "pseudoc": "{\n    uint64_t nmemb = data_423318;\n    uint64_t i = (nmemb >> 1) + nmemb;\n    \n    if (data_423448 < i)\n    {\n        free(data_423450);\n        int64_t rax_2 = reallocarray(nullptr, nmemb, 0x18);\n        \n        if (!rax_2)\n        {\n            sub_40e430();\n            /* no return */\n        }\n        \n        nmemb = data_423318;\n        data_423450 = rax_2;\n        i = nmemb * 3;\n        data_423448 = i;\n    }\n    \n    int32_t r15 = data_4243e0;\n    \n    if (nmemb)\n    {\n        uint64_t i_3 = data_423450;\n        int64_t rdx_1 = 0;\n        i = i_3;\n        \n        do\n        {\n            i += 8;\n            int64_t rcx_2 = data_423320 + rdx_1;\n            rdx_1 += 0xd0;\n            *(uint64_t*)(i - 8) = rcx_2;\n        } while (i_3 + (nmemb << 3) != i);\n        \n        if (r15 == 2)\n            goto label_40e65f;\n        \n        if (data_423478)\n        {\n            i = (uint64_t)(data_423344 - 2);\n            \n            if ((uint32_t)i <= 1)\n            {\n                i_3 = data_423450;\n            label_40e65f:\n                int64_t rbx_1 = 0;\n                \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_resize_sort_file_buffer",
          "confidence": 0.78,
          "rationale": "The function checks and expands a dynamically allocated array used for sorting files, using free and reallocarray, and references strings like 'sort_files' and 'sort_type != sort_version'.",
          "evidence_refs": [
            "strings:sort_files",
            "imports:reallocarray",
            "imports:free",
            "call:0x40e430"
          ],
          "tags": [
            "file_io",
            "process",
            "config"
          ],
          "alt_names": [
            "ai_ensure_sort_buffer_capacity",
            "ai_expand_file_list_array"
          ]
        },
        "explain": {
          "summary": "sub_40e4b0 expands and populates a dynamically allocated array used for sorting file entries. It checks current capacity, frees and reallocates the buffer if needed, then fills it with pointers to file structures before handling different sort modes.",
          "details": [
            "If the required number of elements (data_423318) exceeds the allocated size (data_423448), the old buffer (data_423450) is freed and a new buffer is allocated with reallocarray for 24byte entries.",
            "On allocation failure the function calls sub_40e430 (likely an error handler) and does not return.",
            "When capacity is sufficient, it iterates over the number of entries, writing pointers (data_423320 + offset) into the buffer at data_423450.",
            "A branch based on the global sort_type (data_4243e0) directs further processing, with a special case when sort_type == 2."
          ],
          "evidence_refs": [
            "strings:sort_files",
            "strings:src/ls.c",
            "strings:sort_type != sort_version",
            "imports:free",
            "imports:reallocarray",
            "imports:_setjmp",
            "call:0x40e430"
          ],
          "unknowns": [
            "Exact meaning of data_423478, data_423344 and the code after label_40e65f",
            "What sub_40e430 does beyond being an error handler",
            "How the populated array is later used for sorting"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "file_io",
        "process",
        "config"
      ]
    },
    {
      "addr": "0x40e7a0",
      "original_name": "sub_40e7a0",
      "final_name": "ai_url_encode",
      "score": 83.5,
      "bb_count": 13,
      "insn_est": 100,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4047f0",
          "name": "ai_reallocarray_wrapper",
          "original_name": "reallocarray"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "strlen",
        "reallocarray",
        "__sprintf_chk"
      ],
      "string_refs": [
        "%%%02x"
      ],
      "constants": [
        "0x4048e0",
        "0x4047f0",
        "0x40e430",
        "0x4234a0",
        "0x41af33",
        "0x404d60"
      ],
      "snippets": {
        "asm": "  0x40e7a0  push    rbp {__saved_rbp}\n  0x40e7a1  mov     rbp, rsp {__saved_rbp}\n  0x40e7a4  push    r15 {__saved_r15}\n  0x40e7a6  mov     r15, rdi\n  0x40e7a9  push    r14 {__saved_r14}\n  0x40e7ab  push    r13 {__saved_r13}\n  0x40e7ad  mov     r13d, esi\n  0x40e7b0  push    r12 {__saved_r12}\n  0x40e7b2  push    rbx {__saved_rbx}\n  0x40e7b3  sub     rsp, 0x18\n  0x40e7b7  call    strlen\n  0x40e7bc  xor     edi, edi  {0x0}\n  0x40e7be  mov     esi, 0x3\n  0x40e7c3  lea     rbx, [rax+0x1]\n  0x40e7c7  mov     rdx, rbx\n  0x40e7ca  call    reallocarray\n  0x40e7cf  test    rax, rax\n  0x40e7d2  je      0x40e900\n  0x40e900  call    sub_40e430\n  0x40e900  { Does not return }\n  0x40e7d8  mov     rdx, rax\n  0x40e7db  movzx   eax, byte [r15]\n  0x40e7df  mov     r14, rdx\n  0x40e7e2  test    al, al\n  0x40e7e4  je      0x40e8b4\n  0x40e8b4  mov     byte [r14], 0x0\n  0x40e8b8  add     rsp, 0x18\n  0x40e8bc  mov     rax, rdx\n  0x40e8bf  pop     rbx {__saved_rbx}\n  0x40e8c0  pop     r12 {__saved_r12}\n  ... (335 bytes total, truncated)",
        "hlil": "char* r15 = arg1\nuint64_t elem_size = strlen(arg1) + 1\nchar* result = reallocarray(nullptr, 3, elem_size)\nif (result == 0)\nsub_40e430()\nnoreturn\nchar rax_1 = *r15\nchar* r14 = result\nif (rax_1 != 0)\nuint64_t slen = elem_size * 3\nchar* s = result\nuint64_t slen_2 = slen\nwhile (true)\nr15 = &r15[1]\nuint64_t slen_1 = slen\nif (slen_2 u>= slen)\nslen_1 = slen_2\nif (rax_1 == 0x2f && arg2 != 0)\n*s = 0x2f\nuint64_t slen_4 = slen_1 - slen + 1\nif (slen_4 u< slen_1)\nslen_4 = slen_1\ns = &s[1]\nslen = slen - 1 - slen_1 + slen_4\nif (*(&data_4234a0 + zx.q(rax_1)) != 0)\n*s = rax_1\nuint64_t slen_5 = slen_1 - slen + 1\nif (slen_5 u< slen_1)\nslen_5 = slen_1\ns = &s[1]\nslen = slen - 1 - slen_1 + slen_5\n__sprintf_chk(s, 2, slen, \"%%%02x\", zx.q(rax_1))\nuint64_t slen_3 = slen_1 + 3 - slen\nif (slen_3 u< slen_1)\nslen_3 = slen_1\ns = &s[3]\nslen = slen - (slen_1 + 3) + slen_3\nrax_1 = *r15\nif (rax_1 == 0)\nbreak\n// ... truncated",
        "pseudoc": "{\n    char* r15 = arg1;\n    uint64_t elem_size = strlen(arg1) + 1;\n    char* result = reallocarray(nullptr, 3, elem_size);\n    \n    if (!result)\n    {\n        sub_40e430();\n        /* no return */\n    }\n    \n    char rax_1 = *(uint8_t*)r15;\n    char* r14 = result;\n    \n    if (rax_1)\n    {\n        uint64_t slen = elem_size * 3;\n        char* s = result;\n        uint64_t slen_2 = slen;\n        \n        while (true)\n        {\n            r15 = &r15[1];\n            uint64_t slen_1 = slen;\n            \n            if (slen_2 >= slen)\n                slen_1 = slen_2;\n            \n            if (rax_1 == 0x2f && arg2)\n            {\n                *(uint8_t*)s = 0x2f;\n                uint64_t slen_4 = slen_1 - slen + 1;\n                \n                if (slen_4 < slen_1)\n                    slen_4 = slen_1;\n                \n                s = &s[1];\n                slen = slen - 1 - slen_1 + slen_4;\n            }\n            else if (*(uint8_t*)(&data_4234a0 + (uint64_t)rax_1))\n            {\n                *(uint8_t*)s = rax_1;\n                uint64_t slen_5 = slen_1 - slen + 1;\n                \n                if (slen_5 < slen_1)\n                    slen_5 = slen_1;\n                \n                s = &s[1];\n                slen = slen - 1 - slen_1 + slen_5;\n            }\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_url_encode",
          "confidence": 0.93,
          "rationale": "The function allocates a buffer sized 3 * input length, iterates over each character, preserves '/' optionally, and uses a '%02x' format string to percentencode characters, matching typical URL/percent encoding behavior.",
          "evidence_refs": [
            "strings:%%%02x",
            "imports:strlen",
            "imports:reallocarray",
            "imports:__sprintf_chk",
            "call:0x4048e0",
            "call:0x4047f0",
            "call:0x404d60"
          ],
          "tags": [
            "networking"
          ],
          "alt_names": [
            "ai_percent_encode",
            "ai_url_escape"
          ]
        },
        "explain": {
          "summary": "sub_40e7a0 URLencodes an input string. It allocates a buffer three times the input length, copies safe characters directly, preserves '/' when a flag is set, and percentencodes other bytes using a \"%02x\" format. On allocation failure it invokes an error routine and does not return.",
          "details": [
            "Computes input length with strlen and allocates result buffer via reallocarray sized 3 * (len+1).",
            "Iterates over each character of the input; if the character is '/' and arg2 is true, copies it unchanged.",
            "Uses a lookup table at data_4234a0 to decide if a character is safe; safe characters are copied directly.",
            "For unsafe characters, formats them as \"%%02x\" using __sprintf_chk, producing a \"%XX\" escape sequence.",
            "Handles allocation failure by calling sub_40e430 (likely an error handler) and aborts."
          ],
          "evidence_refs": [
            "strings:%%%02x",
            "imports:strlen",
            "imports:reallocarray",
            "imports:__sprintf_chk",
            "call:0x4048e0",
            "call:0x4047f0",
            "call:0x404d60"
          ],
          "unknowns": [
            "Exact contents and purpose of the data_4234a0 lookup table.",
            "The meaning of the arg2 flag beyond slash handling.",
            "The return value of the function (not shown in snippet).",
            "Behavior of sub_40e430 on allocation failure."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "networking"
      ]
    },
    {
      "addr": "0x40e910",
      "original_name": "sub_40e910",
      "final_name": "ai_print_entry",
      "score": 242.6,
      "bb_count": 39,
      "insn_est": 197,
      "callers": 4,
      "callees": [
        {
          "addr": "0x414230",
          "name": "ai_validate_string_and_flag",
          "original_name": "sub_414230"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40e7a0",
          "name": "ai_url_encode",
          "original_name": "sub_40e7a0"
        },
        {
          "addr": "0x40e7a0",
          "name": "ai_url_encode",
          "original_name": "sub_40e7a0"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x40dde0",
          "name": "ai_obstack_write_global_counter",
          "original_name": "sub_40dde0"
        },
        {
          "addr": "0x404b90",
          "name": "ai_write_buffer_to_file",
          "original_name": "fwrite_unlocked"
        },
        {
          "addr": "0x40dde0",
          "name": "ai_obstack_write_global_counter",
          "original_name": "sub_40dde0"
        },
        {
          "addr": "0x404b90",
          "name": "ai_write_buffer_to_file",
          "original_name": "fwrite_unlocked"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404b90",
          "name": "ai_write_buffer_to_file",
          "original_name": "fwrite_unlocked"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__printf_chk",
        "free",
        "free",
        "fwrite_unlocked",
        "fwrite_unlocked",
        "free",
        "fwrite_unlocked",
        "__overflow",
        "__overflow",
        "__overflow",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x1000",
        "0xffffffffffffdf98",
        "0xffffffffffffdfa8",
        "0xffffffffffffdfc0",
        "0xffffffffffffdfb8",
        "0xffffffffffffdfb7",
        "0xffffffffffffdf80",
        "0x414230",
        "0x422fa8",
        "0x40bbb0",
        "0x4230c0",
        "0x423350",
        "0xffffffffffffdf90",
        "0xffffffffffffdf88",
        "0x4232ca",
        "0x40be90",
        "0x4230d0",
        "0x404960",
        "0x4232c9",
        "0x404b90",
        "0x423678",
        "0x40dde0",
        "0x4235a8",
        "0x40e7a0",
        "0xffffffffffffdfa0",
        "0x41b1ed",
        "0x41af54",
        "0x41af3a",
        "0xffffffffffffdf78",
        "0x404bd0"
      ],
      "snippets": {
        "asm": "  0x40e910  push    rbp {__saved_rbp}\n  0x40e911  mov     rbp, rsp {__saved_rbp}\n  0x40e914  push    r15 {__saved_r15}\n  0x40e916  push    r14 {__saved_r14}\n  0x40e918  push    r13 {__saved_r13}\n  0x40e91a  push    r12 {__saved_r12}\n  0x40e91c  push    rbx {__saved_rbx}\n  0x40e91d  sub     rsp, 0x1000\n  0x40e924  or      qword [rsp {var_1030_1} {var_1030}], 0x0\n  0x40e929  sub     rsp, 0x1000\n  0x40e930  or      qword [rsp {var_2030_1} {var_2030}], 0x0\n  0x40e935  sub     rsp, 0x68\n  0x40e939  mov     r13, qword [rbp+0x10 {arg7}]\n  0x40e93d  mov     qword [rbp-0x2068 {var_2070}], rdi\n  0x40e944  mov     rbx, rdi\n  0x40e947  mov     r12, rcx\n  0x40e94a  mov     r14d, r8d\n  0x40e94d  mov     qword [rbp-0x2058 {var_2060}], r9\n  0x40e954  lea     rax, [rbp-0x2040 {var_2048}]\n  0x40e95b  xor     r8d, r8d  {0x0}\n  0x40e95e  lea     rdi, [rbp-0x2048 {var_2050}]\n  0x40e965  lea     r9, [rbp-0x2049 {var_2051}]\n  0x40e96c  mov     rcx, qword [fs:0x28]\n  0x40e975  mov     qword [rbp-0x38 {var_40}], rcx\n  0x40e979  xor     ecx, ecx  {0x0}\n  0x40e97b  mov     ecx, edx\n  0x40e97d  mov     rdx, rsi\n  0x40e980  mov     rsi, rbx\n  0x40e983  mov     qword [rbp-0x2080 {var_2088}], rax {var_2048}\n  0x40e98a  mov     qword [rbp-0x2048 {var_2050}], rax {var_2048}\n  ... (929 bytes total, truncated)",
        "hlil": "int64_t var_1030\nint64_t var_1030_1 = var_1030\nint64_t var_2030\nint64_t var_2030_1 = var_2030\nuint64_t r14 = zx.q(arg5)\nvoid* fsbase\nint64_t rcx = *(fsbase + 0x28)\nvoid var_2048\nchar* var_2050 = &var_2048\nchar var_2051\nuint64_t count_1 = sub_414230(&var_2050, arg1, arg2, arg3, nullptr, &var_2051, r14)\nchar r15 = var_2051\nif (r15 != 0 && r14.b != 0)\ndata_423350 += 1\nFILE* f_1 = *stdout\nchar* _IO_write_ptr_1 = f_1->_IO_write_ptr\nif (_IO_write_ptr_1 u>= f_1->_IO_write_end)\n__overflow(f_1, 0x20)\nf_1->_IO_write_ptr = &_IO_write_ptr_1[1]\n*_IO_write_ptr_1 = 0x20\nif (arg4 != 0)\nif (sub_40bbb0(4) != 0)\nsub_40be90(&data_4230c0)\nsub_40be90(&data_4230d0)\nsub_40be90(&data_4230c0)\nsub_40be90(arg4)\nsub_40be90(&data_4230d0)\nint64_t var_2080\nuint64_t count\nchar r12_1\nif (arg7 == 0)\ncount = count_1\nr12_1 = 0\nvar_2080 = 0\nr12_1 = data_4232ca\nif (r12_1 == 0)\ncount = count_1\nvar_2080 = 0\nif (data_4232c9 != 1 || r15 != 0)\ncount = count_1\n// ... truncated",
        "pseudoc": "{\n    int64_t var_1030;\n    int64_t var_1030_1 = var_1030;\n    int64_t var_2030;\n    int64_t var_2030_1 = var_2030;\n    uint64_t r14 = (uint64_t)arg5;\n    void* fsbase;\n    int64_t rcx = *(uint64_t*)((char*)fsbase + 0x28);\n    void var_2048;\n    char* var_2050 = &var_2048;\n    char var_2051;\n    uint64_t count_1 = sub_414230(&var_2050, arg1, arg2, arg3, nullptr, &var_2051, r14);\n    char r15 = var_2051;\n    \n    if (r15 && (uint8_t)r14)\n    {\n        data_423350 += 1;\n        FILE* f_1 = *(uint64_t*)stdout;\n        char* _IO_write_ptr_1 = f_1->_IO_write_ptr;\n        \n        if (_IO_write_ptr_1 >= f_1->_IO_write_end)\n            __overflow(f_1, 0x20);\n        else\n        {\n            f_1->_IO_write_ptr = &_IO_write_ptr_1[1];\n            *(uint8_t*)_IO_write_ptr_1 = 0x20;\n        }\n    }\n    \n    if (arg4)\n    {\n        if (sub_40bbb0(4))\n        {\n            sub_40be90(&data_4230c0);\n            sub_40be90(&data_4230d0);\n        }\n        \n        sub_40be90(&data_4230c0);\n        sub_40be90(arg4);\n        sub_40be90(&data_4230d0);\n    }\n    \n    int64_t var_2080;\n    uint64_t count;\n    char r12_1;\n    \n    if (!arg7)\n    {\n        count = count_1;\n        r12_1 = 0;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_entry",
          "confidence": 0.78,
          "rationale": "The function formats and writes data to stdout, inserting spaces and invoking sub_40be90 which performs fwrite_unlocked. It appears to handle output of entries (e.g., file names) with optional formatting flags.",
          "evidence_refs": [
            "imports:__printf_chk",
            "imports:fwrite_unlocked",
            "imports:__overflow",
            "call:0x414230",
            "call:0x40be90"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_output_formatter",
            "ai_print_line"
          ]
        },
        "explain": {
          "summary": "sub_40e910 parses input via sub_414230, conditionally prints a space to stdout, and performs cleanup and output of buffered data using sub_40be90. It also updates a global counter when a flag is set and frees resources associated with global buffers. The function appears to be part of a formatting or reporting routine that writes data to the standard output stream.",
          "details": [
            "Calls sub_414230 to process arguments and obtain a count and status flag (r15).",
            "If the status flag is true and a non-zero flag argument is provided, increments a global counter and writes a space character to stdout using __overflow or direct buffer manipulation.",
            "When arg4 is non-null, checks a condition via sub_40bbb0(4) and then frees or writes global buffers (data_4230c0, data_4230d0) using sub_40be90.",
            "Uses sub_40be90 to write buffered data to stdout via fwrite_unlocked, ensuring initialization of output handling on first call."
          ],
          "evidence_refs": [
            "call:0x414230",
            "call:0x40bbb0",
            "call:0x40be90",
            "imports:__overflow",
            "imports:fwrite_unlocked",
            "imports:free",
            "imports:__printf_chk"
          ],
          "unknowns": [
            "Exact semantics of the arguments arg1arg7 and the data structures referenced by data_4230c0, data_4230d0, etc.",
            "The full purpose of the count returned by sub_414230 and how it is used later in the truncated portion of the function."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x40ecd0",
      "original_name": "sub_40ecd0",
      "final_name": "ai_dispatch_operation",
      "score": 267.2,
      "bb_count": 74,
      "insn_est": 284,
      "callers": 3,
      "callees": [
        {
          "addr": "0x40e910",
          "name": "ai_print_entry",
          "original_name": "sub_40e910"
        },
        {
          "addr": "0x40bf40",
          "name": "ai_signal_suspension_loop",
          "original_name": "sub_40bf40"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40e910",
          "name": "ai_print_entry",
          "original_name": "sub_40e910"
        },
        {
          "addr": "0x40bf40",
          "name": "ai_signal_suspension_loop",
          "original_name": "sub_40bf40"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40e910",
          "name": "ai_print_entry",
          "original_name": "sub_40e910"
        },
        {
          "addr": "0x40bf40",
          "name": "ai_signal_suspension_loop",
          "original_name": "sub_40bf40"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404770",
          "name": "ai_strncmp_wrapper",
          "original_name": "strncmp"
        },
        {
          "addr": "0x407d70",
          "name": "ai_strnicmp",
          "original_name": "sub_407d70"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        }
      ],
      "import_refs": [
        "strlen",
        "strncmp"
      ],
      "string_refs": [],
      "constants": [
        "0x423342",
        "0x4235a0",
        "0x40e910",
        "0x40bf40",
        "0x40bbb0",
        "0xf000",
        "0x8000",
        "0x419620",
        "0xffffffff",
        "0x800",
        "0x4000",
        "0x4048e0",
        "0x423490",
        "0x4230c0",
        "0x400",
        "0x202",
        "0xa000",
        "0x100",
        "0x140",
        "0x1000",
        "0x40be90",
        "0x4230f0",
        "0x4230d0",
        "0x4230e0",
        "0x110",
        "0x200",
        "0x130",
        "0xc000",
        "0x404770",
        "0x4230e8"
      ],
      "snippets": {
        "asm": "  0x40ecd0  endbr64 \n  0x40ecd4  push    rbp {__saved_rbp}\n  0x40ecd5  mov     rbp, rsp {__saved_rbp}\n  0x40ecd8  push    r15 {__saved_r15}\n  0x40ecda  mov     r15d, esi\n  0x40ecdd  push    r14 {__saved_r14}\n  0x40ecdf  push    r13 {__saved_r13}\n  0x40ece1  mov     r13, rdi\n  0x40ece4  push    r12 {__saved_r12}\n  0x40ece6  mov     r12, rdx\n  0x40ece9  push    rbx {__saved_rbx}\n  0x40ecea  sub     rsp, 0x18\n  0x40ecee  mov     qword [rbp-0x38 {var_40}], rcx\n  0x40ecf2  movzx   eax, byte [rel data_423342]\n  0x40ecf9  test    sil, sil\n  0x40ecfc  je      0x40ed88\n  0x40ed88  mov     r14, qword [rdi]\n  0x40ed8b  test    al, al\n  0x40ed8d  je      0x40ed0a\n  0x40ed02  mov     r14, qword [rdi+0x8]\n  0x40ed06  test    al, al\n  0x40ed08  jne     0x40ed58\n  0x40ed0a  sub     rsp, 0x8\n  0x40ed0e  mov     edx, dword [r13+0xc4]\n  0x40ed15  xor     ecx, ecx  {0x0}\n  0x40ed17  mov     r9, r12\n  0x40ed1a  push    qword [r13+0x10] {var_58}\n  0x40ed1e  xor     r15d, 0x1\n  0x40ed22  mov     rsi, qword [rel data_4235a0]\n  0x40ed29  mov     rdi, r14\n  ... (1205 bytes total, truncated)",
        "hlil": "char rax = data_423342\nuint64_t result\nuint32_t rax_4\nint32_t r8_1\nchar* r14\nif (arg2 == 0)\nr14 = *arg1\nif (rax != 0)\nrax_4 = zx.d(*(arg1 + 0xb9))\nif (data_423340 != 0 && rax_4.b != 0)\nr8_1 = *(arg1 + 0xac)\nr8_1 = arg1[6].d\ngoto label_40edab\nresult = sub_40e910(r14, data_4235a0, *(arg1 + 0xc4), nullptr, zx.d(arg2) ^ 1, arg3, arg1[2])\nsub_40bf40()\nr14 = arg1[1]\nif (rax != 0)\nr8_1 = *(arg1 + 0xac)\nint64_t* rcx_7\nuint64_t rcx_3\nif (*(arg1 + 0xb9) != 0)\nrax_4 = 0\nif (arg1[0x17].b == 0)\nlabel_40edc7:\nuint64_t rcx_2 = zx.q(*(&data_419620 + (zx.q(arg1[0x15].d) << 2)))\nif (rcx_2.d != 5)\nif (rcx_2.d != 7 || rax_4 != 0)\nrcx_3 = rcx_2 << 4\ngoto label_40ee17\nlabel_40edeb:\nrcx_3 = 0xd0\nif (data_423340 == 0)\nchar rax_5\nint64_t rcx_4\nrax_5, rcx_4 = sub_40bbb0(0xd)\nrcx_3 = (sbb.q(rcx_4, rcx_4, rax_5 u< 1) & 0xffffffffffffffa0) + 0xd0\ngoto label_40ee17\nlabel_40eed3:\nint32_t rdx_7 = r8_1 & 0xf000\nif (rdx_7 != 0x8000)\n// ... truncated",
        "pseudoc": "{\n    char rax = data_423342;\n    uint64_t result;\n    uint32_t rax_4;\n    int32_t r8_1;\n    char* r14;\n    \n    if (!arg2)\n    {\n        r14 = *(uint64_t*)arg1;\n        \n        if (rax)\n        {\n            rax_4 = (uint32_t)*(uint8_t*)((char*)arg1 + 0xb9);\n            \n            if (data_423340 && (uint8_t)rax_4)\n                r8_1 = *(uint32_t*)((char*)arg1 + 0xac);\n            else\n                r8_1 = arg1[6];\n            \n            goto label_40edab;\n        }\n        \n        result = sub_40e910(r14, data_4235a0, *(uint32_t*)((char*)arg1 + 0xc4), nullptr, \n            (uint32_t)arg2 ^ 1, arg3, arg1[2]);\n        sub_40bf40();\n    }\n    else\n    {\n        r14 = arg1[1];\n        \n        if (rax)\n        {\n            r8_1 = *(uint32_t*)((char*)arg1 + 0xac);\n            int64_t* rcx_7;\n            uint64_t rcx_3;\n            \n            if (*(uint8_t*)((char*)arg1 + 0xb9))\n            {\n                rax_4 = 0;\n                \n                if (!arg1[0x17])\n                {\n                label_40edc7:\n                    uint64_t rcx_2 =\n                        (uint64_t)*(uint32_t*)(&data_419620 + ((uint64_t)arg1[0x15] << 2));\n                    \n                    if ((uint32_t)rcx_2 != 5)\n                    {\n                        if ((uint32_t)rcx_2 != 7 || rax_4)\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dispatch_operation",
          "confidence": 0.71,
          "rationale": "The function examines flags and fields in a data structure, selects behavior based on those values, and calls sub_40e910 (output/processing) and sub_40bf40 (signal handling). This pattern matches a dispatcher/handler for processing a configuration or command entry.",
          "evidence_refs": [
            "imports:strlen",
            "imports:strncmp",
            "call:0x40e910",
            "call:0x40bf40",
            "call:0x40bbb0"
          ],
          "tags": [
            "process",
            "config"
          ],
          "alt_names": [
            "ai_handle_entry",
            "ai_process_command"
          ]
        },
        "explain": {
          "summary": "sub_40ecd0 dispatches processing based on a mode flag (arg2) and a global flag (data_423342), extracts values from a complex structure, invokes sub_40e910 to perform formatted output or data handling, and then calls sub_40bf40 to flush output and manage pending signals. It also contains conditional logic that selects different fields and lookup tables depending on flag values.",
          "details": [
            "If arg2 is zero, the function uses a pointer from arg1[0] and, when the global flag is set, reads a byte at offset 0xb9 to decide which field (0xac or arg1[6]) to pass to later processing.",
            "When arg2 is non-zero, it uses arg1[1] as a pointer and similarly selects fields based on the global flag and other structure offsets, including a lookup in data_419620 indexed by arg1[0x15].",
            "The core operation is a call to sub_40e910 with parameters including a global data_4235a0, a value from arg1+0xc4, a XORed arg2 flag, and other fields; this likely formats or logs data.",
            "After sub_40e910 returns, sub_40bf40 is called, which flushes output streams and handles signal-related cleanup.",
            "The function references helper routines sub_40bbb0 (numeric checks) and sub_40be90 (cleanup), indicating it may validate or reset internal state before or after processing."
          ],
          "evidence_refs": [
            "imports:strlen",
            "imports:strncmp",
            "call:0x40e910",
            "call:0x40bf40",
            "call:0x40bbb0",
            "call:0x40be90"
          ],
          "unknowns": [
            "Exact semantics of the structure pointed to by arg1 and meaning of its offsets (e.g., 0xb9, 0xac, 0xc4).",
            "Purpose of the XOR operation on arg2 before passing to sub_40e910.",
            "Specific role of the global flag data_423342 and the table at data_419620.",
            "Detailed output format or side effects performed by sub_40e910."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "process",
        "config"
      ]
    },
    {
      "addr": "0x40f200",
      "original_name": "sub_40f200",
      "final_name": "ai_ensure_capacity",
      "score": 154.2,
      "bb_count": 43,
      "insn_est": 184,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4047f0",
          "name": "ai_reallocarray_wrapper",
          "original_name": "reallocarray"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        },
        {
          "addr": "0x4047f0",
          "name": "ai_reallocarray_wrapper",
          "original_name": "reallocarray"
        },
        {
          "addr": "0x4047f0",
          "name": "ai_reallocarray_wrapper",
          "original_name": "reallocarray"
        },
        {
          "addr": "0x40d850",
          "name": "ai_process_config_flags",
          "original_name": "sub_40d850"
        }
      ],
      "import_refs": [
        "reallocarray",
        "reallocarray",
        "reallocarray"
      ],
      "string_refs": [],
      "constants": [
        "0x423470",
        "0x423368",
        "0x423318",
        "0x423370",
        "0x4047f0",
        "0x40e430",
        "0x423450",
        "0x40d850",
        "0x423478"
      ],
      "snippets": {
        "asm": "  0x40f200  push    rbp {__saved_rbp}\n  0x40f201  mov     rbp, rsp {__saved_rbp}\n  0x40f204  push    r15 {__saved_r15}\n  0x40f206  push    r14 {__saved_r14}\n  0x40f208  push    r13 {__saved_r13}\n  0x40f20a  mov     r13d, edi\n  0x40f20d  push    r12 {__saved_r12}\n  0x40f20f  push    rbx {__saved_rbx}\n  0x40f210  sub     rsp, 0x18\n  0x40f214  mov     r15, qword [rel data_423470]\n  0x40f21b  mov     r14, qword [rel data_423368]\n  0x40f222  mov     rbx, qword [rel data_423318]\n  0x40f229  test    r15, r15\n  0x40f22c  je      0x40f264\n  0x40f264  cmp     r14, rbx\n  0x40f267  jae     0x40f429\n  0x40f22e  cmp     r15, rbx\n  0x40f231  jae     0x40f424\n  0x40f429  test    rbx, rbx\n  0x40f42c  je      0x40f493\n  0x40f26d  mov     rdi, qword [rel data_423370]\n  0x40f274  mov     edx, 0x30\n  0x40f279  mov     rsi, rbx\n  0x40f27c  lea     r15, [rbx+rbx]\n  0x40f280  call    reallocarray\n  0x40f285  mov     r12, rax\n  0x40f288  test    rax, rax\n  0x40f28b  je      0x40f25f\n  0x40f424  cmp     r14, rbx\n  0x40f427  jb      0x40f43a\n  ... (680 bytes total, truncated)",
        "hlil": "uint64_t nmemb_1 = data_423470\nint64_t r14 = data_423368\nuint64_t nmemb = data_423318\nint64_t r12_1\nif (nmemb_1 == 0)\nif (r14 u>= nmemb)\nlabel_40f429:\nif (nmemb == 0)\nreturn nmemb\nr12_1 = data_423370\ngoto label_40f319\nlabel_40f27c:\nnmemb_1 = nmemb * 2\nint64_t rax_2 = reallocarray(data_423370, nmemb, 0x30)\nr12_1 = rax_2\nif (rax_2 != 0)\nlabel_40f297:\ndata_423370 = r12_1\nint64_t rax_4 = nmemb_1 - r14\nint64_t rdx_2 = nmemb_1 + r14 + 1\nif (nmemb_1 + r14 + 1 u>= nmemb_1 && zx.q(mulu.dp.q(rax_4, rdx_2) u>> 0x40 != zx.o(0)) == 0)\nint64_t rax_7 = reallocarray(nullptr, (rax_4 * rdx_2) u>> 1, 8)\nif (rax_7 != 0)\nint64_t i = (r14 + 1) << 3\nif (r14 u< nmemb_1)\n*(r12_1 + i * 3 - 8) = rax_7\nrax_7 += i\ni += 8\ndo while ((nmemb_1 << 3) + 8 != i)\ndata_423368 = nmemb_1\ngoto label_40f319\nif (nmemb_1 u>= nmemb)\nif (r14 u>= nmemb)\ngoto label_40f429\nif (nmemb u< nmemb_1 u>> 1)\ngoto label_40f27c\ngoto label_40f252\nif (r14 u>= nmemb_1)\nr12_1 = data_423370\nnmemb = nmemb_1\n// ... truncated",
        "pseudoc": "{\n    uint64_t nmemb_1 = data_423470;\n    int64_t r14 = data_423368;\n    uint64_t nmemb = data_423318;\n    int64_t r12_1;\n    \n    if (!nmemb_1)\n    {\n        if (r14 >= nmemb)\n        {\n        label_40f429:\n            \n            if (!nmemb)\n                return nmemb;\n            \n            r12_1 = data_423370;\n            goto label_40f319;\n        }\n        \n    label_40f27c:\n        nmemb_1 = nmemb * 2;\n        int64_t rax_2 = reallocarray(data_423370, nmemb, 0x30);\n        r12_1 = rax_2;\n        \n        if (rax_2)\n        {\n        label_40f297:\n            data_423370 = r12_1;\n            int64_t rax_4 = nmemb_1 - r14;\n            int64_t rdx_2 = nmemb_1 + r14 + 1;\n            \n            if (nmemb_1 + r14 + 1 >= nmemb_1 && !(uint64_t)((rax_4 * rdx_2) >> 0x40 != {0}))\n            {\n                int64_t rax_7 = reallocarray(nullptr, (rax_4 * rdx_2) >> 1, 8);\n                \n                if (rax_7)\n                {\n                    int64_t i = (r14 + 1) << 3;\n                    \n                    if (r14 < nmemb_1)\n                    {\n                        do\n                        {\n                            *(uint64_t*)(r12_1 + i * 3 - 8) = rax_7;\n                            rax_7 += i;\n                            i += 8;\n                        } while ((nmemb_1 << 3) + 8 != i);\n                    }\n                    \n                    data_423368 = nmemb_1;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_ensure_capacity",
          "confidence": 0.86,
          "rationale": "The function dynamically resizes a buffer using reallocarray, checks capacity, and reallocates internal structures, typical of an ensure-capacity or buffer expansion routine.",
          "evidence_refs": [
            "imports:reallocarray",
            "call:0x4047f0",
            "call:0x40e430"
          ],
          "tags": [],
          "alt_names": [
            "ai_expand_buffer",
            "ai_dynamic_array_grow"
          ]
        },
        "explain": {
          "summary": "The function manages a growable data structure, doubling its capacity when needed, reallocating the main buffer (size 0x30 per element) and a secondary buffer of 8byte entries, while checking for overflow and aborting on allocation failure.",
          "details": [
            "It reads current capacity (data_423470), element count (data_423368) and a size parameter (data_423318) from global variables.",
            "If the current capacity is zero or insufficient, it computes a new capacity (nmemb_1 = nmemb * 2) and calls reallocarray to resize the primary buffer at data_423370.",
            "It then calculates a secondary allocation size based on remaining space and uses reallocarray to allocate a secondary array of 8byte entries, populating it in a loop.",
            "On any allocation failure it invokes sub_40e430, which prints \"memory exhausted\" and aborts execution."
          ],
          "evidence_refs": [
            "imports:reallocarray",
            "imports:error",
            "imports:abort",
            "call:0x4047f0",
            "call:0x40e430"
          ],
          "unknowns": [
            "Exact semantic meaning of the secondary array and how it is used later.",
            "The role of data_423318 and the constant values referenced."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40f4c0",
      "original_name": "sub_40f4c0",
      "final_name": "ai_user_name_cache_lookup",
      "score": 80.1,
      "bb_count": 12,
      "insn_est": 52,
      "callers": 3,
      "callees": [
        {
          "addr": "0x404890",
          "name": "ai_get_user_passwd_entry",
          "original_name": "getpwuid"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404bb0",
          "name": "ai_safe_strcpy",
          "original_name": "__strcpy_chk"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "getpwuid",
        "strlen",
        "malloc",
        "__strcpy_chk"
      ],
      "string_refs": [
        "D9#u",
        "[A\\A]A^]"
      ],
      "constants": [
        "0x423360",
        "0x41af54",
        "0x404890",
        "0x4046d0",
        "0x4048e0",
        "0x40e430",
        "0x404bb0"
      ],
      "snippets": {
        "asm": "  0x40f4c0  push    rbp {__saved_rbp}\n  0x40f4c1  mov     rbp, rsp {__saved_rbp}\n  0x40f4c4  push    r14 {__saved_r14}\n  0x40f4c6  push    r13 {__saved_r13}\n  0x40f4c8  push    r12 {__saved_r12}\n  0x40f4ca  mov     r12d, edi\n  0x40f4cd  push    rbx {__saved_rbx}\n  0x40f4ce  mov     rbx, qword [rel data_423360]\n  0x40f4d5  test    rbx, rbx\n  0x40f4d8  jne     0x40f4e9\n  0x40f4e9  cmp     dword [rbx], r12d\n  0x40f4ec  jne     0x40f4e0\n  0x40f4da  jmp     0x40f508\n  0x40f4e0  mov     rbx, qword [rbx+0x8]\n  0x40f4e4  test    rbx, rbx\n  0x40f4e7  je      0x40f508\n  0x40f4ee  xor     eax, eax  {0x0}\n  0x40f4f0  cmp     byte [rbx+0x10], 0x0\n  0x40f4f4  je      0x40f4fa\n  0x40f508  mov     edi, r12d\n  0x40f50b  mov     r13d, 0x18\n  0x40f511  lea     r14, [rel data_41af54]\n  0x40f518  call    getpwuid\n  0x40f51d  test    rax, rax\n  0x40f520  je      0x40f535\n  0x40f4fa  pop     rbx {__saved_rbx}\n  0x40f4fb  pop     r12 {__saved_r12}\n  0x40f4fd  pop     r13 {__saved_r13}\n  0x40f4ff  pop     r14 {__saved_r14}\n  0x40f501  pop     rbp {__saved_rbp}\n  ... (168 bytes total, truncated)",
        "hlil": "int32_t* rbx = data_423360\nif (rbx != 0)\nwhile (*rbx != arg1)\nrbx = *(rbx + 8)\nif (rbx == 0)\ngoto label_40f50b\nlabel_40f50b:\nsize_t n = 0x18\nchar* pw_name = &data_41af54\nstruct passwd* rax_2 = getpwuid(arg1)\nif (rax_2 != 0)\npw_name = rax_2->pw_name\nn = (strlen(pw_name) + 0x18) & 0xfffffffffffffff8\nint32_t* rax_4 = malloc(n)\nrbx = rax_4\nif (rax_4 == 0)\nsub_40e430()\nnoreturn\n*rax_4 = arg1\n__strcpy_chk(&rax_4[4], pw_name, n - 0x10)\nint64_t rax_5 = data_423360\ndata_423360 = rbx\n*(rbx + 8) = rax_5\nif (rbx[4].b == 0)\nreturn nullptr\nreturn &rbx[4]",
        "pseudoc": "{\n    int32_t* rbx = data_423360;\n    \n    if (rbx)\n    {\n        while (*(uint32_t*)rbx != arg1)\n        {\n            rbx = *(uint64_t*)((char*)rbx + 8);\n            \n            if (!rbx)\n                goto label_40f50b;\n        }\n    }\n    else\n    {\n    label_40f50b:\n        size_t n = 0x18;\n        char* pw_name = &data_41af54;\n        struct passwd* rax_2 = getpwuid(arg1);\n        \n        if (rax_2)\n        {\n            pw_name = rax_2->pw_name;\n            n = (strlen(pw_name) + 0x18) & 0xfffffffffffffff8;\n        }\n        \n        int32_t* rax_4 = malloc(n);\n        rbx = rax_4;\n        \n        if (!rax_4)\n        {\n            sub_40e430();\n            /* no return */\n        }\n        \n        *(uint32_t*)rax_4 = arg1;\n        __strcpy_chk(&rax_4[4], pw_name, n - 0x10);\n        int64_t rax_5 = data_423360;\n        data_423360 = rbx;\n        *(uint64_t*)((char*)rbx + 8) = rax_5;\n    }\n    \n    if (!rbx[4])\n        return nullptr;\n    \n    return &rbx[4];\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_user_name_cache_lookup",
          "confidence": 0.96,
          "rationale": "Function caches and returns the username string for a given UID, using getpwuid, malloc, and string copy, inserting into a linked list for future lookups.",
          "evidence_refs": [
            "imports:getpwuid",
            "imports:malloc",
            "imports:strlen",
            "imports:__strcpy_chk",
            "call:0x404890",
            "call:0x4046d0",
            "call:0x4048e0"
          ],
          "tags": [],
          "alt_names": [
            "ai_get_username",
            "ai_uid_to_name_cache"
          ]
        },
        "explain": {
          "summary": "sub_40f4c0 implements a simple UID-to-username cache. It searches a linked list for an entry matching the supplied UID, and if none is found it retrieves the username via getpwuid, allocates a new node, stores the UID and username, inserts it at the head of the list, and returns a pointer to the stored name. If allocation fails it calls an error routine and never returns; if the username is empty it returns nullptr.",
          "details": [
            "The global pointer data_423360 is the head of a singly-linked list of structures where the first 4 bytes hold a UID and the following bytes hold the username string.",
            "The function traverses the list comparing each node's UID to the argument; on a miss it calls getpwuid(uid) to obtain the passwd entry, calculates the needed allocation size, allocates memory, stores the UID and copies the username with __strcpy_chk, then links the new node into the list.",
            "After insertion (or if the node already existed), it checks if the stored username pointer is nonnull and returns a pointer to the username string; otherwise it returns nullptr."
          ],
          "evidence_refs": [
            "imports:getpwuid",
            "imports:strlen",
            "imports:malloc",
            "imports:__strcpy_chk",
            "call:0x404890",
            "call:0x4048e0",
            "call:0x4046d0",
            "call:0x40e430",
            "strings:D9#u",
            "strings:[A\\A]A^]"
          ],
          "unknowns": [
            "Threadsafety of the linked list operations",
            "Exact structure layout beyond the UID and username fields",
            "Behavior of sub_40e430 (error handling) and whether it terminates the process"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40f580",
      "original_name": "sub_40f580",
      "final_name": "ai_resolve_uid_to_name",
      "score": 40.5,
      "bb_count": 4,
      "insn_est": 35,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404720",
          "name": "ai_safe_snprintf_wrapper",
          "original_name": "__snprintf_chk"
        },
        {
          "addr": "0x40f4c0",
          "name": "ai_user_name_cache_lookup",
          "original_name": "sub_40f4c0"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        }
      ],
      "import_refs": [
        "__snprintf_chk",
        "strlen"
      ],
      "string_refs": [],
      "constants": [
        "0x40f4c0",
        "0x41af55",
        "0x404720",
        "0x4048e0",
        "0x4140a0"
      ],
      "snippets": {
        "asm": "  0x40f580  endbr64 \n  0x40f584  push    rbp {__saved_rbp}\n  0x40f585  cmp     byte [rel data_4232cc], 0x0\n  0x40f58c  mov     rbp, rsp {__saved_rbp}\n  0x40f58f  push    r12 {__saved_r12}\n  0x40f591  push    rbx {__saved_rbx}\n  0x40f592  mov     ebx, edi\n  0x40f594  je      0x40f5c0\n  0x40f5c0  call    sub_40f4c0\n  0x40f5c5  mov     r12, rax\n  0x40f5c8  test    rax, rax\n  0x40f5cb  je      0x40f596\n  0x40f596  mov     r9d, ebx\n  0x40f599  lea     r8, [rel data_41af55]\n  0x40f5a0  pop     rbx {__saved_rbx}\n  0x40f5a1  mov     edx, 0x2\n  0x40f5a6  pop     r12 {__saved_r12}\n  0x40f5a8  mov     rcx, 0xffffffffffffffff\n  0x40f5af  xor     esi, esi  {0x0}\n  0x40f5b1  xor     edi, edi  {0x0}\n  0x40f5b3  xor     eax, eax  {0x0}\n  0x40f5b5  pop     rbp {__saved_rbp}\n  0x40f5b6  jmp     __snprintf_chk\n  0x40f5cd  mov     rdi, rax\n  0x40f5d0  call    strlen\n  0x40f5d5  mov     rdi, r12\n  0x40f5d8  mov     rsi, rax\n  0x40f5db  call    sub_4140a0\n  0x40f5e0  xor     edx, edx\n  0x40f5e2  pop     rbx {__saved_rbx}\n  ... (103 bytes total, truncated)",
        "hlil": "if (data_4232cc == 0)\nchar* rax_3 = sub_40f4c0(arg1)\nif (rax_3 != 0)\nint32_t result = sub_4140a0(rax_3, strlen(rax_3))\nif (result s< 0)\nreturn 0\nreturn result\nreturn __snprintf_chk(nullptr, 0, 2, -1, \"%lu\", zx.q(arg1)) __tailcall",
        "pseudoc": "{\n    if (!data_4232cc)\n    {\n        char* rax_3 = sub_40f4c0(arg1);\n        \n        if (rax_3)\n        {\n            int32_t result = sub_4140a0(rax_3, strlen(rax_3));\n            \n            if (result < 0)\n                return 0;\n            \n            return result;\n        }\n    }\n    \n    /* tailcall */\n    return __snprintf_chk(nullptr, 0, 2, -1, \"%lu\", (uint64_t)arg1);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_resolve_uid_to_name",
          "confidence": 0.78,
          "rationale": "The function maps a numeric UID to a username via getpwuid (sub_40f4c0) and processes it, falling back to formatting the UID as a string with snprintf.",
          "evidence_refs": [
            "imports:__snprintf_chk",
            "imports:strlen",
            "call:0x40f4c0",
            "call:0x4140a0",
            "call:0x404720"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_uid_to_string",
            "ai_get_user_name"
          ]
        },
        "explain": {
          "summary": "sub_40f580 resolves a UID to a username string and processes it, falling back to formatting the UID as a decimal string when no name is available.",
          "details": [
            "If the global flag data_4232cc is false, it calls sub_40f4c0(arg1) to retrieve a cached or system username for the UID.",
            "When a username is obtained, it calls sub_4140a0 with the name and its length; the result of that call is returned unless it is negative.",
            "If the flag is true, the username lookup fails, or sub_4140a0 returns a negative value, the function tailcalls __snprintf_chk with a null buffer to compute the length of the UID formatted as \"%lu\" and returns that length."
          ],
          "evidence_refs": [
            "imports:__snprintf_chk",
            "imports:strlen",
            "call:0x40f4c0",
            "call:0x4140a0",
            "call:0x404720"
          ],
          "unknowns": [
            "Exact semantics of sub_4140a0 (what processing it performs on the username)",
            "Purpose of the global variable data_4232cc",
            "What callers expect beyond the returned length/value"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x40f5f0",
      "original_name": "sub_40f5f0",
      "final_name": "ai_get_group_name_by_gid",
      "score": 79.4,
      "bb_count": 12,
      "insn_est": 53,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404940",
          "name": "ai_get_group_by_gid",
          "original_name": "getgrgid"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404bb0",
          "name": "ai_safe_strcpy",
          "original_name": "__strcpy_chk"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "getgrgid",
        "strlen",
        "malloc",
        "__strcpy_chk"
      ],
      "string_refs": [
        "D9#u",
        "[A\\A]A^]"
      ],
      "constants": [
        "0x423358",
        "0x41af54",
        "0x404940",
        "0x4046d0",
        "0x4048e0",
        "0x40e430",
        "0x404bb0"
      ],
      "snippets": {
        "asm": "  0x40f5f0  endbr64 \n  0x40f5f4  push    rbp {__saved_rbp}\n  0x40f5f5  mov     rbp, rsp {__saved_rbp}\n  0x40f5f8  push    r14 {__saved_r14}\n  0x40f5fa  push    r13 {__saved_r13}\n  0x40f5fc  push    r12 {__saved_r12}\n  0x40f5fe  mov     r12d, edi\n  0x40f601  push    rbx {__saved_rbx}\n  0x40f602  mov     rbx, qword [rel data_423358]\n  0x40f609  test    rbx, rbx\n  0x40f60c  jne     0x40f619\n  0x40f619  cmp     dword [rbx], r12d\n  0x40f61c  jne     0x40f610\n  0x40f60e  jmp     0x40f638\n  0x40f610  mov     rbx, qword [rbx+0x8]\n  0x40f614  test    rbx, rbx\n  0x40f617  je      0x40f638\n  0x40f61e  xor     eax, eax  {0x0}\n  0x40f620  cmp     byte [rbx+0x10], 0x0\n  0x40f624  je      0x40f62a\n  0x40f638  mov     edi, r12d\n  0x40f63b  mov     r13d, 0x18\n  0x40f641  lea     r14, [rel data_41af54]\n  0x40f648  call    getgrgid\n  0x40f64d  test    rax, rax\n  0x40f650  je      0x40f665\n  0x40f62a  pop     rbx {__saved_rbx}\n  0x40f62b  pop     r12 {__saved_r12}\n  0x40f62d  pop     r13 {__saved_r13}\n  0x40f62f  pop     r14 {__saved_r14}\n  ... (172 bytes total, truncated)",
        "hlil": "int32_t* rbx = data_423358\nif (rbx != 0)\nwhile (*rbx != arg1)\nrbx = *(rbx + 8)\nif (rbx == 0)\ngoto label_40f63b\nlabel_40f63b:\nsize_t n = 0x18\nerror_t (* parser)(int32_t, char*, struct argp_state*) = &data_41af54\nstruct group* rax_2 = getgrgid(arg1)\nif (rax_2 != 0)\nparser = rax_2->parser\nn = (strlen(parser) + 0x18) & 0xfffffffffffffff8\nint32_t* rax_4 = malloc(n)\nrbx = rax_4\nif (rax_4 == 0)\nsub_40e430()\nnoreturn\n*rax_4 = arg1\n__strcpy_chk(&rax_4[4], parser, n - 0x10)\nint64_t rax_5 = data_423358\ndata_423358 = rbx\n*(rbx + 8) = rax_5\nif (rbx[4].b == 0)\nreturn nullptr\nreturn &rbx[4]",
        "pseudoc": "{\n    int32_t* rbx = data_423358;\n    \n    if (rbx)\n    {\n        while (*(uint32_t*)rbx != arg1)\n        {\n            rbx = *(uint64_t*)((char*)rbx + 8);\n            \n            if (!rbx)\n                goto label_40f63b;\n        }\n    }\n    else\n    {\n    label_40f63b:\n        size_t n = 0x18;\n        error_t (* parser)(int32_t, char*, struct argp_state*) = &data_41af54;\n        struct group* rax_2 = getgrgid(arg1);\n        \n        if (rax_2)\n        {\n            parser = rax_2->parser;\n            n = (strlen(parser) + 0x18) & 0xfffffffffffffff8;\n        }\n        \n        int32_t* rax_4 = malloc(n);\n        rbx = rax_4;\n        \n        if (!rax_4)\n        {\n            sub_40e430();\n            /* no return */\n        }\n        \n        *(uint32_t*)rax_4 = arg1;\n        __strcpy_chk(&rax_4[4], parser, n - 0x10);\n        int64_t rax_5 = data_423358;\n        data_423358 = rbx;\n        *(uint64_t*)((char*)rbx + 8) = rax_5;\n    }\n    \n    if (!rbx[4])\n        return nullptr;\n    \n    return &rbx[4];\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_group_name_by_gid",
          "confidence": 0.92,
          "rationale": "The function searches a linked list cache for a GID, uses getgrgid to retrieve the group entry, allocates memory, stores the GID and group name, and returns a pointer to the cached name. It implements a GID-to-group-name lookup with caching.",
          "evidence_refs": [
            "imports:getgrgid",
            "imports:malloc",
            "imports:strlen",
            "imports:__strcpy_chk"
          ],
          "tags": [],
          "alt_names": [
            "ai_gid_to_group_name",
            "ai_group_name_cache"
          ]
        },
        "explain": {
          "summary": "The function implements a simple cache for POSIX group names. It searches a linked list for an entry matching the supplied GID, and if not found it queries getgrgid, allocates a new entry, stores the GID and the group name string, inserts it into the list, and returns a pointer to the cached name.",
          "details": [
            "Iterates a global linked list (data_423358) comparing stored GIDs to the argument; if a match is found the cached name is returned.",
            "When no entry exists, calls getgrgid(arg1) to retrieve the group struct, extracts the group name, allocates memory sized to the name plus overhead, stores the GID and copies the name, then prepends the new node to the list.",
            "If getgrgid fails, a default string (data_41af54) is used; allocation failures trigger sub_40e430 (likely an error handler).",
            "The function returns a pointer to the stored name string (offset 16 in the allocated struct) or nullptr if the name is empty."
          ],
          "evidence_refs": [
            "imports:getgrgid",
            "imports:strlen",
            "imports:malloc",
            "imports:__strcpy_chk",
            "call:0x404940",
            "call:0x4048e0",
            "call:0x4046d0",
            "call:0x40e430",
            "strings:D9#u",
            "strings:[A\\A]A^]"
          ],
          "unknowns": [
            "Exact layout of the allocated struct beyond the observed fields",
            "Purpose of the default string referenced by data_41af54",
            "What sub_40e430 does on allocation failure"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x40f6b0",
      "original_name": "sub_40f6b0",
      "final_name": "ai_format_file_mode_string",
      "score": 417.0,
      "bb_count": 138,
      "insn_est": 847,
      "callers": 0,
      "callees": [
        {
          "addr": "0x4248f8"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x40cb80",
          "name": "ai_locale_number_format",
          "original_name": "sub_40cb80"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x40ecd0",
          "name": "ai_dispatch_operation",
          "original_name": "sub_40ecd0"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x40ecd0",
          "name": "ai_dispatch_operation",
          "original_name": "sub_40ecd0"
        },
        {
          "addr": "0x40bd80",
          "name": "ai_map_status_code",
          "original_name": "sub_40bd80"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x40af90",
          "name": "ai_print_padded_string",
          "original_name": "sub_40af90"
        },
        {
          "addr": "0x40af90",
          "name": "ai_print_padded_string",
          "original_name": "sub_40af90"
        },
        {
          "addr": "0x40af90",
          "name": "ai_print_padded_string",
          "original_name": "sub_40af90"
        },
        {
          "addr": "0x40af90",
          "name": "ai_print_padded_string",
          "original_name": "sub_40af90"
        },
        {
          "addr": "0x40bd80",
          "name": "ai_map_status_code",
          "original_name": "sub_40bd80"
        },
        {
          "addr": "0x40f5f0",
          "name": "ai_get_group_name_by_gid",
          "original_name": "sub_40f5f0"
        },
        {
          "addr": "0x40f4c0",
          "name": "ai_user_name_cache_lookup",
          "original_name": "sub_40f4c0"
        },
        {
          "addr": "0x40f4c0",
          "name": "ai_user_name_cache_lookup",
          "original_name": "sub_40f4c0"
        },
        {
          "addr": "0x40cb80",
          "name": "ai_locale_number_format",
          "original_name": "sub_40cb80"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x40e390",
          "name": "ai_set_timezone_and_get_localtime",
          "original_name": "sub_40e390"
        },
        {
          "addr": "0x414780",
          "name": "ai_custom_strftime",
          "original_name": "sub_414780"
        },
        {
          "addr": "0x404d60",
          "name": "ai_sprintf_wrapper",
          "original_name": "__sprintf_chk"
        },
        {
          "addr": "0x40e390",
          "name": "ai_set_timezone_and_get_localtime",
          "original_name": "sub_40e390"
        },
        {
          "addr": "0x414780",
          "name": "ai_custom_strftime",
          "original_name": "sub_414780"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        },
        {
          "addr": "0x404840",
          "name": "ai_get_system_time",
          "original_name": "clock_gettime"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__sprintf_chk",
        "__sprintf_chk",
        "strlen",
        "__sprintf_chk",
        "strlen",
        "__sprintf_chk",
        "clock_gettime",
        "__overflow",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "?pcdb-lswd",
        "%s %*s ",
        "%*s, %*s ",
        " -> "
      ],
      "constants": [
        "0x1000",
        "0x338",
        "0x419648",
        "0x3f3f",
        "0xffffffffffffed6d",
        "0xffffffffffffed6f",
        "0xffffffffffffed64",
        "0x3f3f3f3f3f3f3f3f",
        "0xffffffffffffed65",
        "0xf000",
        "0x8000",
        "0xffffffffffffed6e",
        "0x100",
        "0xffffffbb",
        "0xffffffb6",
        "0xffffffffffffed66",
        "0x4000",
        "0xffffffe0",
        "0xffffffb5",
        "0x6000",
        "0x4243e4",
        "0xffffffffffffecb0",
        "0xffffffffffffecd0",
        "0xffffffffffffed67",
        "0xffffffffffffed68",
        "0xffffffffffffed69",
        "0x2000",
        "0xfffffffffffff180",
        "0xe3b",
        "0x41af59"
      ],
      "snippets": {
        "asm": "  0x40f6b0  push    rbp {__saved_rbp}\n  0x40f6b1  mov     rbp, rsp {__saved_rbp}\n  0x40f6b4  push    r15 {__saved_r15}\n  0x40f6b6  push    r14 {__saved_r14}\n  0x40f6b8  push    r13 {__saved_r13}\n  0x40f6ba  push    r12 {__saved_r12}\n  0x40f6bc  push    rbx {__saved_rbx}\n  0x40f6bd  sub     rsp, 0x1000\n  0x40f6c4  or      qword [rsp {var_1030_1} {var_1030}], 0x0\n  0x40f6c9  sub     rsp, 0x338\n  0x40f6d0  movzx   edx, byte [rdi+0xb8]\n  0x40f6d7  mov     rax, qword [fs:0x28]\n  0x40f6e0  mov     qword [rbp-0x38 {var_40}], rax\n  0x40f6e4  xor     eax, eax  {0x0}\n  0x40f6e6  mov     r13, rdi\n  0x40f6e9  test    dl, dl\n  0x40f6eb  je      0x40f8a0\n  0x40f8a0  mov     eax, dword [rdi+0xa8]\n  0x40f8a6  lea     rcx, [rel data_419648]  {\"?pcdb-lswd\"}\n  0x40f8ad  mov     r9d, 0x3f3f\n  0x40f8b3  cmp     byte [rel data_4232c8], 0x0\n  0x40f8ba  mov     word [rbp-0x1293 {var_129b}], r9w  {0x3f3f}\n  0x40f8c2  movzx   eax, byte [rcx+rax]\n  0x40f8c6  mov     byte [rbp-0x1291 {var_1299}], 0x0\n  0x40f8cd  mov     byte [rbp-0x129c {var_12a4}], al\n  0x40f8d3  mov     rax, 0x3f3f3f3f3f3f3f3f\n  0x40f8dd  mov     qword [rbp-0x129b {var_12a3}], rax  {0x3f3f3f3f3f3f3f3f}\n  0x40f8e4  jne     0x40f865\n  0x40f6f1  mov     eax, dword [rdi+0x30]\n  0x40f6f4  mov     ecx, 0x2d\n  ... (3728 bytes total, truncated)",
        "hlil": "int64_t var_1030\nint64_t var_1030_1 = var_1030\nchar rdx = arg1[0x17].b\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nchar var_12a4\nint16_t var_129b\nif (rdx != 0)\nint32_t rax_2 = arg1[6].d\nchar rcx_1 = 0x2d\nint32_t rsi_2 = rax_2 & 0xf000\nif (rsi_2 != 0x8000)\nrcx_1 = 0x64\nif (rsi_2 != 0x4000)\nrcx_1 = 0x62\nif (rsi_2 != 0x6000)\nrcx_1 = 0x63\nif (rsi_2 != 0x2000)\nrcx_1 = 0x6c\nif (rsi_2 != 0xa000)\nrcx_1 = 0x70\nif (rsi_2 != 0x1000)\nrcx_1 = 0x73\nif (rsi_2 != 0xc000)\nrcx_1 = 0x3f\nvar_12a4 = rcx_1\nint32_t rcx_3 = rax_2 & 0x100\nint64_t var_12a3\nvar_12a3.b = ((sbb.d(rcx_3, rcx_3, rcx_3 u< 1)).b & 0xbb) + 0x72\nint32_t rcx_8 = rax_2 & 0x80\nvar_12a3:1.b = ((sbb.d(rcx_8, rcx_8, rcx_8 u< 1)).b & 0xb6) + 0x77\nint32_t rcx_13 = rax_2 & 0x40\nchar rcx_14 = (sbb.d(rcx_13, rcx_13, rcx_13 u< 1)).b\nchar rcx_16\nif ((rax_2:1.b & 8) != 0)\nrcx_16 = (rcx_14 & 0xe0) + 0x73\nrcx_16 = (rcx_14 & 0xb5) + 0x78\nvar_12a3:2.b = rcx_16\nint32_t rcx_18 = rax_2 & 0x20\nvar_12a3:3.b = ((sbb.d(rcx_18, rcx_18, rcx_18 u< 1)).b & 0xbb) + 0x72\n// ... truncated",
        "pseudoc": "{\n    int64_t var_1030;\n    int64_t var_1030_1 = var_1030;\n    char rdx = arg1[0x17];\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    char var_12a4;\n    int16_t var_129b;\n    \n    if (rdx)\n    {\n        int32_t rax_2 = arg1[6];\n        char rcx_1 = 0x2d;\n        int32_t rsi_2 = rax_2 & 0xf000;\n        \n        if (rsi_2 != 0x8000)\n        {\n            rcx_1 = 0x64;\n            \n            if (rsi_2 != 0x4000)\n            {\n                rcx_1 = 0x62;\n                \n                if (rsi_2 != 0x6000)\n                {\n                    rcx_1 = 0x63;\n                    \n                    if (rsi_2 != 0x2000)\n                    {\n                        rcx_1 = 0x6c;\n                        \n                        if (rsi_2 != 0xa000)\n                        {\n                            rcx_1 = 0x70;\n                            \n                            if (rsi_2 != 0x1000)\n                            {\n                                rcx_1 = 0x73;\n                                \n                                if (rsi_2 != 0xc000)\n                                    rcx_1 = 0x3f;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        var_12a4 = rcx_1;\n        int32_t rcx_3 = rax_2 & 0x100;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_format_file_mode_string",
          "confidence": 0.78,
          "rationale": "The function maps file type bits to characters like '-', 'd', 'b', 'c', 'l', 'p', 's', '?' and uses sprintf to build formatted output strings such as '%s %*s '. This matches behavior of generating a file permission/type string similar to 'ls -l' output.",
          "evidence_refs": [
            "strings:'?pcdb-lswd'",
            "strings:'%s %*s '",
            "strings:'%*s, %*s '",
            "imports:__sprintf_chk",
            "call:0x404d60"
          ],
          "tags": [
            "file_io",
            "process"
          ],
          "alt_names": [
            "ai_ls_output_formatter",
            "ai_file_permission_string"
          ]
        },
        "explain": {
          "summary": "sub_40f6b0 formats file metadata for display, converting file mode bits into the typical ls -l type character and building a formatted output string using sprintf.",
          "details": [
            "It reads a flag byte (arg1[0x17]) and a mode field (arg1[6]), masking the high-order bits (0xf000) to select a file type character, mapping values like 0x8000 to '-', 0x4000 to 'd', 0x2000 to 'c', 0x6000 to 'b', 0x1000 to 'p', 0xa000 to 'l', 0xc000 to 's', otherwise '?' (evidence: string \"?pcdb-lswd\").",
            "The selected character is stored in var_12a4 and later used in formatted output strings such as \"%s %*s \" and \"%*s, %*s \" via __sprintf_chk calls, likely constructing a columnar listing similar to the Unix \"ls -l\" output."
          ],
          "evidence_refs": [
            "strings:?pcdb-lswd",
            "strings:%s %*s ",
            "strings:%*s, %*s ",
            "imports:__sprintf_chk",
            "call:0x404d60",
            "call:0x4140a0"
          ],
          "unknowns": [
            "Exact handling of the remaining fields (e.g., timestamps, sizes) beyond the file type character",
            "Purpose of the constants like 0x338, 0x419648, and the large negative values"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io",
        "process"
      ]
    },
    {
      "addr": "0x4105e0",
      "original_name": "sub_4105e0",
      "final_name": "ai_jump_table_dispatch",
      "score": 16.3,
      "bb_count": 3,
      "insn_est": 16,
      "callers": 3,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [
        "0x423344",
        "0x419180"
      ],
      "snippets": {
        "asm": "  0x4105e0  cmp     dword [rel data_423344], 0x4\n  0x4105e7  ja      0x410a10\n  0x410a10  retn     {__return_addr}\n  0x4105ed  push    rbp {var_8}\n  0x4105ee  lea     rdx, [rel jump_table_419180]\n  0x4105f5  mov     rbp, rsp\n  0x4105f8  push    r15 {var_10}\n  0x4105fa  push    r14 {var_18}\n  0x4105fc  push    r13 {var_20}\n  0x4105fe  push    r12 {var_28}\n  0x410600  push    rbx {var_30}\n  0x410601  sub     rsp, 0x38\n  0x410605  mov     eax, dword [rel data_423344]\n  0x41060b  movsxd  rax, dword [rdx+rax*4]\n  0x41060f  add     rax, rdx\n  0x410612  jmp     rax\n  0x410618  {Case 0x3}\n  0x410618  cmp     qword [rel data_423478], 0x0\n  0x410620  je      0x410980\n  0x410720  {Case 0x4}\n  0x410720  mov     edi, 0x2c\n  0x410740  {Case 0x0}\n  0x410740  cmp     qword [rel data_423318], 0x0\n  0x410748  je      0x41096e\n  0x4107f8  {Case 0x1}\n  0x4107f8  cmp     qword [rel data_423318], 0x0\n  0x410800  je      0x41096e\n  0x410868  {Case 0x2}\n  0x410868  cmp     qword [rel data_423478], 0x0\n  0x410870  je      0x410980\n  ... (1018 bytes total, truncated)",
        "hlil": "if (data_423344 u> 4)\nreturn \nint64_t rbp\nint64_t var_8 = rbp\nint64_t r15\nint64_t var_10 = r15\nint64_t r14\nint64_t var_18 = r14\nint64_t r13\nint64_t var_20 = r13\nint64_t r12\nint64_t var_28 = r12\nint64_t rbx\nint64_t var_30 = rbx\njump(sx.q(jump_table_419180[zx.q(data_423344)]) + &jump_table_419180)",
        "pseudoc": "{\n    if (data_423344 > 4)\n        return;\n    \n    int64_t rbp;\n    int64_t var_8 = rbp;\n    int64_t r15;\n    int64_t var_10 = r15;\n    int64_t r14;\n    int64_t var_18 = r14;\n    int64_t r13;\n    int64_t var_20 = r13;\n    int64_t r12;\n    int64_t var_28 = r12;\n    int64_t rbx;\n    int64_t var_30 = rbx;\n    /* jump -> (int64_t)jump_table_419180[(uint64_t)data_423344] + &jump_table_419180 */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_jump_table_dispatch",
          "confidence": 0.78,
          "rationale": "The function checks a global index (data_423344) and jumps to a handler via a jump table (jump_table_419180), indicating a dispatcher or switch-case implementation.",
          "evidence_refs": [
            "constants:0x423344",
            "constants:0x419180"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_dispatcher",
            "ai_switch_handler"
          ]
        },
        "explain": {
          "summary": "sub_4105e0 is a simple dispatcher that checks a global index (data_423344) and, if within the range 0-4, jumps to a corresponding entry in a jump table located at 0x419180.",
          "details": [
            "The function first verifies that data_423344 is not greater than 4; otherwise it returns immediately.",
            "It then prepares stack space for saved registers and performs an indirect jump using the value of data_423344 as an index into jump_table_419180."
          ],
          "evidence_refs": [
            "constants:0x423344",
            "constants:0x419180",
            "call:0x419180"
          ],
          "unknowns": [
            "The specific actions performed by each jump-table target.",
            "The overall purpose of the dispatcher within the larger program."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x410a20",
      "original_name": "sub_410a20",
      "final_name": "ai_safe_buffer_resize",
      "score": 75.3,
      "bb_count": 21,
      "insn_est": 81,
      "callers": 3,
      "callees": [
        {
          "addr": "0x404ba0",
          "name": "ai_memory_realloc_wrapper",
          "original_name": "realloc"
        },
        {
          "addr": "0x404ba0",
          "name": "ai_memory_realloc_wrapper",
          "original_name": "realloc"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "realloc",
        "realloc"
      ],
      "string_refs": [],
      "constants": [
        "0x7fffffffffffffff",
        "0x404ba0",
        "0x40e430"
      ],
      "snippets": {
        "asm": "  0x410a20  endbr64 \n  0x410a24  push    rbp {__saved_rbp}\n  0x410a25  mov     r9, rdx\n  0x410a28  mov     rbp, rsp {__saved_rbp}\n  0x410a2b  push    r14 {__saved_r14}\n  0x410a2d  mov     r14, rdi\n  0x410a30  mov     rdi, rcx\n  0x410a33  push    r13 {__saved_r13}\n  0x410a35  mov     r13, rsi\n  0x410a38  push    r12 {__saved_r12}\n  0x410a3a  push    rbx {__saved_rbx}\n  0x410a3b  mov     rcx, qword [rsi]\n  0x410a3e  mov     rbx, rcx\n  0x410a41  sar     rbx, 0x1\n  0x410a44  add     rbx, rcx\n  0x410a47  jo      0x410b09\n  0x410b09  mov     rbx, 0x7fffffffffffffff\n  0x410b13  jmp     0x410a4d\n  0x410a4d  cmp     rbx, rdi\n  0x410a50  mov     rax, rdi\n  0x410a53  cmovle  rax, rbx\n  0x410a57  cmp     rdi, 0xffffffffffffffff\n  0x410a5b  cmovne  rbx, rax\n  0x410a5f  mov     rsi, rbx\n  0x410a62  imul    rsi, r8\n  0x410a66  jo      0x410afd\n  0x410afd  mov     rsi, 0x7fffffffffffffff\n  0x410b07  jmp     0x410ac5\n  0x410a6c  cmp     rsi, 0x7f\n  0x410a70  jle     0x410ac0\n  ... (255 bytes total, truncated)",
        "hlil": "int64_t rcx = *arg2\nint64_t rbx_1 = rcx s>> 1\nint64_t rbx_2 = rbx_1 + rcx\nif (add_overflow(rbx_1, rcx))\nrbx_2 = 0x7fffffffffffffff\nint64_t rax = arg4\nif (rbx_2 s<= arg4)\nrax = rbx_2\nif (arg4 != -1)\nrbx_2 = rax\nsize_t n_1 = rbx_2 * arg5\nbool o_1 = unimplemented  {imul rsi, r8}\nint64_t rsi_2\nif (o_1)\nrsi_2 = 0x7fffffffffffffff\nlabel_410ac8:\nint64_t rax_4\nint64_t rdx\nrdx:rax_4 = sx.o(rsi_2)\nrbx_2 = divs.dp.q(rdx:rax_4, arg5)\nn_1 = rsi_2 - mods.dp.q(rdx:rax_4, arg5)\nif (arg1 == 0)\nlabel_410adb:\n*arg2 = 0\nif (rbx_2 - rcx s< arg3)\ngoto label_410a82\ngoto label_410aee\nif (n_1 s<= 0x7f)\nrsi_2 = 0x80\ngoto label_410ac8\nif (arg1 == 0)\ngoto label_410adb\nint64_t result\nif (rbx_2 - rcx s>= arg3)\nlabel_410aee:\nresult = realloc(arg1, n_1)\nif (result != 0)\n*arg2 = rbx_2\nreturn result\nlabel_410a82:\n// ... truncated",
        "pseudoc": "{\n    int64_t rcx = *(uint64_t*)arg2;\n    int64_t rbx_1 = rcx >> 1;\n    int64_t rbx_2 = rbx_1 + rcx;\n    \n    if (rbx_1 + rcx)\n        rbx_2 = 0x7fffffffffffffff;\n    \n    int64_t rax = arg4;\n    \n    if (rbx_2 <= arg4)\n        rax = rbx_2;\n    \n    if (arg4 != -1)\n        rbx_2 = rax;\n    \n    size_t n_1 = rbx_2 * arg5;\n    bool o_1 = /* bool o_1 = unimplemented  {imul rsi, r8} */;\n    int64_t rsi_2;\n    \n    if (o_1)\n    {\n        rsi_2 = 0x7fffffffffffffff;\n    label_410ac8:\n        int64_t rax_4;\n        int64_t rdx;\n        rdx = HIGHQ((int128_t)rsi_2);\n        rax_4 = LOWQ((int128_t)rsi_2);\n        rbx_2 = COMBINE(rdx, rax_4) / arg5;\n        n_1 = rsi_2 - COMBINE(rdx, rax_4) % arg5;\n        \n        if (!arg1)\n        {\n        label_410adb:\n            *(uint64_t*)arg2 = 0;\n            \n            if (rbx_2 - rcx < arg3)\n                goto label_410a82;\n            \n            goto label_410aee;\n        }\n    }\n    else\n    {\n        if (n_1 <= 0x7f)\n        {\n            rsi_2 = 0x80;\n            goto label_410ac8;\n        }\n        \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_safe_buffer_resize",
          "confidence": 0.84,
          "rationale": "The function computes a new allocation size with overflow checks, caps at a maximum, and invokes realloc, indicating it safely resizes a memory buffer.",
          "evidence_refs": [
            "imports:realloc",
            "call:0x404ba0",
            "call:0x40e430"
          ],
          "tags": [],
          "alt_names": [
            "ai_buffer_grow",
            "ai_safe_realloc"
          ]
        },
        "explain": {
          "summary": "sub_410a20 computes a new allocation size for a buffer, applying a growth factor, limiting it by a maximum, rounding to a multiple of the element size, handling overflow, and then invokes realloc to resize the memory. On failure it triggers a memoryexhausted abort routine.",
          "details": [
            "Reads the current allocation size from *arg2, calculates a 1.5 growth (rcx + rcx/2) and caps it at 0x7FFFFFFFFFFFFF on overflow.",
            "Chooses the smaller of the computed growth size and arg4 (unless arg4 is -1) as the target capacity.",
            "Multiplies the target capacity by arg5 (element size), checks for multiplication overflow, and rounds the result up to a whole number of elements.",
            "Updates the stored size in *arg2 when appropriate and calls realloc (import at 0x404ba0) with the new byte count.",
            "If allocation fails, it calls sub_40e430 which prints \"memory exhausted\" and aborts."
          ],
          "evidence_refs": [
            "imports:realloc",
            "call:0x404ba0",
            "call:0x40e430",
            "strings:memory exhausted"
          ],
          "unknowns": [
            "Exact meaning of arg1, arg3, and the conditional branches involving them",
            "Precise handling of the zerosize case and the return value semantics"
          ],
          "confidence": 0.87
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x410b30",
      "original_name": "sub_410b30",
      "final_name": "ai_strdup",
      "score": 40.8,
      "bb_count": 3,
      "insn_est": 21,
      "callers": 7,
      "callees": [
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404aa0",
          "name": "ai_safe_memory_copy",
          "original_name": "__memcpy_chk"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "strlen",
        "malloc",
        "__memcpy_chk"
      ],
      "string_refs": [],
      "constants": [
        "0x4048e0",
        "0x4046d0",
        "0x40e430",
        "0x404aa0"
      ],
      "snippets": {
        "asm": "  0x410b30  endbr64 \n  0x410b34  push    rbp {__saved_rbp}\n  0x410b35  mov     rbp, rsp {__saved_rbp}\n  0x410b38  push    r12 {__saved_r12}\n  0x410b3a  mov     r12, rdi\n  0x410b3d  push    rbx {__saved_rbx}\n  0x410b3e  call    strlen\n  0x410b43  lea     rbx, [rax+0x1]\n  0x410b47  mov     rdi, rbx\n  0x410b4a  call    malloc\n  0x410b4f  test    rax, rax\n  0x410b52  je      0x410b69\n  0x410b69  call    sub_40e430\n  0x410b69  { Does not return }\n  0x410b54  mov     rcx, rbx\n  0x410b57  mov     rdx, rbx\n  0x410b5a  mov     rsi, r12\n  0x410b5d  pop     rbx {__saved_rbx}\n  0x410b5e  mov     rdi, rax\n  0x410b61  pop     r12 {__saved_r12}\n  0x410b63  pop     rbp {__saved_rbp}\n  0x410b64  jmp     __memcpy_chk",
        "hlil": "size_t n = strlen(arg1) + 1\nint64_t rax_1 = malloc(n)\nif (rax_1 != 0)\nreturn __memcpy_chk(rax_1, arg1, n, n) __tailcall\nsub_40e430()\nnoreturn",
        "pseudoc": "{\n    size_t n = strlen(arg1) + 1;\n    int64_t rax_1 = malloc(n);\n    \n    if (rax_1)\n        /* tailcall */\n        return __memcpy_chk(rax_1, arg1, n, n);\n    \n    sub_40e430();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_strdup",
          "confidence": 0.96,
          "rationale": "Allocates memory for a copy of a given string and copies it using memcpy, matching typical strdup behavior.",
          "evidence_refs": [
            "imports:strlen",
            "imports:malloc",
            "imports:__memcpy_chk",
            "call:0x4048e0",
            "call:0x4046d0",
            "call:0x404aa0"
          ],
          "tags": [],
          "alt_names": [
            "ai_string_duplicate",
            "ai_copy_string"
          ]
        },
        "explain": {
          "summary": "sub_410b30 duplicates a nullterminated string by allocating a buffer of the appropriate size and copying the contents, acting like a safe strdup implementation. On allocation failure it invokes an error handler (sub_40e430) and does not return.",
          "details": [
            "Computes the length of the input string with strlen and adds one for the terminating null.",
            "Allocates memory of that size using malloc; if allocation succeeds, copies the string into the new buffer with __memcpy_chk and returns the new pointer.",
            "If malloc returns NULL, calls sub_40e430 (likely a fatal error routine) and does not return."
          ],
          "evidence_refs": [
            "imports:strlen",
            "imports:malloc",
            "imports:__memcpy_chk",
            "call:0x4048e0",
            "call:0x4046d0",
            "call:0x404aa0"
          ],
          "unknowns": [
            "Exact behavior of sub_40e430 (error handling routine) is not detailed."
          ],
          "confidence": 0.96
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x410b70",
      "original_name": "sub_410b70",
      "final_name": "ai_add_list_node",
      "score": 41.6,
      "bb_count": 7,
      "insn_est": 37,
      "callers": 3,
      "callees": [
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x410b30",
          "name": "ai_strdup",
          "original_name": "sub_410b30"
        },
        {
          "addr": "0x410b30",
          "name": "ai_strdup",
          "original_name": "sub_410b30"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "malloc"
      ],
      "string_refs": [],
      "constants": [
        "0x4046d0",
        "0x40e430",
        "0x410b30",
        "0x423720"
      ],
      "snippets": {
        "asm": "  0x410b70  push    rbp {__saved_rbp}\n  0x410b71  mov     rbp, rsp {__saved_rbp}\n  0x410b74  push    r14 {__saved_r14}\n  0x410b76  mov     r14, rsi\n  0x410b79  push    r13 {__saved_r13}\n  0x410b7b  mov     r13d, edx\n  0x410b7e  push    r12 {__saved_r12}\n  0x410b80  mov     r12, rdi\n  0x410b83  mov     edi, 0x20\n  0x410b88  push    rbx {__saved_rbx}\n  0x410b89  call    malloc\n  0x410b8e  test    rax, rax\n  0x410b91  je      0x410bdc\n  0x410bdc  call    sub_40e430\n  0x410bdc  { Does not return }\n  0x410b93  mov     rbx, rax\n  0x410b96  test    r14, r14\n  0x410b99  je      0x410ba6\n  0x410ba6  mov     qword [rbx+0x8], r14\n  0x410baa  test    r12, r12\n  0x410bad  je      0x410bba\n  0x410b9b  mov     rdi, r14\n  0x410b9e  call    sub_410b30\n  0x410ba3  mov     r14, rax\n  0x410bba  mov     rax, qword [rel data_423720]\n  0x410bc1  mov     qword [rbx], r12\n  0x410bc4  mov     byte [rbx+0x10], r13b\n  0x410bc8  mov     qword [rbx+0x18], rax\n  0x410bcc  mov     qword [rel data_423720], rbx\n  0x410bd3  pop     rbx {__saved_rbx}\n  ... (113 bytes total, truncated)",
        "hlil": "char* r14 = arg2\nchar* r12 = arg1\nint64_t* rax = malloc(0x20)\nif (rax == 0)\nsub_40e430()\nnoreturn\nif (r14 != 0)\nr14 = sub_410b30(r14)\nrax[1] = r14\nif (r12 != 0)\nr12 = sub_410b30(r12)\nint64_t result = data_423720\n*rax = r12\nrax[2].b = arg3\nrax[3] = result\ndata_423720 = rax\nreturn result",
        "pseudoc": "{\n    char* r14 = arg2;\n    char* r12 = arg1;\n    int64_t* rax = malloc(0x20);\n    \n    if (!rax)\n    {\n        sub_40e430();\n        /* no return */\n    }\n    \n    if (r14)\n        r14 = sub_410b30(r14);\n    \n    rax[1] = r14;\n    \n    if (r12)\n        r12 = sub_410b30(r12);\n    \n    int64_t result = data_423720;\n    *(uint64_t*)rax = r12;\n    rax[2] = arg3;\n    rax[3] = result;\n    data_423720 = rax;\n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_add_list_node",
          "confidence": 0.86,
          "rationale": "Allocates a 32-byte struct, duplicates two input strings, stores a value and links the struct into a global linked list (data_423720), typical of a list node creation/insertion routine.",
          "evidence_refs": [
            "imports:malloc",
            "call:0x410b30",
            "call:0x40e430"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_create_list_entry",
            "ai_push_node"
          ]
        },
        "explain": {
          "summary": "sub_410b70 allocates a 32-byte structure, duplicates optional string arguments, stores a third argument, and inserts the new node at the head of a global linked list. It returns the previous head of the list and aborts on allocation failure via sub_40e430.",
          "details": [
            "Calls malloc (0x4046d0) to allocate memory for a new node; on failure it invokes sub_40e430 which does not return.",
            "If arg2 is nonnull, duplicates it using sub_410b30 (string copy with malloc) and stores the copy in the node's second field.",
            "If arg1 is nonnull, duplicates it similarly and stores the copy in the node's first field.",
            "Stores arg3 in the node's third field and the previous global list head (data_423720) in the fourth field, then updates data_423720 to point to the new node.",
            "Returns the previous head of the list (the value of data_423720 before update)."
          ],
          "evidence_refs": [
            "imports:malloc",
            "call:0x4046d0",
            "call:0x410b30",
            "call:0x40e430"
          ],
          "unknowns": [
            "Exact purpose of arg3 and the semantics of the stored fields",
            "The structure layout beyond the observed fields",
            "Behavior of sub_40e430 (error handling routine)"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x410bf0",
      "original_name": "sub_410bf0",
      "final_name": "ai_process_config_entries",
      "score": 251.7,
      "bb_count": 59,
      "insn_est": 244,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x410b30",
          "name": "ai_strdup",
          "original_name": "sub_410b30"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404740",
          "name": "ai_safe_memcpy",
          "original_name": "__mempcpy_chk"
        },
        {
          "addr": "0x404c10",
          "name": "ai_memcpy_wrapper",
          "original_name": "mempcpy"
        },
        {
          "addr": "0x410b70",
          "name": "ai_add_list_node",
          "original_name": "sub_410b70"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x410b70",
          "name": "ai_add_list_node",
          "original_name": "sub_410b70"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404920",
          "name": "ai_free_security_context",
          "original_name": "freecon"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "malloc",
        "strlen",
        "strlen",
        "malloc",
        "__mempcpy_chk",
        "mempcpy",
        "free",
        "free",
        "free",
        "free",
        "freecon",
        "strlen"
      ],
      "string_refs": [],
      "constants": [
        "0x423318",
        "0x4236f8",
        "0x4046d0",
        "0x40e430",
        "0x410b30",
        "0x423720",
        "0x423450",
        "0x410b70",
        "0x4046b0",
        "0x423024",
        "0x404920",
        "0x4048e0",
        "0x404740",
        "0x404c10"
      ],
      "snippets": {
        "asm": "  0x410bf0  push    rbp {__saved_rbp}\n  0x410bf1  mov     rbp, rsp {__saved_rbp}\n  0x410bf4  push    r15 {__saved_r15}\n  0x410bf6  push    r14 {__saved_r14}\n  0x410bf8  push    r13 {__saved_r13}\n  0x410bfa  push    r12 {__saved_r12}\n  0x410bfc  mov     r12, rdi\n  0x410bff  push    rbx {__saved_rbx}\n  0x410c00  sub     rsp, 0x38\n  0x410c04  mov     byte [rbp-0x39 {var_41}], sil\n  0x410c08  test    rdi, rdi\n  0x410c0b  je      0x410c56\n  0x410c56  mov     rax, qword [rel data_423318]\n  0x410c5d  movzx   ebx, byte [rbp-0x39 {var_41}]\n  0x410c61  lea     r14, [rax-0x1]\n  0x410c65  mov     dword [rbp-0x40 {var_48_1}], ebx\n  0x410c68  test    rax, rax\n  0x410c6b  je      0x410fac\n  0x410c0d  cmp     qword [rel data_4236f8], 0x0\n  0x410c15  je      0x410c56\n  0x410fac  xor     edx, edx  {0x0}\n  0x410fae  jmp     0x410ea8\n  0x410c71  nop     dword [rax]\n  0x410c17  mov     edi, 0x20\n  0x410c1c  call    malloc\n  0x410c21  mov     rbx, rax\n  0x410c24  test    rax, rax\n  0x410c27  je      0x410fb3\n  0x410ea8  mov     qword [rel data_423318], rdx\n  0x410eaf  add     rsp, 0x38\n  ... (939 bytes total, truncated)",
        "hlil": "char* rdx\nif (arg1 != 0 && data_4236f8 != 0)\nint64_t* rax_1 = malloc(0x20)\nif (rax_1 == 0)\nlabel_410fb3:\nsub_40e430()\nnoreturn\nint64_t rax_2\nrax_2, rdx = sub_410b30(arg1)\n*rax_1 = 0\nrax_1[1] = rax_2\nrax_1[2].b = 0\nrax_1[3] = data_423720\ndata_423720 = rax_1\nuint64_t i_2 = data_423318\nint64_t r14_1 = i_2 - 1\nint64_t rdx_7\nif (i_2 == 0)\nrdx_7 = 0\nwhile (true)\nint64_t* r15_1 = *(data_423450 + (r14_1 << 3))\nint32_t rbx_3 = r15_1[0x15].d\nrdx.b = rbx_3 == 3\ni_2.b = rbx_3 == 9\nchar rdi_1 = rdx.b | i_2.b\nif (rdi_1 != 0)\nchar* r13_1 = *r15_1\nif (arg1 == 0)\nlabel_410eca:\ni_2, rdx = sub_410b70(r13_1, r15_1[1], arg2)\nif (rbx_3 == 9)\nlabel_410edb:\nfree(*r15_1)\nfree(r15_1[1])\nfree(r15_1[2])\nint64_t rdi_15 = r15_1[0x16]\ni_2 = &data_423024\nif (rdi_15 != &data_423024)\ni_2, rdx = freecon(rdi_15)\nint64_t temp1_1 = r14_1\n// ... truncated",
        "pseudoc": "{\n    char* rdx;\n    \n    if (arg1 && data_4236f8)\n    {\n        int64_t* rax_1 = malloc(0x20);\n        \n        if (!rax_1)\n        {\n        label_410fb3:\n            sub_40e430();\n            /* no return */\n        }\n        \n        int64_t rax_2;\n        rax_2 = sub_410b30(arg1);\n        *(uint64_t*)rax_1 = 0;\n        rax_1[1] = rax_2;\n        rax_1[2] = 0;\n        rax_1[3] = data_423720;\n        data_423720 = rax_1;\n    }\n    \n    uint64_t i_2 = data_423318;\n    int64_t r14_1 = i_2 - 1;\n    int64_t rdx_7;\n    \n    if (!i_2)\n        rdx_7 = 0;\n    else\n    {\n        while (true)\n        {\n            int64_t* r15_1 = *(uint64_t*)(data_423450 + (r14_1 << 3));\n            int32_t rbx_3 = r15_1[0x15];\n            (uint8_t)rdx = rbx_3 == 3;\n            (uint8_t)i_2 = rbx_3 == 9;\n            char rdi_1 = (uint8_t)rdx | (uint8_t)i_2;\n            \n            if (rdi_1)\n            {\n                char* r13_1 = *(uint64_t*)r15_1;\n                \n                if (!arg1)\n                {\n                label_410eca:\n                    i_2 = sub_410b70(r13_1, r15_1[1], arg2);\n                    \n                    if (rbx_3 == 9)\n                    {\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_process_config_entries",
          "confidence": 0.78,
          "rationale": "The function allocates a node, links it into a global list, then iterates over a collection of entries checking type fields (3 or 9) and dispatches handling via sub_410b70. This pattern matches processing of configuration or queued items.",
          "evidence_refs": [
            "imports:malloc",
            "imports:free",
            "call:0x410b30",
            "call:0x410b70"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_handle_config_items",
            "ai_dispatch_queue"
          ]
        },
        "explain": {
          "summary": "sub_410bf0 registers a new string entry in a global linked list when a nonnull argument is provided, then iterates over a global array of structures performing actions on entries of type 3 or 9. It allocates memory for the new node, copies the input string, links it into data_423720, and for each matching entry calls sub_410b70 with stored pointers. The routine appears to manage a collection of configuration or filerelated objects.",
          "details": [
            "If arg1 is nonnull and data_4236f8 is set, the function allocates a 0x20byte node, copies arg1 via sub_410b30, stores the copy and a pointer to data_423720, and updates the global head data_423720.",
            "It then walks a global array (data_423450) indexed by data_423318, checking each entry's field at offset 0x15 for values 3 or 9, and for those entries invokes sub_410b70 with the entry's string pointer and a second field, passing arg2 as a parameter.",
            "Memory allocation failures trigger a call to sub_40e430 (likely an error/exit routine).",
            "The function uses standard C library functions malloc, strlen, __mempcpy_chk, mempcpy, and free, indicating dynamic string handling."
          ],
          "evidence_refs": [
            "imports:malloc",
            "imports:strlen",
            "imports:__mempcpy_chk",
            "imports:mempcpy",
            "imports:free",
            "call:0x410b30",
            "call:0x410b70",
            "call:0x40e430"
          ],
          "unknowns": [
            "Exact semantics of the structures referenced by data_423450 and the meaning of the type codes 3 and 9",
            "Purpose of sub_410b70 and how its result influences later processing",
            "The overall higherlevel functionality of this routine within the application"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x410fc0",
      "original_name": "sub_410fc0",
      "final_name": "ai_directory_traversal",
      "score": 399.9,
      "bb_count": 77,
      "insn_est": 398,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404880",
          "name": "ai_open_directory",
          "original_name": "opendir"
        },
        {
          "addr": "0x404a80",
          "name": "ai_get_dir_fd",
          "original_name": "dirfd"
        },
        {
          "addr": "0x40b9e0",
          "name": "ai_collect_file_metadata",
          "original_name": "sub_40b9e0"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x40c940",
          "name": "ai_safe_malloc",
          "original_name": "sub_40c940"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x414030",
          "name": "ai_init_dynamic_array",
          "original_name": "sub_414030"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x404a00",
          "name": "ai_close_directory",
          "original_name": "closedir"
        },
        {
          "addr": "0x409f10",
          "name": "ai_cleanup_global_structs",
          "original_name": "sub_409f10"
        },
        {
          "addr": "0x40e910",
          "name": "ai_print_entry",
          "original_name": "sub_40e910"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x404b20",
          "name": "ai_read_directory_entry",
          "original_name": "readdir"
        },
        {
          "addr": "0x4049b0",
          "name": "ai_fnmatch_wrapper",
          "original_name": "fnmatch"
        },
        {
          "addr": "0x40bf40",
          "name": "ai_signal_suspension_loop",
          "original_name": "sub_40bf40"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x404a00",
          "name": "ai_close_directory",
          "original_name": "closedir"
        },
        {
          "addr": "0x40e4b0",
          "name": "ai_resize_sort_file_buffer",
          "original_name": "sub_40e4b0"
        },
        {
          "addr": "0x40cb80",
          "name": "ai_locale_number_format",
          "original_name": "sub_40cb80"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x4105e0",
          "name": "ai_jump_table_dispatch",
          "original_name": "sub_4105e0"
        },
        {
          "addr": "0x4049b0",
          "name": "ai_fnmatch_wrapper",
          "original_name": "fnmatch"
        },
        {
          "addr": "0x417490",
          "name": "ai_collect_file_acl_info",
          "original_name": "sub_417490"
        },
        {
          "addr": "0x40bf40",
          "name": "ai_signal_suspension_loop",
          "original_name": "sub_40bf40"
        },
        {
          "addr": "0x40e4b0",
          "name": "ai_resize_sort_file_buffer",
          "original_name": "sub_40e4b0"
        },
        {
          "addr": "0x4105e0",
          "name": "ai_jump_table_dispatch",
          "original_name": "sub_4105e0"
        },
        {
          "addr": "0x409f10",
          "name": "ai_cleanup_global_structs",
          "original_name": "sub_409f10"
        },
        {
          "addr": "0x40b9e0",
          "name": "ai_collect_file_metadata",
          "original_name": "sub_40b9e0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x404a00",
          "name": "ai_close_directory",
          "original_name": "closedir"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x40e4b0",
          "name": "ai_resize_sort_file_buffer",
          "original_name": "sub_40e4b0"
        },
        {
          "addr": "0x410bf0",
          "name": "ai_process_config_entries",
          "original_name": "sub_410bf0"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x416b20",
          "name": "ai_resolve_path",
          "original_name": "sub_416b20"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x408170",
          "name": "ai_write_stdout",
          "original_name": "sub_408170"
        },
        {
          "addr": "0x40dca0",
          "name": "ai_memory_chunk_allocate",
          "original_name": "_obstack_newchunk"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "__errno_location",
        "opendir",
        "dirfd",
        "malloc",
        "free",
        "dcgettext",
        "error",
        "closedir",
        "free",
        "readdir",
        "fnmatch",
        "dcgettext",
        "closedir",
        "strlen",
        "dcgettext",
        "strlen",
        "fnmatch",
        "dcgettext",
        "closedir",
        "dcgettext",
        "dcgettext",
        "__overflow",
        "__stack_chk_fail",
        "dcgettext"
      ],
      "string_refs": [
        "cannot open directory %s",
        "error canonicalizing %s",
        "reading directory %s",
        "closing directory %s",
        "total",
        "cannot determine device and inode of %s",
        "%s: not listing already-listed directory"
      ],
      "constants": [
        "0x2e8",
        "0xfffffffffffffd18",
        "0xfffffffffffffcfc",
        "0x404760",
        "0x404880",
        "0x41af75",
        "0x4048c0",
        "0x4236f8",
        "0x4048f0",
        "0x40bc10",
        "0x409f10",
        "0x423700",
        "0x404a80",
        "0xfffffffffffffd30",
        "0x100",
        "0x423728",
        "0x423026",
        "0xffffff9c",
        "0x40b9e0",
        "0x1000",
        "0x41af54",
        "0xfffffffffffffd10",
        "0xfffffffffffffd00",
        "0x422fa8",
        "0x423350",
        "0x4046d0",
        "0x41d558",
        "0x42348c",
        "0x404960",
        "0x41af63"
      ],
      "snippets": {
        "asm": "  0x410fc0  push    rbp {__saved_rbp}\n  0x410fc1  mov     rbp, rsp {__saved_rbp}\n  0x410fc4  push    r15 {__saved_r15}\n  0x410fc6  mov     r15d, edx\n  0x410fc9  push    r14 {__saved_r14}\n  0x410fcb  mov     r14, rdi\n  0x410fce  push    r13 {__saved_r13}\n  0x410fd0  push    r12 {__saved_r12}\n  0x410fd2  push    rbx {__saved_rbx}\n  0x410fd3  mov     rbx, rsi\n  0x410fd6  sub     rsp, 0x2e8\n  0x410fdd  mov     qword [rbp-0x2e8 {var_2f0}], rdi\n  0x410fe4  mov     dword [rbp-0x304 {var_30c}], edx\n  0x410fea  mov     rax, qword [fs:0x28]\n  0x410ff3  mov     qword [rbp-0x38 {var_40}], rax\n  0x410ff7  xor     eax, eax  {0x0}\n  0x410ff9  call    __errno_location\n  0x410ffe  mov     rdi, r14\n  0x411001  mov     dword [rax], 0x0\n  0x411007  mov     r13, rax\n  0x41100a  call    opendir\n  0x41100f  test    rax, rax\n  0x411012  je      0x4116a7\n  0x4116a7  lea     rsi, [rel data_41af75]  {\"cannot open directory %s\"}\n  0x4116ae  mov     edx, 0x5\n  0x4116b3  xor     edi, edi  {0x0}\n  0x4116b5  call    dcgettext\n  0x4116ba  mov     rsi, rax\n  0x4116bd  mov     rax, qword [rbp-0x38 {var_40}]\n  0x4116c1  sub     rax, qword [fs:0x28]\n  ... (1803 bytes total, truncated)",
        "hlil": "int64_t rbx = arg2\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nint32_t* rax_2 = __errno_location()\n*rax_2 = 0\nDIR* dirp = opendir(arg1)\nif (dirp == 0)\nchar* rax_44 = dcgettext(nullptr, \"cannot open directory %s\", 5)\n*(fsbase + 0x28)\nif (rax == *(fsbase + 0x28))\nreturn sub_40bc10(arg3, rax_44, arg1) __tailcall\nint64_t* r12_1 = data_4236f8\nint32_t var_2d8[0x29][0x4]\nif (r12_1 == 0)\nlabel_41115a:\nsub_409f10()\nif (data_423700 != 0)\nif (data_423026 != 0)\ngoto label_411179\nlabel_4115bb:\ndata_423350 += 1\nFILE* f = *stdout\nchar* _IO_write_ptr = f->_IO_write_ptr\nif (_IO_write_ptr u< f->_IO_write_end)\nbool cond:1_1 = data_423678 == 0\ndata_423026 = 0\nf->_IO_write_ptr = &_IO_write_ptr[1]\n*_IO_write_ptr = 0xa\nif (cond:1_1)\ngoto label_41118d\ngoto label_4115ff\n__overflow(f, 0xa)\nlabel_411179:\nbool cond:0_1 = data_423678 != 0\ndata_423026 = 0\nchar* r12_2\nif (cond:0_1)\nlabel_4115ff:\nr12_2 = nullptr\nsub_408170(&data_41af63, 2)\n// ... truncated",
        "pseudoc": "{\n    int64_t rbx = arg2;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int32_t* rax_2 = __errno_location();\n    *(uint32_t*)rax_2 = 0;\n    DIR* dirp = opendir(arg1);\n    \n    if (!dirp)\n    {\n        char* rax_44 = dcgettext(nullptr, \"cannot open directory %s\", 5);\n        *(uint64_t*)((char*)fsbase + 0x28);\n        \n        if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n            /* tailcall */\n            return sub_40bc10(arg3, rax_44, arg1);\n    }\n    else\n    {\n        int64_t* r12_1 = data_4236f8;\n        int32_t var_2d8[0x29][0x4];\n        \n        if (!r12_1)\n        {\n        label_41115a:\n            sub_409f10();\n            \n            if (data_423700)\n            {\n                if (data_423026)\n                    goto label_411179;\n                \n            label_4115bb:\n                data_423350 += 1;\n                FILE* f = *(uint64_t*)stdout;\n                char* _IO_write_ptr = f->_IO_write_ptr;\n                \n                if (_IO_write_ptr < f->_IO_write_end)\n                {\n                    bool cond:1_1 = !data_423678;\n                    data_423026 = 0;\n                    f->_IO_write_ptr = &_IO_write_ptr[1];\n                    *(uint8_t*)_IO_write_ptr = 0xa;\n                    \n                    if (cond:1_1)\n                        goto label_41118d;\n                    \n                    goto label_4115ff;\n                }\n                \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_directory_traversal",
          "confidence": 0.78,
          "rationale": "The function opens a directory, iterates entries with readdir, handles errors like 'cannot open directory', prints totals, and tracks visited directories, indicating it performs directory listing/traversal.",
          "evidence_refs": [
            "strings:cannot open directory %s",
            "strings:reading directory %s",
            "strings:total",
            "imports:opendir",
            "imports:readdir",
            "imports:closedir",
            "imports:dirfd",
            "call:0x404760",
            "call:0x404880"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_dir_traverse",
            "ai_list_directory"
          ]
        },
        "explain": {
          "summary": "sub_410fc0 opens a directory, reports errors if it cannot be opened, then iterates over its entries while tracking visited directories to avoid duplicate processing. It prints status messages such as \"reading directory\" and \"total\", and updates counters before closing the directory. The function uses standard POSIX directory APIs and localized error messages.",
          "details": [
            "Calls opendir on the provided path and checks for a NULL return; on failure it uses dcgettext to fetch a localized error string and forwards it to sub_40bc10 for reporting.",
            "If the directory opens successfully, it accesses global data structures (e.g., data_4236f8) to manage state, reads entries with readdir, and may recursively process subdirectories while avoiding already-listed directories using device/inode checks.",
            "Writes output to stdout, including newline handling and a \"total\" line, and updates counters such as data_423350.",
            "Closes the directory with closedir and cleans up allocated resources via free."
          ],
          "evidence_refs": [
            "strings:\"cannot open directory %s\"",
            "strings:\"reading directory %s\"",
            "strings:\"total\"",
            "imports:opendir",
            "imports:readdir",
            "imports:closedir",
            "imports:dcgettext",
            "call:0x40bc10",
            "call:0x409f10"
          ],
          "unknowns": [
            "Exact logic for handling symbolic links and device/inode comparison",
            "Precise structure and purpose of the global data variables (e.g., data_4236f8, data_423350)",
            "Full recursion depth and termination conditions"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x411700",
      "original_name": "sub_411700",
      "final_name": "ai_utf8_to_utf32_wrapper",
      "score": 41.6,
      "bb_count": 10,
      "insn_est": 42,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4049f0",
          "name": "ai_mbrtoc32_wrapper",
          "original_name": "mbrtoc32"
        },
        {
          "addr": "0x40c6a0",
          "name": "ai_check_posix_locale",
          "original_name": "sub_40c6a0"
        }
      ],
      "import_refs": [
        "mbrtoc32"
      ],
      "string_refs": [],
      "constants": [
        "0x41af54",
        "0x4049f0",
        "0x40c6a0"
      ],
      "snippets": {
        "asm": "  0x411700  push    rbp {__saved_rbp}\n  0x411701  mov     rbp, rsp {__saved_rbp}\n  0x411704  push    r14 {__saved_r14}\n  0x411706  push    r13 {__saved_r13}\n  0x411708  push    r12 {__saved_r12}\n  0x41170a  push    rbx {__saved_rbx}\n  0x41170b  test    rsi, rsi\n  0x41170e  je      0x411770\n  0x411770  xor     r13d, r13d  {0x0}\n  0x411773  mov     r14d, 0x1\n  0x411779  mov     edx, 0x1\n  0x41177e  lea     rbx, [rel data_41af54]\n  0x411785  jmp     0x41171d\n  0x411710  test    rdx, rdx\n  0x411713  mov     r13, rdi\n  0x411716  mov     rbx, rsi\n  0x411719  setne   r14b\n  0x41171d  mov     rsi, rbx\n  0x411720  mov     rdi, r13\n  0x411723  call    mbrtoc32\n  0x411728  mov     r12, rax\n  0x41172b  cmp     rax, 0xfffffffffffffffd\n  0x41172f  jbe     0x411736\n  0x411736  pop     rbx {__saved_rbx}\n  0x411737  mov     rax, r12\n  0x41173a  pop     r12 {__saved_r12}\n  0x41173c  pop     r13 {__saved_r13}\n  0x41173e  pop     r14 {__saved_r14}\n  0x411740  pop     rbp {__saved_rbp}\n  0x411741  retn     {__return_addr}\n  ... (120 bytes total, truncated)",
        "hlil": "char* s\nuint32_t* pc32\nint64_t r14\nif (arg2 == 0)\npc32 = nullptr\nr14 = 1\narg3 = 1\ns = &data_41af54\npc32 = arg1\ns = arg2\nr14.b = arg3 != 0\nuint64_t result = mbrtoc32(pc32, s, arg3, arg4)\nif (result u> -3 && r14.b != 0 && sub_40c6a0(0) == 0)\nif (pc32 != 0)\n*pc32 = zx.d(*s)\nreturn 1\nreturn result",
        "pseudoc": "{\n    char* s;\n    uint32_t* pc32;\n    int64_t r14;\n    \n    if (!arg2)\n    {\n        pc32 = nullptr;\n        r14 = 1;\n        arg3 = 1;\n        s = &data_41af54;\n    }\n    else\n    {\n        pc32 = arg1;\n        s = arg2;\n        (uint8_t)r14 = arg3;\n    }\n    \n    uint64_t result = mbrtoc32(pc32, s, arg3, arg4);\n    \n    if (result > -3 && (uint8_t)r14 && !sub_40c6a0(0))\n    {\n        if (pc32)\n            *(uint32_t*)pc32 = (uint32_t)*(uint8_t*)s;\n        \n        return 1;\n    }\n    \n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_utf8_to_utf32_wrapper",
          "confidence": 0.78,
          "rationale": "The function wraps the mbrtoc32 conversion, handling null inputs, default values, locale checks via sub_40c6a0, and writes a fallback byte to the output. It essentially performs a safe multibyte-to-UTF-32 character conversion.",
          "evidence_refs": [
            "imports:mbrtoc32",
            "call:0x4049f0",
            "call:0x40c6a0"
          ],
          "tags": [],
          "alt_names": [
            "ai_mbrtoc32_safe",
            "ai_char_conversion"
          ]
        },
        "explain": {
          "summary": "sub_411700 is a wrapper around the C library function mbrtoc32 that converts a multibyte character to a UTF-32 code point. It handles a null input pointer by using a default byte string, checks the conversion result and a locale condition via sub_40c6a0, and on success optionally stores the raw byte as a code point before returning 1; otherwise it returns the mbrtoc32 result.",
          "details": [
            "If arg2 is null, the function uses a default byte (data_41af54) and sets a flag (r14) to indicate a fallback mode.",
            "Calls mbrtoc32(pc32, s, arg3, arg4) to perform the multibyte-to-char32 conversion.",
            "If the conversion result is not an error (result > -3), the fallback flag is set, and sub_40c6a0(0) returns false (likely indicating a nonPOSIX locale), the function writes the first byte of the input to *pc32 when pc32 is nonnull and returns 1.",
            "If any of those conditions fail, the original mbrtoc32 result is returned."
          ],
          "evidence_refs": [
            "imports:mbrtoc32",
            "call:0x4049f0",
            "call:0x40c6a0",
            "strings:data_41af54"
          ],
          "unknowns": [
            "Exact semantics of sub_40c6a0 return value and its locale check",
            "Purpose of arg1, arg3, arg4 beyond being passed to mbrtoc32",
            "Why the function writes only the first byte of s to pc32 in the fallback case"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x411790",
      "original_name": "sub_411790",
      "final_name": "ai_print_version_and_license",
      "score": 372.6,
      "bb_count": 30,
      "insn_est": 352,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x404a90",
          "name": "ai_write_char_to_stream",
          "original_name": "fputc_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x404a90",
          "name": "ai_write_char_to_stream",
          "original_name": "fputc_unlocked"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x404a90",
          "name": "ai_write_char_to_stream",
          "original_name": "fputc_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x404a90",
          "name": "ai_write_char_to_stream",
          "original_name": "fputc_unlocked"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__fprintf_chk",
        "dcgettext",
        "__fprintf_chk",
        "fputc_unlocked",
        "dcgettext",
        "__fprintf_chk",
        "fputc_unlocked",
        "__fprintf_chk",
        "dcgettext",
        "__fprintf_chk",
        "fputc_unlocked",
        "dcgettext",
        "__fprintf_chk",
        "fputc_unlocked",
        "dcgettext",
        "__fprintf_chk",
        "dcgettext",
        "dcgettext",
        "__fprintf_chk",
        "dcgettext",
        "dcgettext",
        "__fprintf_chk",
        "dcgettext",
        "dcgettext",
        "__fprintf_chk",
        "dcgettext",
        "__fprintf_chk",
        "dcgettext",
        "__fprintf_chk",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "GNU coreutils",
        "%s (%s) %s\n",
        "Written by %s.\n",
        "Written by %s and %s.\n",
        "Written by %s, %s, and %s.\n",
        "License GPLv3+: GNU GPL version 3 or later <%s>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n",
        "https://gnu.org/licenses/gpl.html",
        "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n",
        "Written by %s, %s, %s,\nand %s.\n",
        "Written by %s, %s, %s,\n%s, and %s.\n",
        "Written by %s, %s, %s,\n%s, %s, and %s.\n",
        "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n",
        "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n",
        "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n",
        "Copyright %s %d Free Software Foundation, Inc."
      ],
      "constants": [
        "0x168",
        "0xfffffffffffffea8",
        "0xfffffffffffffea0",
        "0xfffffffffffffec0",
        "0xfffffffffffffea4",
        "0xfffffffffffffeb0",
        "0x41ae4e",
        "0x41b4c3",
        "0x404cd0",
        "0x41b4cf",
        "0x4048c0",
        "0x7e7",
        "0x41e140",
        "0x404a90",
        "0x41d8a8",
        "0x41d958",
        "0xffffffffffffff00",
        "0xfffffffffffffef8",
        "0xfffffffffffffed0",
        "0xfffffffffffffec8",
        "0x41d980",
        "0xfffffffffffffe78",
        "0xfffffffffffffe80",
        "0xfffffffffffffef0",
        "0xfffffffffffffe88",
        "0xfffffffffffffee8",
        "0xfffffffffffffe90",
        "0xfffffffffffffee0",
        "0xfffffffffffffe98",
        "0xfffffffffffffed8"
      ],
      "snippets": {
        "asm": "  0x411790  endbr64 \n  0x411794  push    rbp {__saved_rbp}\n  0x411795  mov     r10, rsi\n  0x411798  mov     r11, rcx\n  0x41179b  mov     rbp, rsp {__saved_rbp}\n  0x41179e  push    r15 {__saved_r15}\n  0x4117a0  push    r14 {__saved_r14}\n  0x4117a2  push    r13 {__saved_r13}\n  0x4117a4  push    r12 {__saved_r12}\n  0x4117a6  mov     r12, rdi\n  0x4117a9  push    rbx {__saved_rbx}\n  0x4117aa  sub     rsp, 0x168\n  0x4117b1  mov     qword [rbp-0xc0 {var_c8}], r8\n  0x4117b8  mov     qword [rbp-0xb8 {var_c0}], r9\n  0x4117bf  test    al, al\n  0x4117c1  je      0x4117ec\n  0x4117ec  mov     rax, qword [fs:0x28]\n  0x4117f5  mov     qword [rbp-0xe8 {var_f0}], rax\n  0x4117fc  xor     eax, eax  {0x0}\n  0x4117fe  lea     r9, [rbp-0xe0 {var_e8}]\n  0x411805  lea     rax, [rbp+0x10 {arg_8}]\n  0x411809  xor     edi, edi  {0x0}\n  0x41180b  mov     qword [rbp-0x158 {var_160}], rax {arg_8}\n  0x411812  lea     rcx, [rbp+0x10 {arg_8}]\n  0x411816  xor     r8d, r8d  {0x0}\n  0x411819  xor     ebx, ebx  {0x0}\n  0x41181b  mov     dword [rbp-0x160 {var_168}], 0x20\n  0x411825  mov     edx, 0x20\n  0x41182a  lea     rsi, [rbp-0x140 {var_148}]\n  0x411831  mov     dword [rbp-0x15c {var_164}], 0x30\n  ... (1649 bytes total, truncated)",
        "hlil": "int64_t r8\nint64_t var_c8 = r8\nint64_t r9\nint64_t var_c0 = r9\nif (arg5 != 0)\nint128_t zmm0\nint128_t var_b8_1 = zmm0\nint128_t zmm1\nint128_t var_a8_1 = zmm1\nint128_t zmm2\nint128_t var_98_1 = zmm2\nint128_t zmm3\nint128_t var_88_1 = zmm3\nint128_t zmm4\nint128_t var_78_1 = zmm4\nint128_t zmm5\nint128_t var_68_1 = zmm5\nint128_t zmm6\nint128_t var_58_1 = zmm6\nint128_t zmm7\nint128_t var_48_1 = zmm7\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nchar rdi = 0\nvoid arg_8\nvoid* var_160 = &arg_8\nint64_t* rcx = &arg_8\nchar r8_1 = 0\nint64_t rbx = 0\nint32_t var_168 = 0x20\nint32_t rdx = 0x20\nint32_t var_164 = 0x30\nvoid var_e8\nvoid* var_158 = &var_e8\nwhile (true)\nchar* var_190_1\nint64_t var_188_1\nint64_t var_180_1\nint64_t var_178_1\nint64_t var_170_1\n// ... truncated",
        "pseudoc": "{\n    int64_t r8;\n    int64_t var_c8 = r8;\n    int64_t r9;\n    int64_t var_c0 = r9;\n    \n    if (arg5)\n    {\n        int128_t zmm0;\n        int128_t var_b8_1 = zmm0;\n        int128_t zmm1;\n        int128_t var_a8_1 = zmm1;\n        int128_t zmm2;\n        int128_t var_98_1 = zmm2;\n        int128_t zmm3;\n        int128_t var_88_1 = zmm3;\n        int128_t zmm4;\n        int128_t var_78_1 = zmm4;\n        int128_t zmm5;\n        int128_t var_68_1 = zmm5;\n        int128_t zmm6;\n        int128_t var_58_1 = zmm6;\n        int128_t zmm7;\n        int128_t var_48_1 = zmm7;\n    }\n    \n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    char rdi = 0;\n    void arg_8;\n    void* var_160 = &arg_8;\n    int64_t* rcx = &arg_8;\n    char r8_1 = 0;\n    int64_t rbx = 0;\n    int32_t var_168 = 0x20;\n    int32_t rdx = 0x20;\n    int32_t var_164 = 0x30;\n    void var_e8;\n    void* var_158 = &var_e8;\n    \n    while (true)\n    {\n        char* var_190_1;\n        int64_t var_188_1;\n        int64_t var_180_1;\n        int64_t var_178_1;\n        int64_t var_170_1;\n        int64_t var_148;\n        int64_t var_140;\n        int64_t var_138;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_version_and_license",
          "confidence": 0.78,
          "rationale": "The function references many strings related to GNU coreutils version, author credits, and GPL license text, and uses __fprintf_chk and fputc_unlocked to output formatted text, indicating it prints version/license information.",
          "evidence_refs": [
            "strings:'GNU coreutils'",
            "strings:'License GPLv3+: GNU GPL version 3 or later <%s>.'",
            "imports:__fprintf_chk",
            "imports:fputc_unlocked",
            "imports:dcgettext"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_print_license",
            "ai_print_version"
          ]
        },
        "explain": {
          "summary": "The function prints GNU coreutils version, author, and licensing information, using localized strings and formatted output. It selects appropriate format strings based on the number of authors and writes them to stdout via __fprintf_chk and fputc_unlocked, handling optional arguments to control output.",
          "details": [
            "Loads localized strings such as \"GNU coreutils\" and various \"Written by\" formats, then calls __fprintf_chk (import) to output them.",
            "Uses dcgettext to retrieve translations for the strings before printing, indicating support for internationalization.",
            "Iterates over a list of author name placeholders, selecting the correct format string (e.g., \"%s (%s) %s\\n\") based on the count of authors.",
            "Writes the GPLv3+ license text and URL using fputc_unlocked for line breaks."
          ],
          "evidence_refs": [
            "strings:'GNU coreutils'",
            "strings:'%s (%s) %s\\n'",
            "strings:'Written by %s.\\n'",
            "strings:'License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n'",
            "imports:__fprintf_chk",
            "imports:dcgettext",
            "imports:fputc_unlocked",
            "call:0x404cd0",
            "call:0x4048c0"
          ],
          "unknowns": [
            "Exact conditions under which each author format string is chosen",
            "The role of the ZMM registers and the arg5 flag in the initial block"
          ],
          "confidence": 0.82
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x411e10",
      "original_name": "sub_411e10",
      "final_name": "ai_allocate_and_init_static_struct",
      "score": 40.8,
      "bb_count": 3,
      "insn_est": 26,
      "callers": 4,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        }
      ],
      "import_refs": [
        "__errno_location",
        "malloc"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x4046d0",
        "0x40e430",
        "0x4232e0",
        "0x4232f0",
        "0x423300",
        "0x423310"
      ],
      "snippets": {
        "asm": "  0x411e10  endbr64 \n  0x411e14  push    rbp {__saved_rbp}\n  0x411e15  mov     rbp, rsp {__saved_rbp}\n  0x411e18  push    r12 {__saved_r12}\n  0x411e1a  push    rbx {__saved_rbx}\n  0x411e1b  call    __errno_location\n  0x411e20  mov     edi, 0x38\n  0x411e25  mov     r12d, dword [rax]\n  0x411e28  mov     rbx, rax\n  0x411e2b  call    malloc\n  0x411e30  test    rax, rax\n  0x411e33  je      0x411e6b\n  0x411e6b  call    sub_40e430\n  0x411e6b  { Does not return }\n  0x411e35  movdqa  xmm0, xmmword [rel data_4232e0]\n  0x411e3d  movdqa  xmm1, xmmword [rel data_4232f0]\n  0x411e45  movdqa  xmm2, xmmword [rel data_423300]\n  0x411e4d  mov     rdx, qword [rel data_423310]\n  0x411e54  mov     dword [rbx], r12d\n  0x411e57  movups  xmmword [rax], xmm0\n  0x411e5a  mov     qword [rax+0x30], rdx\n  0x411e5e  movups  xmmword [rax+0x10], xmm1\n  0x411e62  movups  xmmword [rax+0x20], xmm2\n  0x411e66  pop     rbx {__saved_rbx}\n  0x411e67  pop     r12 {__saved_r12}\n  0x411e69  pop     rbp {__saved_rbp}\n  0x411e6a  retn     {__return_addr}",
        "hlil": "int32_t* rax = __errno_location()\nint32_t r12 = *rax\nint128_t* result = malloc(0x38)\nif (result == 0)\nsub_40e430()\nnoreturn\nint128_t zmm0 = data_4232e0\nint128_t zmm1 = data_4232f0\nint128_t zmm2 = data_423300\nint64_t rdx = data_423310\n*rax = r12\n*result = zmm0\nresult[3].q = rdx\nresult[1] = zmm1\nresult[2] = zmm2\nreturn result",
        "pseudoc": "{\n    int32_t* rax = __errno_location();\n    int32_t r12 = *(uint32_t*)rax;\n    int128_t* result = malloc(0x38);\n    \n    if (!result)\n    {\n        sub_40e430();\n        /* no return */\n    }\n    \n    int128_t zmm0 = data_4232e0;\n    int128_t zmm1 = data_4232f0;\n    int128_t zmm2 = data_423300;\n    int64_t rdx = data_423310;\n    *(uint32_t*)rax = r12;\n    *(uint128_t*)result = zmm0;\n    result[3] = rdx;\n    result[1] = zmm1;\n    result[2] = zmm2;\n    return result;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_allocate_and_init_static_struct",
          "confidence": 0.78,
          "rationale": "The function allocates a fixed-size memory block, checks for allocation failure, restores errno, and fills the block with predefined constant data, indicating an initialization of a static configuration/structure.",
          "evidence_refs": [
            "imports:malloc",
            "imports:__errno_location",
            "call:0x40e430"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_init_static_buffer",
            "ai_create_config_struct"
          ]
        },
        "explain": {
          "summary": "The function allocates a 56byte block, preserves the current errno value across the allocation, initializes the block with three static 128bit constants and one static 64bit constant, and returns a pointer to this initialized structure; on allocation failure it prints a memory exhausted error and aborts.",
          "details": [
            "Calls __errno_location to save the current errno value before calling malloc.",
            "Allocates 0x38 (56) bytes; if malloc returns NULL, invokes sub_40e430 which reports a memory exhausted error and aborts.",
            "Copies static data values (data_4232e0, data_4232f0, data_423300, data_423310) into the newly allocated memory in a specific order.",
            "Restores the saved errno value before returning the pointer to the initialized memory."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:malloc",
            "call:0x40e430"
          ],
          "unknowns": [
            "Exact purpose of the static data constants and the structure they initialize",
            "Why errno is saved and restored in this context"
          ],
          "confidence": 0.94
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x411e70",
      "original_name": "sub_411e70",
      "final_name": "ai_match_argument_in_list",
      "score": 60.8,
      "bb_count": 13,
      "insn_est": 66,
      "callers": 4,
      "callees": [
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404770",
          "name": "ai_strncmp_wrapper",
          "original_name": "strncmp"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        }
      ],
      "import_refs": [
        "strlen",
        "strncmp",
        "strlen"
      ],
      "string_refs": [],
      "constants": [
        "0x4048e0",
        "0x404770"
      ],
      "snippets": {
        "asm": "  0x411e70  endbr64 \n  0x411e74  push    rbp {__saved_rbp}\n  0x411e75  mov     rbp, rsp {__saved_rbp}\n  0x411e78  push    r15 {__saved_r15}\n  0x411e7a  push    r14 {__saved_r14}\n  0x411e7c  push    r13 {__saved_r13}\n  0x411e7e  mov     r13, rsi\n  0x411e81  push    r12 {__saved_r12}\n  0x411e83  push    rbx {__saved_rbx}\n  0x411e84  sub     rsp, 0x28\n  0x411e88  mov     qword [rbp-0x38 {var_40}], rdi\n  0x411e8c  mov     qword [rbp-0x48 {var_50}], rdx\n  0x411e90  call    strlen\n  0x411e95  mov     r12, qword [r13]\n  0x411e99  test    r12, r12\n  0x411e9c  je      0x411f4d\n  0x411f4d  mov     r14, 0xffffffffffffffff\n  0x411f54  jmp     0x411f2f\n  0x411ea2  mov     byte [rbp-0x39 {var_41_1}], 0x0\n  0x411ea6  mov     rbx, rax\n  0x411ea9  xor     r15d, r15d  {0x0}\n  0x411eac  mov     r14, 0xffffffffffffffff\n  0x411eb3  jmp     0x411ee1\n  0x411f2f  add     rsp, 0x28\n  0x411f33  mov     rax, r14\n  0x411f36  pop     rbx {__saved_rbx}\n  0x411f37  pop     r12 {__saved_r12}\n  0x411f39  pop     r13 {__saved_r13}\n  0x411f3b  pop     r14 {__saved_r14}\n  0x411f3d  pop     r15 {__saved_r15}\n  ... (220 bytes total, truncated)",
        "hlil": "uint64_t rax = strlen(arg1)\nchar* r12 = *arg2\nif (r12 == 0)\nreturn -1\nchar var_41_1 = 0\nint64_t r15_1 = 0\nint64_t r14 = -1\nwhile (true)\nif (strncmp(r12, arg1, rax) == 0)\nif (rax == strlen(r12))\nreturn r15_1\nif (r14 != -1)\nchar rax_2 = var_41_1\nif (*(arg3 + (r15_1 << 2)) != *(arg3 + (r14 << 2)))\nrax_2 = 1\nvar_41_1 = rax_2\nr14 = r15_1\nr15_1 += 1\nr12 = arg2[r15_1]\nif (r12 == 0)\nbreak\ncontinue\nr15_1 += 1\nr12 = arg2[r15_1]\nif (r12 == 0)\nbreak\nif (var_41_1 != 0)\nreturn -2\nreturn r14",
        "pseudoc": "{\n    uint64_t rax = strlen(arg1);\n    char* r12 = *(uint64_t*)arg2;\n    \n    if (!r12)\n        return -1;\n    \n    char var_41_1 = 0;\n    int64_t r15_1 = 0;\n    int64_t r14 = -1;\n    \n    while (true)\n    {\n        if (!strncmp(r12, arg1, rax))\n        {\n            if (rax == strlen(r12))\n                return r15_1;\n            \n            if (r14 != -1)\n            {\n                char rax_2 = var_41_1;\n                \n                if (*(uint32_t*)(arg3 + (r15_1 << 2)) != *(uint32_t*)(arg3 + (r14 << 2)))\n                    rax_2 = 1;\n                \n                var_41_1 = rax_2;\n            }\n            else\n            {\n                r14 = r15_1;\n                r15_1 += 1;\n                r12 = arg2[r15_1];\n                \n                if (!r12)\n                    break;\n                \n                continue;\n            }\n        }\n        \n        r15_1 += 1;\n        r12 = arg2[r15_1];\n        \n        if (!r12)\n            break;\n    }\n    \n    if (var_41_1)\n        return -2;\n    \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_match_argument_in_list",
          "confidence": 0.88,
          "rationale": "The function iterates over an array of strings, comparing each to a target string using strlen and strncmp, returning the index of a unique match, -1 if not found, or -2 if ambiguous, typical of command-line argument or option lookup.",
          "evidence_refs": [
            "imports:strlen",
            "imports:strncmp",
            "call:0x4048e0",
            "call:0x404770"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_find_option_index",
            "ai_lookup_argument"
          ]
        },
        "explain": {
          "summary": "The function scans a NULLterminated array of strings (arg2) for entries that match the provided key string (arg1). It returns the index of an exact match, -1 if no match is found, and -2 if the key is a prefix of multiple entries that differ in an associated value array (arg3), indicating an ambiguous match.",
          "details": [
            "Computes the length of arg1 with strlen and uses strncmp to compare each candidate string in arg2 against arg1 up to that length.",
            "If a candidate string exactly equals arg1 (same length), the current index is returned immediately.",
            "Tracks the first prefix match (r14) and sets a flag (var_41_1) when a later prefix match has a different associated value in arg3, leading to an ambiguous result (-2).",
            "Returns -1 when the array is empty or no candidate matches the prefix."
          ],
          "evidence_refs": [
            "imports:strlen",
            "imports:strncmp",
            "call:0x4048e0",
            "call:0x404770"
          ],
          "unknowns": [
            "Exact semantics of the arg3 integer array and how its values influence the ambiguousmatch flag.",
            "The remaining code after the truncated section, which may handle additional edge cases or cleanup."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x411f60",
      "original_name": "sub_411f60",
      "final_name": "ai_parse_uintmax",
      "score": 267.3,
      "bb_count": 85,
      "insn_est": 301,
      "callers": 4,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404d50",
          "name": "ai_get_ctype_table",
          "original_name": "__ctype_b_loc"
        },
        {
          "addr": "0x404ae0",
          "name": "ai_str_to_uintmax",
          "original_name": "__isoc23_strtoumax"
        },
        {
          "addr": "0x404930",
          "name": "ai_strchr_wrapper",
          "original_name": "strchr"
        },
        {
          "addr": "0x404930",
          "name": "ai_strchr_wrapper",
          "original_name": "strchr"
        },
        {
          "addr": "0x404930",
          "name": "ai_strchr_wrapper",
          "original_name": "strchr"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__errno_location",
        "__ctype_b_loc",
        "__isoc23_strtoumax",
        "strchr",
        "strchr",
        "strchr",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x404d50",
        "0x404ae0",
        "0x4048f0",
        "0x404930",
        "0x400",
        "0x81440030b945",
        "0x41db48",
        "0x3e8"
      ],
      "snippets": {
        "asm": "  0x411f60  endbr64 \n  0x411f64  push    rbp {__saved_rbp}\n  0x411f65  mov     rbp, rsp {__saved_rbp}\n  0x411f68  push    r15 {__saved_r15}\n  0x411f6a  push    r14 {__saved_r14}\n  0x411f6c  mov     r14, rsi\n  0x411f6f  push    r13 {__saved_r13}\n  0x411f71  mov     r13, rdx\n  0x411f74  push    r12 {__saved_r12}\n  0x411f76  push    rbx {__saved_rbx}\n  0x411f77  mov     rbx, rdi\n  0x411f7a  sub     rsp, 0x28\n  0x411f7e  mov     qword [rbp-0x48 {var_50}], rcx\n  0x411f82  mov     rax, qword [fs:0x28]\n  0x411f8b  mov     qword [rbp-0x38 {var_40}], rax\n  0x411f8f  xor     eax, eax  {0x0}\n  0x411f91  test    rsi, rsi\n  0x411f94  lea     rax, [rbp-0x40 {var_48}]\n  0x411f98  cmove   r14, rax {var_48}\n  0x411f9c  call    __errno_location\n  0x411fa1  mov     dword [rax], 0x0\n  0x411fa7  mov     r12, rax\n  0x411faa  movzx   r15d, byte [rbx]\n  0x411fae  call    __ctype_b_loc\n  0x411fb3  mov     rcx, qword [rax]\n  0x411fb6  movzx   eax, r15b\n  0x411fba  test    byte [rcx+rax*2+0x1], 0x20\n  0x411fbf  je      0x411fda\n  0x411fda  cmp     r15b, 0x2d\n  0x411fde  je      0x41204a\n  ... (1171 bytes total, truncated)",
        "hlil": "int64_t* r14 = arg2\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nvoid var_48\nif (arg2 == 0)\nr14 = &var_48\nint32_t* rax_1 = __errno_location()\n*rax_1 = 0\nchar r15 = *arg1\nuint16_t* rcx = *__ctype_b_loc()\nif ((*(&rcx[zx.q(r15)] + 1) & 0x20) != 0)\nchar* rax_4 = arg1\nuint64_t rdx\nrdx = zx.q(rax_4[1])\nrax_4 = &rax_4[1]\nr15 = rdx.b\ndo while ((*(&rcx[rdx] + 1) & 0x20) != 0)\nint32_t rbx_1\nif (r15 == 0x2d)\nrbx_1 = 4\nint64_t rax_5 = __isoc23_strtoumax(arg1, r14, 0, rcx)\nchar* rcx_1 = *r14\nint64_t r15_1 = rax_5\nchar* rcx_2\nuint32_t r12_1\nif (arg1 == rcx_1)\nr12_1 = zx.d(*rcx_1)\nif (r12_1.b == 0)\nrbx_1 = 4\nrbx_1 = 0\nr15_1 = 1\nrcx_2 = rcx_1\nif (strchr(arg4, sx.d(r12_1.b)) == 0)\nrbx_1 = 4\nlabel_412083:\nuint64_t rax_11 = zx.q(r12_1 - 0x45)\nchar* rax_12\nif (rax_11.b u<= 0x2f && test_bit(0x81440030b945, rax_11))\nrax_12 = strchr(arg4, 0x30)\nint64_t rsi_2\n// ... truncated",
        "pseudoc": "{\n    int64_t* r14 = arg2;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    void var_48;\n    \n    if (!arg2)\n        r14 = &var_48;\n    int32_t* rax_1 = __errno_location();\n    *(uint32_t*)rax_1 = 0;\n    char r15 = *(uint8_t*)arg1;\n    uint16_t* rcx = *(uint64_t*)__ctype_b_loc();\n    \n    if (*(uint8_t*)(&rcx[(uint64_t)r15] + 1) & 0x20)\n    {\n        char* rax_4 = arg1;\n        uint64_t rdx;\n        \n        do\n        {\n            rdx = (uint64_t)rax_4[1];\n            rax_4 = &rax_4[1];\n            r15 = (uint8_t)rdx;\n        } while (*(uint8_t*)(&rcx[rdx] + 1) & 0x20);\n    }\n    \n    int32_t rbx_1;\n    \n    if (r15 == 0x2d)\n        rbx_1 = 4;\n    else\n    {\n        int64_t rax_5 = __isoc23_strtoumax(arg1, r14, 0, rcx);\n        char* rcx_1 = *(uint64_t*)r14;\n        int64_t r15_1 = rax_5;\n        char* rcx_2;\n        uint32_t r12_1;\n        \n        if (arg1 == rcx_1)\n        {\n            r12_1 = (uint32_t)*(uint8_t*)rcx_1;\n            \n            if (!(uint8_t)r12_1)\n                rbx_1 = 4;\n            else\n            {\n                rbx_1 = 0;\n                r15_1 = 1;\n                rcx_2 = rcx_1;\n                \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_parse_uintmax",
          "confidence": 0.87,
          "rationale": "The function trims whitespace, handles optional sign, clears errno, and calls __isoc23_strtoumax to convert a string to an unsigned integer, indicating it is a numeric parsing utility.",
          "evidence_refs": [
            "imports:__errno_location",
            "imports:__ctype_b_loc",
            "imports:__isoc23_strtoumax",
            "call:0x404ae0"
          ],
          "tags": [
            "config",
            "process"
          ],
          "alt_names": [
            "ai_str_to_uintmax",
            "ai_parse_number"
          ]
        },
        "explain": {
          "summary": "sub_411f60 parses a numeric string, skipping leading whitespace, handling an optional sign, converting the characters to an unsigned integer with __isoc23_strtoumax, and returns a status code indicating success or error.",
          "details": [
            "Clears errno via __errno_location before conversion.",
            "Uses __ctype_b_loc to skip whitespace characters before parsing.",
            "Detects a leading '-' sign and sets a flag (rbx_1 = 4) for negative values.",
            "Calls __isoc23_strtoumax to perform the actual conversion with base detection.",
            "If conversion consumes no characters or encounters errors, it returns a nonzero status; otherwise it stores the parsed value via the provided pointer and returns zero."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:__ctype_b_loc",
            "imports:__isoc23_strtoumax",
            "call:0x404760",
            "call:0x404d50",
            "call:0x404ae0"
          ],
          "unknowns": [
            "Exact meaning of the returned flag values (e.g., why rbx_1 is set to 4).",
            "How overflow or outofrange values are reported beyond the errno check."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "process"
      ]
    },
    {
      "addr": "0x412420",
      "original_name": "sub_412420",
      "final_name": "ai_get_blocksize_config",
      "score": 135.2,
      "bb_count": 25,
      "insn_est": 104,
      "callers": 2,
      "callees": [
        {
          "addr": "0x411e70",
          "name": "ai_match_argument_in_list",
          "original_name": "sub_411e70"
        },
        {
          "addr": "0x411f60",
          "name": "ai_parse_uintmax",
          "original_name": "sub_411f60"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x404700",
          "name": "ai_getenv_wrapper",
          "original_name": "getenv"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "getenv",
        "getenv",
        "getenv",
        "getenv",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "BLOCKSIZE",
        "POSIXLY_CORRECT",
        "eEgGkKmMpPtTyYzZ0"
      ],
      "constants": [
        "0x41b0ed",
        "0x404700",
        "0x41b516",
        "0x41e138",
        "0x422a20",
        "0x411e70",
        "0x41b520",
        "0x4232dc",
        "0x200",
        "0x4232d0",
        "0x41b530",
        "0x411f60",
        "0x4048f0",
        "0x180"
      ],
      "snippets": {
        "asm": "  0x412420  endbr64 \n  0x412424  push    rbp {__saved_rbp}\n  0x412425  mov     rbp, rsp {__saved_rbp}\n  0x412428  push    r13 {__saved_r13}\n  0x41242a  push    r12 {__saved_r12}\n  0x41242c  push    rbx {__saved_rbx}\n  0x41242d  mov     rbx, rdi\n  0x412430  sub     rsp, 0x18\n  0x412434  mov     rax, qword [fs:0x28]\n  0x41243d  mov     qword [rbp-0x28 {var_30}], rax\n  0x412441  xor     eax, eax  {0x0}\n  0x412443  test    rdi, rdi\n  0x412446  je      0x412570\n  0x412570  lea     rdi, [rel data_41b0ea[3]]  {\"BLOCK_SIZE\"}\n  0x412577  call    getenv\n  0x41257c  mov     rbx, rax\n  0x41257f  test    rax, rax\n  0x412582  jne     0x41244c\n  0x41244c  xor     r12d, r12d  {0x0}\n  0x41244f  cmp     byte [rbx], 0x27\n  0x412452  jne     0x41245e\n  0x412588  lea     rdi, [rel data_41b516]  {\"BLOCKSIZE\"}\n  0x41258f  call    getenv\n  0x412594  mov     rbx, rax\n  0x412597  test    rax, rax\n  0x41259a  jne     0x41244c\n  0x41245e  lea     r13, [rel data_41e138]\n  0x412465  lea     rsi, [rel data_422a20]\n  0x41246c  mov     rdi, rbx\n  0x41246f  mov     rdx, r13  {data_41e138}\n  ... (448 bytes total, truncated)",
        "hlil": "char* rbx = arg1\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nint32_t result\nif (arg1 == 0)\nchar* rax_8 = getenv(\"BLOCK_SIZE\")\nrbx = rax_8\nif (rax_8 != 0)\ngoto label_41244c\nchar* rax_9 = getenv(\"BLOCKSIZE\")\nrbx = rax_9\nif (rax_9 != 0)\ngoto label_41244c\nchar* rax_10 = getenv(\"POSIXLY_CORRECT\")\ndata_4232dc = 0\ndata_4232d0 = (zx.q((sbb.q(rax_10, rax_10, rax_10 u< 1)).d) & 0x200) + 0x200\nresult = 0\nlabel_41244c:\nint32_t r12_1 = 0\nif (*rbx == 0x27)\nrbx = &rbx[1]\nr12_1 = 4\nint32_t rax_2 = sub_411e70(rbx, &data_422a20, &data_41e138)\nif (rax_2 s< 0)\nint64_t var_38\nresult = sub_411f60(rbx, &var_38, &data_4232d0, \"eEgGkKmMpPtTyYzZ0\")\nint64_t rdx_3\nif (result != 0)\ndata_4232dc = 0\nrdx_3 = data_4232d0\nif (*rbx - 0x30 u> 9)\nchar rsi_2\nif (rbx == var_38)\nif (rbx[-1] == 0x42)\nr12_1 |= 0x180\nif (rbx[-2] == 0x69)\nr12_1 |= 0x20\nr12_1.b |= 0x80\nr12_1 |= 0x20\nbreak\n// ... truncated",
        "pseudoc": "{\n    char* rbx = arg1;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int32_t result;\n    \n    if (!arg1)\n    {\n        char* rax_8 = getenv(\"BLOCK_SIZE\");\n        rbx = rax_8;\n        \n        if (rax_8)\n            goto label_41244c;\n        \n        char* rax_9 = getenv(\"BLOCKSIZE\");\n        rbx = rax_9;\n        \n        if (rax_9)\n            goto label_41244c;\n        \n        char* rax_10 = getenv(\"POSIXLY_CORRECT\");\n        data_4232dc = 0;\n        data_4232d0 = ((uint64_t)(uint32_t)(rax_10 - rax_10) & 0x200) + 0x200;\n        result = 0;\n    }\n    else\n    {\n    label_41244c:\n        int32_t r12_1 = 0;\n        \n        if (*(uint8_t*)rbx == 0x27)\n        {\n            rbx = &rbx[1];\n            r12_1 = 4;\n        }\n        \n        int32_t rax_2 = sub_411e70(rbx, &data_422a20, &data_41e138);\n        \n        if (rax_2 < 0)\n        {\n            int64_t var_38;\n            result = sub_411f60(rbx, &var_38, &data_4232d0, \"eEgGkKmMpPtTyYzZ0\");\n            int64_t rdx_3;\n            \n            if (result)\n            {\n                data_4232dc = 0;\n                rdx_3 = data_4232d0;\n            }\n            else\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_get_blocksize_config",
          "confidence": 0.86,
          "rationale": "The function reads BLOCK_SIZE/BLOCKSIZE environment variables, checks POSIXLY_CORRECT, parses numeric values with suffixes (eEgGkKmMpPtTyYzZ0) and stores the result, indicating block size configuration handling.",
          "evidence_refs": [
            "strings:BLOCK_SIZE",
            "strings:BLOCKSIZE",
            "strings:POSIXLY_CORRECT",
            "strings:eEgGkKmMpPtTyYzZ0",
            "imports:getenv",
            "call:0x411e70",
            "call:0x411f60"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_parse_blocksize_env",
            "ai_blocksize_setting"
          ]
        },
        "explain": {
          "summary": "sub_412420 determines the block size to use by checking a provided argument or environment variables (BLOCK_SIZE, BLOCKSIZE) and falling back to a default of 512 bytes when POSIXLY_CORRECT is set. It parses the value, handling optional leading quotes and unit suffixes (e.g., K, M, G) via sub_411f60, and stores the resulting size in global variables data_4232d0 and a flag in data_4232dc.",
          "details": [
            "If arg1 is NULL, the function queries the environment for BLOCK_SIZE or BLOCKSIZE; if none are found it checks POSIXLY_CORRECT and defaults to 0x200 (512) bytes.",
            "When a string is provided (or retrieved), a leading single quote is stripped and a flag is set, then sub_411e70 is called to match known size descriptors.",
            "If sub_411e70 fails, sub_411f60 parses the string as a numeric value with optional unit suffixes defined by the string \"eEgGkKmMpPtTyYzZ0\".",
            "The parsed block size is stored in data_4232d0, and data_4232dc is updated to indicate whether a custom size was successfully parsed."
          ],
          "evidence_refs": [
            "strings:BLOCK_SIZE",
            "strings:BLOCKSIZE",
            "strings:POSIXLY_CORRECT",
            "strings:eEgGkKmMpPtTyYzZ0",
            "imports:getenv",
            "call:0x411e70",
            "call:0x411f60",
            "imports:__stack_chk_fail"
          ],
          "unknowns": [
            "Exact semantics of data_4232dc flag and how it influences later code",
            "Full handling of quoted values beyond the initial quote detection",
            "All possible unit suffix mappings performed by sub_411f60"
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x412600",
      "original_name": "sub_412600",
      "final_name": "ai_filename_compare",
      "score": 104.6,
      "bb_count": 29,
      "insn_est": 112,
      "callers": 4,
      "callees": [
        {
          "addr": "0x40c110",
          "name": "ai_validate_dot_extension",
          "original_name": "sub_40c110"
        },
        {
          "addr": "0x40c110",
          "name": "ai_validate_dot_extension",
          "original_name": "sub_40c110"
        },
        {
          "addr": "0x40c1f0",
          "name": "ai_is_digit_string",
          "original_name": "sub_40c1f0"
        },
        {
          "addr": "0x40c1f0",
          "name": "ai_is_digit_string",
          "original_name": "sub_40c1f0"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__stack_chk_fail"
      ],
      "string_refs": [
        "<.u|"
      ],
      "constants": [
        "0x4048f0",
        "0xffffffff",
        "0x40c110",
        "0x40c1f0"
      ],
      "snippets": {
        "asm": "  0x412600  endbr64 \n  0x412604  push    rbp {__saved_rbp}\n  0x412605  mov     rbp, rsp {__saved_rbp}\n  0x412608  push    r15 {__saved_r15}\n  0x41260a  push    r14 {__saved_r14}\n  0x41260c  push    r13 {__saved_r13}\n  0x41260e  push    r12 {__saved_r12}\n  0x412610  push    rbx {__saved_rbx}\n  0x412611  sub     rsp, 0x28\n  0x412615  movzx   edx, byte [rdi]\n  0x412618  mov     rax, qword [fs:0x28]\n  0x412621  mov     qword [rbp-0x38 {var_40}], rax\n  0x412625  xor     eax, eax  {0x0}\n  0x412627  mov     qword [rbp-0x40 {var_48}], 0xffffffffffffffff\n  0x41262f  movzx   eax, byte [rsi]\n  0x412632  mov     qword [rbp-0x48 {var_50}], 0xffffffffffffffff\n  0x41263a  test    dl, dl\n  0x41263c  je      0x412738\n  0x412738  neg     al\n  0x41273a  sbb     eax, eax\n  0x41273c  jmp     0x412715\n  0x412642  test    al, al\n  0x412644  je      0x412710\n  0x412715  mov     rdx, qword [rbp-0x38 {var_40}]\n  0x412719  sub     rdx, qword [fs:0x28]\n  0x412722  jne     0x412767\n  0x412710  mov     eax, 0x1\n  0x41264a  mov     rbx, rdi\n  0x41264d  mov     r12, rsi\n  0x412650  cmp     dl, 0x2e\n  ... (377 bytes total, truncated)",
        "hlil": "char rdx = *arg1\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nint64_t var_48 = -1\nuint32_t rax_1 = zx.d(*arg2)\nint64_t var_50 = -1\nuint32_t result\nif (rdx == 0)\nlabel_412738:\nchar temp0_1 = rax_1.b\nrax_1.b = neg.b(rax_1.b)\nresult = sbb.d(rax_1, rax_1, temp0_1 != 0)\nlabel_412719:\n*(fsbase + 0x28)\nif (rax == *(fsbase + 0x28))\nreturn result\nif (rax_1.b == 0)\nlabel_412710:\nresult = 1\ngoto label_412719\nif (rdx == 0x2e)\nif (rax_1.b != 0x2e)\nlabel_412760:\nresult = -1\ngoto label_412719\nchar rdx_4 = arg1[1]\nrax_1 = zx.d(arg2[1])\nif (rdx_4 == 0)\ngoto label_412738\nif (rax_1.b == 0)\ngoto label_412710\nif (rdx_4 != 0x2e)\nif (rax_1.b != 0x2e || arg2[2] != 0)\ngoto label_412668\ngoto label_412710\nchar rdx_7 = arg1[2]\nif (rax_1.b != 0x2e)\nif (rdx_7 != 0)\ngoto label_412668\ngoto label_412760\n// ... truncated",
        "pseudoc": "{\n    char rdx = *(uint8_t*)arg1;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int64_t var_48 = -1;\n    uint32_t rax_1 = (uint32_t)*(uint8_t*)arg2;\n    int64_t var_50 = -1;\n    uint32_t result;\n    \n    if (!rdx)\n    {\n    label_412738:\n        char temp0_1 = (uint8_t)rax_1;\n        (uint8_t)rax_1 = -((char)rax_1);\n        result = rax_1 - rax_1;\n    label_412719:\n        *(uint64_t*)((char*)fsbase + 0x28);\n        \n        if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n            return result;\n    }\n    else\n    {\n        if (!(uint8_t)rax_1)\n        {\n        label_412710:\n            result = 1;\n            goto label_412719;\n        }\n        \n        if (rdx == 0x2e)\n        {\n            if ((uint8_t)rax_1 != 0x2e)\n            {\n            label_412760:\n                result = -1;\n                goto label_412719;\n            }\n            \n            char rdx_4 = arg1[1];\n            rax_1 = (uint32_t)arg2[1];\n            \n            if (!rdx_4)\n                goto label_412738;\n            \n            if (!(uint8_t)rax_1)\n                goto label_412710;\n            \n            if (rdx_4 != 0x2e)\n            {\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_filename_compare",
          "confidence": 0.78,
          "rationale": "The function implements a custom string comparison handling '.' characters and case, used by higher-level functions before falling back to strcmp, indicating filename or path component comparison logic.",
          "evidence_refs": [
            "strings:'<.u|'",
            "imports:__stack_chk_fail",
            "call:0x40c110",
            "call:0x40c1f0",
            "call:0x4048f0"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_custom_strcmp",
            "ai_dot_aware_strcmp"
          ]
        },
        "explain": {
          "summary": "sub_412600 is a custom string comparator that first checks for null or '.' characters, handling special cases for empty strings and dot-prefixed components before delegating to helper routines for more detailed comparison. It returns -1, 0, or 1 like strcmp, and is used by higherlevel functions that fall back to a standard strcmp if this routine reports equality.",
          "details": [
            "The function reads the first byte of each input string (arg1, arg2) and treats a zero byte as endofstring, returning a result based on sign inversion.",
            "If the first character is a period (0x2e), it performs special handling for dotprefixed names, comparing subsequent characters and possibly recursing.",
            "When both characters are nonzero and not a dot, it calls sub_40c110 and sub_40c1f0 (numeric and dotsegment helpers) to perform more complex ordering before falling back to a simple comparison.",
            "A stack canary check (__stack_chk_fail) is present, indicating stack protection is enabled."
          ],
          "evidence_refs": [
            "strings:'<.u|'",
            "imports:__stack_chk_fail",
            "call:0x40c110",
            "call:0x40c1f0",
            "call:0x4048f0"
          ],
          "unknowns": [
            "Exact semantics of the numeric comparison performed by sub_40c1f0",
            "Full handling of multicharacter dot sequences beyond the shown snippet"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x412790",
      "original_name": "sub_412790",
      "final_name": "ai_locale_string_validator",
      "score": 409.5,
      "bb_count": 363,
      "insn_est": 1242,
      "callers": 5,
      "callees": [
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        },
        {
          "addr": "0x4048d0",
          "name": "ai_get_mb_cur_max",
          "original_name": "__ctype_get_mb_cur_max"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404d50",
          "name": "ai_get_ctype_table",
          "original_name": "__ctype_b_loc"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404a10",
          "name": "ai_memcmp_wrapper",
          "original_name": "memcmp"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x411700",
          "name": "ai_utf8_to_utf32_wrapper",
          "original_name": "sub_411700"
        },
        {
          "addr": "0x404d20",
          "name": "ai_is_wide_printable",
          "original_name": "iswprint"
        },
        {
          "addr": "0x404d00",
          "name": "ai_check_multibyte_state",
          "original_name": "mbsinit"
        },
        {
          "addr": "0x40df40",
          "name": "ai_detect_locale_charset",
          "original_name": "sub_40df40"
        },
        {
          "addr": "0x40df40",
          "name": "ai_detect_locale_charset",
          "original_name": "sub_40df40"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "abort",
        "__ctype_get_mb_cur_max",
        "dcgettext",
        "dcgettext",
        "strlen",
        "__ctype_b_loc",
        "strlen",
        "memcmp",
        "strlen",
        "iswprint",
        "mbsinit",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x404750",
        "0x41dc20",
        "0x41aef1",
        "0x41b542",
        "0x4048c0",
        "0x41afef",
        "0x4048e0",
        "0x40df40",
        "0x4048d0",
        "0x404a10",
        "0x3ffffff53ffffff",
        "0x404d50",
        "0x41dc4c",
        "0x4048f0",
        "0xfffffffd",
        "0xa4000000",
        "0x41de4c",
        "0x41dd4c",
        "0x404d20",
        "0x404d00",
        "0x411700",
        "0x7000a38200000000",
        "0x20000002b"
      ],
      "snippets": {
        "asm": "  0x412790  endbr64 \n  0x412794  push    rbp {__saved_rbp}\n  0x412795  mov     r11, rsi\n  0x412798  mov     rbp, rsp {__saved_rbp}\n  0x41279b  push    r15 {__saved_r15}\n  0x41279d  mov     r15d, ecx\n  0x4127a0  push    r14 {__saved_r14}\n  0x4127a2  push    r13 {__saved_r13}\n  0x4127a4  push    r12 {__saved_r12}\n  0x4127a6  push    rbx {__saved_rbx}\n  0x4127a7  sub     rsp, 0xb8\n  0x4127ae  mov     qword [rbp-0x78 {var_80}], r9\n  0x4127b2  mov     r14, qword [rbp+0x10 {arg7}]\n  0x4127b6  mov     r9, 0xffffffffffffffff\n  0x4127bd  mov     qword [rbp-0x68 {var_70}], rdx\n  0x4127c1  mov     r13, qword [rbp+0x18 {arg8}]\n  0x4127c5  mov     dword [rbp-0xb4 {var_bc}], r8d\n  0x4127cc  mov     rax, qword [fs:0x28]\n  0x4127d5  mov     qword [rbp-0x38 {var_40}], rax\n  0x4127d9  xor     eax, eax  {0x0}\n  0x4127db  mov     qword [rbp-0xd8 {var_e0}], r14\n  0x4127e2  mov     r14, r9  {-0x1}\n  0x4127e5  mov     qword [rbp-0xd0 {var_d8}], r13\n  0x4127ec  mov     r13, rdi\n  0x4127ef  nop     \n  0x404d89  call    abort\n  0x404d89  { Does not return }\n  0x412819  lea     rsi, [rel jump_table_41dc20]\n  0x412820  mov     eax, r15d\n  0x412823  mov     r11, qword [rbp-0x58 {var_60_2}]\n  ... (5341 bytes total, truncated)",
        "hlil": "char* r11 = arg2\nint32_t r15 = arg4\nint64_t var_80 = arg6\nint32_t var_bc = arg5\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nchar* var_e0 = arg7\nchar* r14_1 = -ffffffffffffffff\nchar* var_d8 = arg8\nchar* r13_1 = arg1\nlabel_4127f4:\nuint64_t rax_2\nuint64_t rdx\nuint32_t r8\nuint32_t r9\nrax_2, rdx, r8, r9 = __ctype_get_mb_cur_max()\nint32_t r12_2 = var_bc & 2\nbool var_61_1 = r12_2 != 0\nif (r15 u> 0xa)\nabort()\nnoreturn\nchar* var_b8_1\nchar const* const var_b0_1\nuint64_t var_78_1\nchar var_64_1\nchar result_4\nchar var_62_1\nchar* var_60_2\nchar* rax_5\nchar* result_2\nswitch (r15)\ncase 0\nvar_60_2.b = 1\nresult_2 = nullptr\nvar_64_1 = 0\nvar_62_1 = 0\nvar_b8_1 = nullptr\nvar_61_1 = false\nresult_4 = 0\nvar_78_1 = 0\n// ... truncated",
        "pseudoc": "{\n    char* r11 = arg2;\n    int32_t r15 = arg4;\n    int64_t var_80 = arg6;\n    int32_t var_bc = arg5;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    char* var_e0 = arg7;\n    char* r14_1 = -ffffffffffffffff;\n    char* var_d8 = arg8;\n    char* r13_1 = arg1;\nlabel_4127f4:\n    uint64_t rax_2;\n    uint64_t rdx;\n    uint32_t r8;\n    uint32_t r9;\n    rax_2 = __ctype_get_mb_cur_max();\n    int32_t r12_2 = var_bc & 2;\n    bool var_61_1 = r12_2;\n    \n    if (r15 > 0xa)\n    {\n        abort();\n        /* no return */\n    }\n    \n    char* var_b8_1;\n    char const* const var_b0_1;\n    uint64_t var_78_1;\n    char var_64_1;\n    char result_4;\n    char var_62_1;\n    char* var_60_2;\n    char* rax_5;\n    char* result_2;\n    \n    switch (r15)\n    {\n        case 0:\n        {\n            (uint8_t)var_60_2 = 1;\n            result_2 = nullptr;\n            var_64_1 = 0;\n            var_62_1 = 0;\n            var_b8_1 = nullptr;\n            var_61_1 = false;\n            result_4 = 0;\n            var_78_1 = 0;\n            var_b0_1 = nullptr;\n            break;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_locale_string_validator",
          "confidence": 0.68,
          "rationale": "The function switches on a mode value (r15) with a limit of 10, uses __ctype_get_mb_cur_max, dcgettext, iswprint, memcmp and strlen, and aborts on invalid mode. It appears to validate or parse strings according to locale rules, likely checking printable characters and length.",
          "evidence_refs": [
            "imports:abort",
            "imports:__ctype_get_mb_cur_max",
            "imports:dcgettext",
            "imports:iswprint",
            "call:0x404750",
            "call:0x4048d0",
            "call:0x4048c0"
          ],
          "tags": [
            "file_io",
            "process"
          ],
          "alt_names": [
            "ai_string_locale_check",
            "ai_multibyte_string_parser"
          ]
        },
        "explain": {
          "summary": "sub_412790 is a validation/processing routine that examines a string or buffer according to a mode parameter (r15) limited to values 010. It uses locale information (__ctype_get_mb_cur_max) and character classification (iswprint, __ctype_b_loc) to compute lengths, compare data (memcmp) and possibly translate messages (dcgettext). If an unsupported mode is supplied it aborts, otherwise it initializes internal state and returns a length or status used by callers such as sub_40bcc0 for further checks.",
          "details": [
            "The function checks r15 against a maximum of 0xA and aborts if out of range, indicating r15 is a mode or type identifier.",
            "It calls __ctype_get_mb_cur_max early, suggesting handling of multibyte character encodings.",
            "Switch logic initializes many local variables (e.g., var_60_2, var_64_1) based on the mode, likely preparing buffers for parsing.",
            "Calls to memcmp, iswprint, __ctype_b_loc, and dcgettext imply character property checks and localized error handling.",
            "Callers (e.g., sub_40bcc0) use the return value as a length to compare against strlen, indicating the function returns a processed length or validation result."
          ],
          "evidence_refs": [
            "imports:abort",
            "imports:__ctype_get_mb_cur_max",
            "imports:dcgettext",
            "imports:strlen",
            "imports:memcmp",
            "imports:iswprint",
            "call:0x404750",
            "call:0x4048d0",
            "call:0x4048c0"
          ],
          "unknowns": [
            "Exact semantics of each case branch within the switch (full behavior not shown).",
            "Precise meaning of all eight arguments and how they map to internal processing.",
            "The role of the other callee addresses (0x4048e0, 0x404a10, 0x411700) not detailed in the excerpt."
          ],
          "confidence": 0.73
        }
      },
      "is_boring": false,
      "tags": [
        "file_io",
        "process"
      ]
    },
    {
      "addr": "0x413ce0",
      "original_name": "sub_413ce0",
      "final_name": "ai_dynamic_array_ensure_and_process",
      "score": 122.8,
      "bb_count": 14,
      "insn_est": 126,
      "callers": 8,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x410a20",
          "name": "ai_safe_buffer_resize",
          "original_name": "sub_410a20"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x412790",
          "name": "ai_locale_string_validator",
          "original_name": "sub_412790"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x412790",
          "name": "ai_locale_string_validator",
          "original_name": "sub_412790"
        },
        {
          "addr": "0x410a20",
          "name": "ai_safe_buffer_resize",
          "original_name": "sub_410a20"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__errno_location",
        "memset",
        "free",
        "malloc",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x404760",
        "0x423270",
        "0x423250",
        "0x412790",
        "0x423260",
        "0x424400",
        "0x7fffffff",
        "0x410a20",
        "0x4048f0",
        "0x4046d0",
        "0x4046b0",
        "0x4049c0",
        "0x40e430"
      ],
      "snippets": {
        "asm": "  0x413ce0  endbr64 \n  0x413ce4  push    rbp {__saved_rbp}\n  0x413ce5  mov     rbp, rsp {__saved_rbp}\n  0x413ce8  push    r15 {__saved_r15}\n  0x413cea  mov     r15, rdx\n  0x413ced  push    r14 {__saved_r14}\n  0x413cef  push    r13 {__saved_r13}\n  0x413cf1  push    r12 {__saved_r12}\n  0x413cf3  push    rbx {__saved_rbx}\n  0x413cf4  movsxd  rbx, edi\n  0x413cf7  sub     rsp, 0x48\n  0x413cfb  mov     qword [rbp-0x48 {var_50}], rsi\n  0x413cff  mov     rax, qword [fs:0x28]\n  0x413d08  mov     qword [rbp-0x38 {var_40}], rax\n  0x413d0c  xor     eax, eax  {0x0}\n  0x413d0e  call    __errno_location\n  0x413d13  mov     r14, qword [rel data_423270]\n  0x413d1a  mov     r12, rax\n  0x413d1d  mov     eax, dword [rax]\n  0x413d1f  mov     dword [rbp-0x4c {var_54}], eax\n  0x413d22  mov     eax, dword [rel data_423250]\n  0x413d28  cmp     ebx, eax\n  0x413d2a  jl      0x413d9a\n  0x413d9a  mov     r8d, dword [r15+0x4]\n  0x413d9e  shl     rbx, 0x4\n  0x413da2  lea     rax, [r15+0x8]\n  0x413da6  mov     ecx, dword [r15]\n  0x413da9  add     rbx, r14\n  0x413dac  mov     qword [rbp-0x60 {var_68}], rax\n  0x413db0  mov     rdx, qword [rbp-0x48 {var_50}]\n  ... (462 bytes total, truncated)",
        "hlil": "int64_t rbx = sx.q(arg1)\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nint32_t* rax_2 = __errno_location()\nint128_t* r14 = data_423270\nint32_t rax_3 = *rax_2\nint32_t rax_4 = data_423250\nif (rbx.d s>= rax_4)\nint64_t r9_1 = sx.q(rax_4)\nint64_t var_48 = r9_1\nint64_t rdx_3 = sx.q(rbx.d - rax_4 + 1)\nint64_t r9_2\nint32_t var_60\nif (r14 == &data_423260)\nvar_60.q = r9_1\nint128_t* rax_14 = sub_410a20(0, &var_48, rdx_3, 0x7fffffff, 0x10)\nint128_t zmm0_1 = data_423260\nr9_2 = var_60.q\ndata_423270 = rax_14\nr14 = rax_14\n*rax_14 = zmm0_1\nvar_60.q = r9_1\nint128_t* rax_5 = sub_410a20(r14, &var_48, rdx_3, 0x7fffffff, 0x10)\nr9_2 = var_60.q\ndata_423270 = rax_5\nr14 = rax_5\nmemset(&r14[r9_2], 0, (var_48 - r9_2) << 4)\ndata_423250 = var_48.d\nint64_t* rbx_2 = &r14[rbx]\nint32_t r8_1 = arg3[1] | 1\nchar* r13 = *rbx_2\nchar* result = rbx_2[1]\nchar* rax_8 = sub_412790(result, r13, arg2, *arg3, r8_1, &arg3[2], *(arg3 + 0x28), *(arg3 + 0x30))\nif (rax_8 u>= r13)\nchar* n = &rax_8[1]\n*rbx_2 = n\nif (result != &data_424400)\nfree(result)\nchar* result_1 = malloc(n)\nresult = result_1\n// ... truncated",
        "pseudoc": "{\n    int64_t rbx = (int64_t)arg1;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int32_t* rax_2 = __errno_location();\n    int128_t* r14 = data_423270;\n    int32_t rax_3 = *(uint32_t*)rax_2;\n    int32_t rax_4 = data_423250;\n    \n    if ((int32_t)rbx >= rax_4)\n    {\n        int64_t r9_1 = (int64_t)rax_4;\n        int64_t var_48 = r9_1;\n        int64_t rdx_3 = (int64_t)((uint32_t)rbx - rax_4 + 1);\n        int64_t r9_2;\n        int32_t var_60;\n        \n        if (r14 == &data_423260)\n        {\n            var_60 = r9_1;\n            int128_t* rax_14 = sub_410a20(0, &var_48, rdx_3, 0x7fffffff, 0x10);\n            int128_t zmm0_1 = data_423260;\n            r9_2 = var_60;\n            data_423270 = rax_14;\n            r14 = rax_14;\n            *(uint128_t*)rax_14 = zmm0_1;\n        }\n        else\n        {\n            var_60 = r9_1;\n            int128_t* rax_5 = sub_410a20(r14, &var_48, rdx_3, 0x7fffffff, 0x10);\n            r9_2 = var_60;\n            data_423270 = rax_5;\n            r14 = rax_5;\n        }\n        memset(&r14[r9_2], 0, (var_48 - r9_2) << 4);\n        data_423250 = (int32_t)var_48;\n    }\n    \n    int64_t* rbx_2 = &r14[rbx];\n    int32_t r8_1 = arg3[1] | 1;\n    char* r13 = *(uint64_t*)rbx_2;\n    char* result = rbx_2[1];\n    char* rax_8 = sub_412790(result, r13, arg2, *(uint32_t*)arg3, r8_1, &arg3[2], \n        *(uint64_t*)((char*)arg3 + 0x28), *(uint64_t*)((char*)arg3 + 0x30));\n    \n    if (rax_8 >= r13)\n    {\n        char* n = &rax_8[1];\n        *(uint64_t*)rbx_2 = n;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_dynamic_array_ensure_and_process",
          "confidence": 0.78,
          "rationale": "The function checks if an index exceeds the current size, expands a dynamically allocated array using a custom realloc, zeroes new slots, then updates an entry and calls a processing routine. This matches behavior of ensuring capacity and inserting/processing an element in a dynamic array.",
          "evidence_refs": [
            "imports:malloc",
            "imports:free",
            "imports:memset",
            "imports:__errno_location",
            "call:0x410a20",
            "call:0x412790"
          ],
          "tags": [],
          "alt_names": [
            "ai_ensure_capacity",
            "ai_vector_set"
          ]
        },
        "explain": {
          "summary": "sub_413ce0 manages a resizable array of 128bit entries, expanding it when the requested index exceeds the current capacity, then invokes a helper (sub_412790) to process the selected entry and updates the stored pointer based on the result.",
          "details": [
            "The function checks if the supplied index (arg1) is greater than or equal to the current size stored in data_423250; if so it reallocates the array using sub_410a20, zerofills the new region with memset, and updates the global pointer data_423270 and size.",
            "After ensuring capacity, it retrieves the entry at the given index, extracts fields from arg3, and calls sub_412790 with those fields and the entry's pointers; if the returned pointer is beyond the original entry pointer, it stores the new pointer back into the array."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "imports:memset",
            "imports:free",
            "imports:malloc",
            "calls:0x410a20",
            "calls:0x412790",
            "calls:0x4049c0",
            "constants:0x7fffffff"
          ],
          "unknowns": [
            "Exact semantics of sub_412790 and the structure of the array elements",
            "Purpose of the additional arguments passed from arg3 (e.g., arg3[1], arg3+0x28, arg3+0x30)",
            "Why __errno_location is read at function start (potential stack canary check)"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x413ec0",
      "original_name": "sub_413ec0",
      "final_name": "ai_print_valid_arguments",
      "score": 122.0,
      "bb_count": 12,
      "insn_est": 95,
      "callers": 8,
      "callees": [
        {
          "addr": "0x411e70",
          "name": "ai_match_argument_in_list",
          "original_name": "sub_411e70"
        },
        {
          "addr": "0x40c040",
          "name": "ai_argument_error_report",
          "original_name": "sub_40c040"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x404a30",
          "name": "ai_print_string_to_stream",
          "original_name": "fputs_unlocked"
        },
        {
          "addr": "0x413ce0",
          "name": "ai_dynamic_array_ensure_and_process",
          "original_name": "sub_413ce0"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x413ce0",
          "name": "ai_dynamic_array_ensure_and_process",
          "original_name": "sub_413ce0"
        },
        {
          "addr": "0x404cd0",
          "name": "ai_safe_fprintf_wrapper",
          "original_name": "__fprintf_chk"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        }
      ],
      "import_refs": [
        "dcgettext",
        "fputs_unlocked",
        "__fprintf_chk",
        "__fprintf_chk",
        "__overflow"
      ],
      "string_refs": [
        "Valid arguments are:",
        "\n  - %s",
        ", %s"
      ],
      "constants": [
        "0x411e70",
        "0x40c040",
        "0x422ff8",
        "0x41b544",
        "0x4048c0",
        "0x404a30",
        "0x404960",
        "0x423040",
        "0x413ce0",
        "0x41b559",
        "0x404cd0",
        "0x41b561"
      ],
      "snippets": {
        "asm": "  0x413ec0  endbr64 \n  0x413ec4  push    rbp {__saved_rbp}\n  0x413ec5  mov     rbp, rsp {__saved_rbp}\n  0x413ec8  push    r15 {__saved_r15}\n  0x413eca  mov     r15, rdi\n  0x413ecd  push    r14 {__saved_r14}\n  0x413ecf  mov     r14, rsi\n  0x413ed2  push    r13 {__saved_r13}\n  0x413ed4  mov     rdi, r14\n  0x413ed7  mov     r13, r8\n  0x413eda  push    r12 {__saved_r12}\n  0x413edc  mov     r12, rdx\n  0x413edf  mov     rdx, rcx\n  0x413ee2  push    rbx {__saved_rbx}\n  0x413ee3  mov     rsi, r12\n  0x413ee6  mov     rbx, rcx\n  0x413ee9  sub     rsp, 0x18\n  0x413eed  call    sub_411e70\n  0x413ef2  test    rax, rax\n  0x413ef5  js      0x413f10\n  0x413f10  mov     rdx, rax\n  0x413f13  mov     rsi, r14\n  0x413f16  mov     rdi, r15\n  0x413f19  call    sub_40c040\n  0x413f1e  mov     r14, qword [rel stderr]\n  0x413f25  mov     edx, 0x5\n  0x413f2a  xor     edi, edi  {0x0}\n  0x413f2c  lea     rsi, [rel data_41b544]  {\"Valid arguments are:\"}\n  0x413f33  mov     r15, qword [r14]\n  0x413f36  call    dcgettext\n  ... (336 bytes total, truncated)",
        "hlil": "int32_t* rbx = arg4\nint64_t result = sub_411e70(arg2, arg3, arg4)\nif (result s>= 0)\nreturn result\nsub_40c040(arg1, arg2, result)\nint64_t r15_2 = 0\nfputs_unlocked(dcgettext(nullptr, \"Valid arguments are:\", 5), *stderr)\nchar* rsi_3 = *arg3\nint32_t* r8 = rbx\nif (rsi_3 == 0)\nlabel_413ff0:\nFILE* f = *stderr\nchar* _IO_write_ptr = f->_IO_write_ptr\nif (_IO_write_ptr u>= f->_IO_write_end)\n__overflow(f, 0xa)\nf->_IO_write_ptr = &_IO_write_ptr[1]\n*_IO_write_ptr = 0xa\narg5()\nreturn -1\nwhile (true)\nchar* rax_1 = sub_413ce0(0, rsi_3, &data_423040)\n__fprintf_chk(*stderr, 2, \"\\n  - %s\", rax_1)\nint32_t* r8_1 = r8\nint32_t* r10_1 = rbx\nwhile (true)\nr15_2 += 1\nr8 = &r8_1[1]\nrsi_3 = arg3[r15_2]\nif (rsi_3 == 0)\ngoto label_413ff0\nrbx = r8\nif (*r8 != *r10_1)\nbreak\nchar* rax_4 = sub_413ce0(0, rsi_3, &data_423040)\n__fprintf_chk(*stderr, 2, \", %s\", rax_4)\nr8_1 = r8",
        "pseudoc": "{\n    int32_t* rbx = arg4;\n    int64_t result = sub_411e70(arg2, arg3, arg4);\n    \n    if (result >= 0)\n        return result;\n    \n    sub_40c040(arg1, arg2, result);\n    int64_t r15_2 = 0;\n    fputs_unlocked(dcgettext(nullptr, \"Valid arguments are:\", 5), *(uint64_t*)stderr);\n    char* rsi_3 = *(uint64_t*)arg3;\n    int32_t* r8 = rbx;\n    \n    if (!rsi_3)\n    {\n    label_413ff0:\n        FILE* f = *(uint64_t*)stderr;\n        char* _IO_write_ptr = f->_IO_write_ptr;\n        \n        if (_IO_write_ptr >= f->_IO_write_end)\n            __overflow(f, 0xa);\n        else\n        {\n            f->_IO_write_ptr = &_IO_write_ptr[1];\n            *(uint8_t*)_IO_write_ptr = 0xa;\n        }\n        \n        arg5();\n        return -1;\n    }\n    \n    while (true)\n    {\n        char* rax_1 = sub_413ce0(0, rsi_3, &data_423040);\n        __fprintf_chk(*(uint64_t*)stderr, 2, \"\\n  - %s\", rax_1);\n        int32_t* r8_1 = r8;\n        int32_t* r10_1 = rbx;\n        \n        while (true)\n        {\n            r15_2 += 1;\n            r8 = &r8_1[1];\n            rsi_3 = arg3[r15_2];\n            \n            if (!rsi_3)\n                goto label_413ff0;\n            \n            rbx = r8;\n            \n            if (*(uint32_t*)r8 != *(uint32_t*)r10_1)\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_valid_arguments",
          "confidence": 0.92,
          "rationale": "The function validates arguments, prints an error via sub_40c040 when invalid, then outputs \"Valid arguments are:\" followed by a list of possible arguments, indicating it generates a usage/help message.",
          "evidence_refs": [
            "strings:Valid arguments are:",
            "imports:fputs_unlocked",
            "imports:__fprintf_chk",
            "call:0x411e70",
            "call:0x40c040"
          ],
          "tags": [],
          "alt_names": [
            "ai_display_help",
            "ai_show_usage"
          ]
        },
        "explain": {
          "summary": "sub_413ec0 validates command-line arguments using sub_411e70; if validation fails it reports an error via sub_40c040, prints a \"Valid arguments are:\" header and enumerates each acceptable argument, then returns -1.",
          "details": [
            "Calls sub_411e70(arg2,arg3,arg4) to locate a matching argument; a nonnegative return indicates success.",
            "On failure, invokes sub_40c040 to emit an \"invalid/ambiguous argument\" error message.",
            "Prints the string \"Valid arguments are:\" to stderr using fputs_unlocked and then iterates over the argument list (arg3) printing each entry with \"\\n  - %s\" via __fprintf_chk.",
            "Ensures a trailing newline is written to stderr, handling buffer overflow with __overflow if needed, and finally returns -1."
          ],
          "evidence_refs": [
            "strings:Valid arguments are:",
            "strings:\\n  - %s",
            "imports:fputs_unlocked",
            "imports:__fprintf_chk",
            "imports:__overflow",
            "call:0x411e70",
            "call:0x40c040",
            "call:0x413ce0"
          ],
          "unknowns": [
            "Exact semantics of arg1, arg2, arg3, arg4 beyond being argument descriptors",
            "The content and purpose of data_423040 used by sub_413ce0"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x414030",
      "original_name": "sub_414030",
      "final_name": "ai_init_dynamic_array",
      "score": 27.2,
      "bb_count": 3,
      "insn_est": 24,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4248e8"
        },
        {
          "addr": "0x413ce0",
          "name": "ai_dynamic_array_ensure_and_process",
          "original_name": "sub_413ce0"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x41db00",
        "0x413ce0",
        "0x4048f0"
      ],
      "snippets": {
        "asm": "  0x414030  endbr64 \n  0x414034  push    rbp {__saved_rbp}\n  0x414035  mov     rsi, rdi\n  0x414038  xor     edi, edi  {0x0}\n  0x41403a  mov     rbp, rsp {__saved_rbp}\n  0x41403d  sub     rsp, 0x40\n  0x414041  movdqa  xmm0, xmmword [rel data_41db00]\n  0x414049  mov     rax, qword [fs:0x28]\n  0x414052  mov     qword [rbp-0x8 {var_10}], rax\n  0x414056  xor     eax, eax  {0x0}\n  0x414058  lea     rdx, [rbp-0x40 {var_48}]\n  0x41405c  mov     qword [rbp-0x40 {var_48}], 0x3\n  0x414064  movups  xmmword [rbp-0x38 {var_40}], xmm0\n  0x414068  pxor    xmm0, xmm0\n  0x41406c  movups  xmmword [rbp-0x28], xmm0\n  0x414070  pxor    xmm0, xmm0\n  0x414074  movups  xmmword [rbp-0x18 {var_20}], xmm0\n  0x414078  call    sub_413ce0\n  0x41407d  mov     rdx, qword [rbp-0x8 {var_10}]\n  0x414081  sub     rdx, qword [fs:0x28]\n  0x41408a  jne     0x41408e\n  0x41408e  call    __stack_chk_fail\n  0x41408e  { Does not return }\n  0x41408c  leave    {__saved_rbp}\n  0x41408d  retn     {__return_addr}",
        "hlil": "int128_t zmm0 = data_41db00\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nint64_t var_48 = 3\nint128_t var_40 = zmm0\nint128_t var_30\n__builtin_memset(&var_30, 0, 0x20)\nchar* result = sub_413ce0(0, arg1, &var_48)\n*(fsbase + 0x28)\nif (rax == *(fsbase + 0x28))\nreturn result\n__stack_chk_fail()\nnoreturn",
        "pseudoc": "{\n    int128_t zmm0 = data_41db00;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int64_t var_48 = 3;\n    int128_t var_40 = zmm0;\n    int128_t var_30;\n    __builtin_memset(&var_30, 0, 0x20);\n    char* result = sub_413ce0(0, arg1, &var_48);\n    *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (rax == *(uint64_t*)((char*)fsbase + 0x28))\n        return result;\n    \n    __stack_chk_fail();\n    /* no return */\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_init_dynamic_array",
          "confidence": 0.68,
          "rationale": "The function sets up a default size (3), zeroes a buffer, and calls a subroutine that performs allocation based on those parameters, with a stack canary check. This pattern matches an initializer for a dynamic array or buffer.",
          "evidence_refs": [
            "imports:__stack_chk_fail",
            "call:0x413ce0",
            "constants:0x41db00"
          ],
          "tags": [],
          "alt_names": [
            "ai_allocate_buffer",
            "ai_init_array"
          ]
        },
        "explain": {
          "summary": "sub_414030 prepares a small stack frame, initializes a constant vector and a flag value, then forwards the call to sub_413ce0 with arguments (0, arg1, &var_48) and returns its result, while enforcing stack canary protection.",
          "details": [
            "Loads a 128bit constant from data_41db00 into a local variable and zeroes another buffer.",
            "Sets a local integer var_48 to 3 and passes its address to sub_413ce0 along with a zero and the original argument.",
            "After the call, verifies the stack canary stored at FS:0x28; on mismatch it invokes __stack_chk_fail."
          ],
          "evidence_refs": [
            "imports:__stack_chk_fail",
            "call:0x413ce0"
          ],
          "unknowns": [
            "Exact semantic purpose of the constant data_41db00 and the flag value 3.",
            "The higherlevel functionality performed by sub_413ce0."
          ],
          "confidence": 0.86
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x4140a0",
      "original_name": "sub_4140a0",
      "final_name": "ai_compute_display_width",
      "score": 139.9,
      "bb_count": 31,
      "insn_est": 113,
      "callers": 9,
      "callees": [
        {
          "addr": "0x4048d0",
          "name": "ai_get_mb_cur_max",
          "original_name": "__ctype_get_mb_cur_max"
        },
        {
          "addr": "0x4248e8"
        },
        {
          "addr": "0x404b30",
          "name": "ai_wcwidth_wrapper",
          "original_name": "wcwidth"
        },
        {
          "addr": "0x404d00",
          "name": "ai_check_multibyte_state",
          "original_name": "mbsinit"
        },
        {
          "addr": "0x411700",
          "name": "ai_utf8_to_utf32_wrapper",
          "original_name": "sub_411700"
        },
        {
          "addr": "0x404b30",
          "name": "ai_wcwidth_wrapper",
          "original_name": "wcwidth"
        },
        {
          "addr": "0x4047e0",
          "name": "ai_is_wide_control_char",
          "original_name": "iswcntrl"
        },
        {
          "addr": "0x404d50",
          "name": "ai_get_ctype_table",
          "original_name": "__ctype_b_loc"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__ctype_get_mb_cur_max",
        "wcwidth",
        "mbsinit",
        "wcwidth",
        "iswcntrl",
        "__ctype_b_loc",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x4048d0",
        "0x404d50",
        "0x4048f0",
        "0x7fffffff",
        "0x411700",
        "0x404b30",
        "0x4047e0",
        "0x404d00"
      ],
      "snippets": {
        "asm": "  0x4140a0  endbr64 \n  0x4140a4  push    rbp {__saved_rbp}\n  0x4140a5  mov     rbp, rsp {__saved_rbp}\n  0x4140a8  push    r15 {__saved_r15}\n  0x4140aa  push    r14 {__saved_r14}\n  0x4140ac  push    r13 {__saved_r13}\n  0x4140ae  lea     r13, [rdi+rsi]\n  0x4140b2  push    r12 {__saved_r12}\n  0x4140b4  push    rbx {__saved_rbx}\n  0x4140b5  mov     rbx, rdi\n  0x4140b8  sub     rsp, 0x38\n  0x4140bc  mov     rax, qword [fs:0x28]\n  0x4140c5  mov     qword [rbp-0x38 {var_40}], rax\n  0x4140c9  xor     eax, eax  {0x0}\n  0x4140cb  call    __ctype_get_mb_cur_max\n  0x4140d0  cmp     rax, 0x1\n  0x4140d4  jbe     0x4141d8\n  0x4141d8  xor     r12d, r12d  {0x0}\n  0x4141db  cmp     rbx, r13\n  0x4141de  jae     0x4141b4\n  0x4140da  xor     r12d, r12d  {0x0}\n  0x4140dd  cmp     rbx, r13\n  0x4140e0  jae     0x4141b4\n  0x4141b4  mov     rax, qword [rbp-0x38 {var_40}]\n  0x4141b8  sub     rax, qword [fs:0x28]\n  0x4141c1  jne     0x414228\n  0x4141e0  call    __ctype_b_loc\n  0x4141e5  xor     r12d, r12d  {0x0}\n  0x4141e8  mov     rdx, qword [rax]\n  0x4141eb  nop     dword [rax+rax]\n  ... (377 bytes total, truncated)",
        "hlil": "void* r13 = &arg1[arg2]\nchar* rbx = arg1\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nint32_t r12\nif (__ctype_get_mb_cur_max() u<= 1)\nr12 = 0\nif (rbx u< r13)\nr12 = 0\nuint16_t* rdx_3 = *__ctype_b_loc()\nwhile (true)\nuint64_t rax_12 = zx.q(*rbx)\nrbx = &rbx[1]\nint16_t rax_13 = rdx_3[rax_12]\nif ((rax_13:1.b & 0x40) != 0 || (rax_13.b & 2) == 0)\nif (r12 == 0x7fffffff)\nbreak\nr12 += 1\nif (r13 == rbx)\ngoto label_4141b8\nlabel_414220:\nr12 = 0x7fffffff\nr12 = 0\nwhile (rbx u< r13)\nif (sx.d(*rbx) - 0x20 u<= 0x5e)\nlabel_4140f8:\nrbx = &rbx[1]\nr12 += 1\nmbstate_t ps\n__builtin_memset(&ps, 0, 8)\nint32_t i\nwchar_t var_4c\nuint64_t rax_6 = sub_411700(&var_4c, rbx, r13 - rbx, &ps)\nuint64_t r15_1 = rax_6\nif (rax_6 == -1)\ngoto label_4140f8\nif (rax_6 == -2)\nr12 += 1\ngoto label_4141b8\nint32_t rax_5\n// ... truncated",
        "pseudoc": "{\n    void* r13 = &arg1[arg2];\n    char* rbx = arg1;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    int32_t r12;\n    \n    if (__ctype_get_mb_cur_max() <= 1)\n    {\n        r12 = 0;\n        \n        if (rbx < r13)\n        {\n            r12 = 0;\n            uint16_t* rdx_3 = *(uint64_t*)__ctype_b_loc();\n            \n            while (true)\n            {\n                uint64_t rax_12 = (uint64_t)*(uint8_t*)rbx;\n                rbx = &rbx[1];\n                int16_t rax_13 = rdx_3[rax_12];\n                \n                if (*(uint8_t*)((char*)&rax_13 + 1) & 0x40 || !((uint8_t)rax_13 & 2))\n                {\n                    if (r12 == 0x7fffffff)\n                        break;\n                    \n                    r12 += 1;\n                }\n                \n                if (r13 == rbx)\n                    goto label_4141b8;\n            }\n            \n        label_414220:\n            r12 = 0x7fffffff;\n        }\n    }\n    else\n    {\n        r12 = 0;\n        \n        while (rbx < r13)\n        {\n            if ((int32_t)*(uint8_t*)rbx - 0x20 <= 0x5e)\n            {\n            label_4140f8:\n                rbx = &rbx[1];\n                r12 += 1;\n            }\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compute_display_width",
          "confidence": 0.86,
          "rationale": "The function iterates over a string, uses ctype classification and wcwidth to count printable/displayable characters, returning a column width used for formatting output.",
          "evidence_refs": [
            "imports:__ctype_get_mb_cur_max",
            "imports:wcwidth",
            "imports:iswcntrl",
            "imports:__ctype_b_loc"
          ],
          "tags": [],
          "alt_names": [
            "ai_string_display_width",
            "ai_calc_column_width"
          ]
        },
        "explain": {
          "summary": "sub_4140a0 computes the display width (column count) of a string, handling both single-byte and multibyte locales. It iterates over the characters, using ctype tables for single-byte characters and wcwidth for multibyte characters, counting only printable characters and capping the result at 0x7fffffff.",
          "details": [
            "If __ctype_get_mb_cur_max() <= 1, the function walks each byte, checks character classification via __ctype_b_loc(), and increments a counter for characters that are not control or nonprintable.",
            "If the locale supports multibyte characters, it likely uses wcwidth (and related widecharacter checks) to add the column width of each wide character.",
            "The loop stops when the end of the buffer is reached or when the counter reaches the maximum 0x7fffffff."
          ],
          "evidence_refs": [
            "imports:__ctype_get_mb_cur_max",
            "imports:wcwidth",
            "imports:__ctype_b_loc",
            "call:0x4048d0",
            "call:0x404b30"
          ],
          "unknowns": [
            "Exact handling of multibyte characters beyond the truncated portion of the code",
            "Specific treatment of control characters versus printable characters in the multibyte branch"
          ],
          "confidence": 0.92
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x414230",
      "original_name": "sub_414230",
      "final_name": "ai_validate_string_and_flag",
      "score": 329.0,
      "bb_count": 77,
      "insn_est": 335,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048d0",
          "name": "ai_get_mb_cur_max",
          "original_name": "__ctype_get_mb_cur_max"
        },
        {
          "addr": "0x404d50",
          "name": "ai_get_ctype_table",
          "original_name": "__ctype_b_loc"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x4048d0",
          "name": "ai_get_mb_cur_max",
          "original_name": "__ctype_get_mb_cur_max"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x412790",
          "name": "ai_locale_string_validator",
          "original_name": "sub_412790"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404d50",
          "name": "ai_get_ctype_table",
          "original_name": "__ctype_b_loc"
        },
        {
          "addr": "0x404910",
          "name": "ai_mbrtowc_wrapper",
          "original_name": "mbrtowc"
        },
        {
          "addr": "0x40c6a0",
          "name": "ai_check_posix_locale",
          "original_name": "sub_40c6a0"
        },
        {
          "addr": "0x404b30",
          "name": "ai_wcwidth_wrapper",
          "original_name": "wcwidth"
        },
        {
          "addr": "0x404d00",
          "name": "ai_check_multibyte_state",
          "original_name": "mbsinit"
        },
        {
          "addr": "0x404b30",
          "name": "ai_wcwidth_wrapper",
          "original_name": "wcwidth"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x412790",
          "name": "ai_locale_string_validator",
          "original_name": "sub_412790"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "strlen",
        "__ctype_get_mb_cur_max",
        "__ctype_b_loc",
        "strlen",
        "memcpy",
        "__ctype_get_mb_cur_max",
        "__errno_location",
        "strlen",
        "__ctype_b_loc",
        "mbrtowc",
        "wcwidth",
        "mbsinit",
        "wcwidth",
        "malloc",
        "malloc",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x4232e0",
        "0x4232cb",
        "0x4048e0",
        "0x1fff",
        "0x404760",
        "0x2000",
        "0x412790",
        "0x4046d0",
        "0x404ad0",
        "0x4232ca",
        "0x4048d0",
        "0x40e430",
        "0x4232c9",
        "0x4140a0",
        "0x404d50",
        "0x4048f0",
        "0x4000",
        "0x40c6a0",
        "0x404b30",
        "0x404910",
        "0x404d00"
      ],
      "snippets": {
        "asm": "  0x414230  endbr64 \n  0x414234  push    rbp {__saved_rbp}\n  0x414235  mov     r11, rdx\n  0x414238  mov     rbp, rsp {__saved_rbp}\n  0x41423b  push    r15 {__saved_r15}\n  0x41423d  mov     r15, rsi\n  0x414240  push    r14 {var_18}\n  0x414242  push    r13 {__saved_r13}\n  0x414244  push    r12 {__saved_r12}\n  0x414246  push    rbx {__saved_rbx}\n  0x414247  sub     rsp, 0x68\n  0x41424b  mov     qword [rbp-0x78 {var_80}], rdi\n  0x41424f  mov     r12, qword [rdi]\n  0x414252  mov     qword [rbp-0x70 {var_78}], r8\n  0x414256  mov     qword [rbp-0x80 {var_88}], r9\n  0x41425a  mov     rdx, qword [fs:0x28]\n  0x414263  mov     qword [rbp-0x38 {var_40}], rdx\n  0x414267  xor     edx, edx  {0x0}\n  0x414269  test    r11, r11\n  0x41426c  lea     rdx, [rel data_4232e0]\n  0x414273  cmove   r11, rdx  {data_4232e0}\n  0x414277  mov     ebx, dword [r11]\n  0x41427a  cmp     ebx, 0x2\n  0x41427d  setbe   r13b\n  0x414281  and     r13b, byte [rel data_4232cb]\n  0x414288  jne     0x414370\n  0x414370  test    ecx, ecx\n  0x414372  jne     0x41453c\n  0x41428e  test    ecx, ecx\n  0x414290  jne     0x414440\n  ... (1292 bytes total, truncated)",
        "hlil": "int32_t* r11 = arg3\nuint64_t var_18 = arg7\nchar* i_1 = *arg1\nvoid* fsbase\nint64_t rdx = *(fsbase + 0x28)\nif (r11 == 0)\nr11 = &data_4232e0\nint32_t rbx = *r11\nuint64_t r13\nr13.b = rbx u<= 2\nr13.b &= data_4232cb\nint32_t var_60\nchar rax_5\nuint64_t result\nif (r13.b == 0)\nif (arg4 != 0)\nvar_60 = 0\ngoto label_41444b\ni_1 = arg2\nresult = strlen(arg2)\nif (arg5 == 0)\nlabel_414310:\nif (data_4232ca == 0)\n*arg6 = 0\nlabel_414323:\nrax_5 = (r13.b ^ 1) & data_4232c9\nlabel_414332:\n*arg6 = rax_5\nif (arg5 != 0)\n*arg5 = arg7\nlabel_4142ab:\nif (__ctype_get_mb_cur_max() u> 1)\narg7 = sx.q(sub_4140a0(i_1, result))\nif (data_4232ca != 0)\ngoto label_414323\n*arg6 = 0\n*arg5 = arg7\nvoid* r15_1 = &i_1[result]\nif (i_1 u>= r15_1)\narg7 = 0\n// ... truncated",
        "pseudoc": "{\n    int32_t* r11 = arg3;\n    uint64_t var_18 = arg7;\n    char* i_1 = *(uint64_t*)arg1;\n    void* fsbase;\n    int64_t rdx = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (!r11)\n        r11 = &data_4232e0;\n    \n    int32_t rbx = *(uint32_t*)r11;\n    uint64_t r13;\n    (uint8_t)r13 = rbx <= 2;\n    (uint8_t)r13 &= data_4232cb;\n    int32_t var_60;\n    char rax_5;\n    uint64_t result;\n    \n    if (!(uint8_t)r13)\n    {\n        if (arg4)\n        {\n            var_60 = 0;\n            goto label_41444b;\n        }\n        \n        i_1 = arg2;\n        result = strlen(arg2);\n        \n        if (!arg5)\n        {\n        label_414310:\n            \n            if (!data_4232ca)\n                *(uint8_t*)arg6 = 0;\n            else\n            {\n            label_414323:\n                rax_5 = ((uint8_t)r13 ^ 1) & data_4232c9;\n            label_414332:\n                *(uint8_t*)arg6 = rax_5;\n                \n                if (arg5)\n                    *(uint64_t*)arg5 = arg7;\n            }\n        }\n        else\n        {\n        label_4142ab:\n            \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_validate_string_and_flag",
          "confidence": 0.68,
          "rationale": "The function uses strlen and ctype functions to examine a string, computes a flag based on global settings, and returns length/flag information. It is called by higher-level routines that handle string output, suggesting it validates or processes strings for configuration or output.",
          "evidence_refs": [
            "imports:strlen",
            "imports:__ctype_get_mb_cur_max",
            "imports:__ctype_b_loc",
            "imports:mbrtowc",
            "call:0x40b040",
            "call:0x40e910"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_string_check",
            "ai_process_string_flag"
          ]
        },
        "explain": {
          "summary": "sub_414230 processes an input string, computes its length, and determines a flag based on internal configuration and character properties. It may allocate a transformed copy of the string, store the length in an optional outparameter, and set a status byte indicating special handling (e.g., presence of multibyte or whitespace characters). The function is used by higherlevel routines for formatting output and memory management.",
          "details": [
            "If the third argument is null, a default data pointer is used; a flag is derived from a global mask (data_4232cb) and a comparison against a small integer.",
            "When arg4 is false, the function calls strlen on the provided string (arg2) to obtain its length, optionally storing it via arg5 and setting a status byte via arg6 based on global flags (data_4232ca, data_4232c9).",
            "The function imports and likely uses __ctype_get_mb_cur_max, __ctype_b_loc, and mbrtowc, indicating handling of multibyte character classification and conversion.",
            "Higherlevel callers (sub_40b040, sub_40e910) receive a pointer to a possibly allocated buffer, a length value, and a flag, and they free the buffer if it was allocated."
          ],
          "evidence_refs": [
            "imports:strlen",
            "imports:__ctype_get_mb_cur_max",
            "imports:__ctype_b_loc",
            "imports:mbrtowc",
            "call:0x4048e0"
          ],
          "unknowns": [
            "Exact semantics of arg4 and the meaning of the flag stored at arg6",
            "Precise conditions under which a new buffer is allocated versus using the original string",
            "The role of data_4232e0, data_4232ca, data_4232c9 in controlling behavior"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x414780",
      "original_name": "sub_414780",
      "final_name": "ai_custom_strftime",
      "score": 453.0,
      "bb_count": 429,
      "insn_est": 1831,
      "callers": 5,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4046f0",
          "name": "ai_get_toupper_locale",
          "original_name": "__ctype_toupper_loc"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x404c00",
          "name": "ai_format_timestamp",
          "original_name": "strftime"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4046f0",
          "name": "ai_get_toupper_locale",
          "original_name": "__ctype_toupper_loc"
        },
        {
          "addr": "0x414780",
          "name": "ai_custom_strftime",
          "original_name": "sub_414780"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x414780",
          "name": "ai_custom_strftime",
          "original_name": "sub_414780"
        },
        {
          "addr": "0x4046f0",
          "name": "ai_get_toupper_locale",
          "original_name": "__ctype_toupper_loc"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4046f0",
          "name": "ai_get_toupper_locale",
          "original_name": "__ctype_toupper_loc"
        },
        {
          "addr": "0x40e1f0",
          "name": "ai_manage_timezone_env",
          "original_name": "sub_40e1f0"
        },
        {
          "addr": "0x404b70",
          "name": "ai_mktime_wrapper",
          "original_name": "mktime"
        },
        {
          "addr": "0x40e300",
          "name": "ai_set_tz_env_and_cleanup",
          "original_name": "sub_40e300"
        },
        {
          "addr": "0x4046f0",
          "name": "ai_get_toupper_locale",
          "original_name": "__ctype_toupper_loc"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x404d40",
          "name": "ai_get_locale_tolower_table",
          "original_name": "__ctype_tolower_loc"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x414780",
          "name": "ai_custom_strftime",
          "original_name": "sub_414780"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x40e0c0",
          "name": "ai_add_string_to_list",
          "original_name": "sub_40e0c0"
        },
        {
          "addr": "0x40e300",
          "name": "ai_set_tz_env_and_cleanup",
          "original_name": "sub_40e300"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x404d40",
          "name": "ai_get_locale_tolower_table",
          "original_name": "__ctype_tolower_loc"
        },
        {
          "addr": "0x404bf0",
          "name": "ai_utc_timestamp_from_tm",
          "original_name": "timegm"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x40e300",
          "name": "ai_set_tz_env_and_cleanup",
          "original_name": "sub_40e300"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4049c0",
          "name": "ai_memset_wrapper",
          "original_name": "memset"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__errno_location",
        "memset",
        "memset",
        "__ctype_toupper_loc",
        "memcpy",
        "strftime",
        "memset",
        "__ctype_toupper_loc",
        "memset",
        "__ctype_toupper_loc",
        "memset",
        "strlen",
        "memset",
        "__ctype_toupper_loc",
        "mktime",
        "__ctype_toupper_loc",
        "memset",
        "memset",
        "memset",
        "memcpy",
        "memset",
        "memcpy",
        "__ctype_tolower_loc",
        "memset",
        "memset",
        "memset",
        "memset",
        "memset",
        "memcpy",
        "__ctype_tolower_loc",
        "timegm",
        "memset",
        "memset",
        "memset",
        "memset",
        "memset",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "%m/%d/%y",
        "%Y-%m-%d",
        "%H:%M:%S"
      ],
      "constants": [
        "0x518",
        "0xfffffffffffffb38",
        "0xfffffffffffffb28",
        "0xfffffffffffffb1c",
        "0xfffffffffffffb20",
        "0xfffffffffffffb33",
        "0x404760",
        "0x41af54",
        "0xfffffffffffffb34",
        "0xfffffffffffffb10",
        "0xfffffffffffffb18",
        "0xfffffffffffffb08",
        "0x1000000000002500",
        "0x4048f0",
        "0x41df4c",
        "0xfffffffffffffb00",
        "0xfffffffffffffaf0",
        "0x4048e0",
        "0xfffffffffffffb50",
        "0xfffffffffffffb70",
        "0xfffffffffffffb5c",
        "0xffffffff",
        "0xfffffffffffffb40",
        "0xfffffffffffffb60",
        "0xffffffff92492493",
        "0x41b578",
        "0x41b196",
        "0x4049c0",
        "0xfffffffffffffbbc",
        "0xfffffffffffffbbd"
      ],
      "snippets": {
        "asm": "  0x414780  endbr64 \n  0x414784  push    rbp {__saved_rbp}\n  0x414785  mov     rbp, rsp {__saved_rbp}\n  0x414788  push    r15 {__saved_r15}\n  0x41478a  mov     r15, rdi\n  0x41478d  push    r14 {__saved_r14}\n  0x41478f  mov     r14, rcx\n  0x414792  push    r13 {__saved_r13}\n  0x414794  push    r12 {__saved_r12}\n  0x414796  mov     r12, rdx\n  0x414799  push    rbx {__saved_rbx}\n  0x41479a  sub     rsp, 0x518\n  0x4147a1  mov     rax, qword [rbp+0x18 {arg8}]\n  0x4147a5  mov     qword [rbp-0x4c8 {var_4d0}], rsi\n  0x4147ac  mov     qword [rbp-0x4d8 {var_4e0}], rcx\n  0x4147b3  mov     dword [rbp-0x4e4 {var_4ec}], r9d\n  0x4147ba  mov     qword [rbp-0x4e0 {var_4e8}], rax\n  0x4147c1  mov     byte [rbp-0x4cd {var_4d5}], r8b\n  0x4147c8  mov     rax, qword [fs:0x28]\n  0x4147d1  mov     qword [rbp-0x38 {var_40}], rax\n  0x4147d5  xor     eax, eax  {0x0}\n  0x4147d7  call    __errno_location\n  0x4147dc  mov     rsi, qword [r14+0x30 {tm::tm_zone}]\n  0x4147e0  mov     edi, dword [r14+0x8 {tm::tm_hour}]\n  0x4147e4  mov     r13d, dword [rax]\n  0x4147e7  mov     rbx, rax\n  0x4147ea  lea     rax, [rel data_41af54]\n  0x4147f1  mov     r10d, dword [rbp+0x10 {arg7}]\n  0x4147f5  test    rsi, rsi\n  0x4147f8  mov     dword [rbp-0x4cc {var_4d4}], edi\n  ... (8423 bytes total, truncated)",
        "hlil": "char* r15 = arg1\nvoid* fsbase\nint64_t rax_1 = *(fsbase + 0x28)\nint32_t* rax_3 = __errno_location()\nchar* tm_zone = arg4->tm_zone\nuint64_t i_12 = zx.q(arg4->tm_hour)\nint32_t r13 = *rax_3\nchar* tm_zone_1 = &data_41af54\nint32_t var_4d4 = i_12.d\nif (tm_zone != 0)\ntm_zone_1 = tm_zone\nint32_t var_4d4_1\nif (i_12.d s<= 0xc)\nint32_t rax_12 = 0xc\nif (var_4d4 != 0)\nrax_12 = var_4d4\nvar_4d4_1 = rax_12\nvar_4d4_1 = i_12.d - 0xc\nchar rax_4 = *arg3\nint64_t result = 0\nif (rax_4 != 0)\nchar* r8 = arg3\nint64_t r13_1 = sx.q(arg7)\nint64_t result_1 = 0\nwhile (true)\nchar var_500\nchar* r14_2\nif (rax_4 != 0x25)\nint64_t rax_5 = 0\nint64_t r14_1 = 1\nif (r13_1.d s>= 0)\nrax_5 = r13_1\nif (rax_5 != 0)\nr14_1 = rax_5\nif (r14_1 u>= arg2 - result_1)\nlabel_4148e0:\n*rax_3 = 0x22\nresult = 0\ngoto label_4148ed\nif (r15 != 0)\n// ... truncated",
        "pseudoc": "{\n    char* r15 = arg1;\n    void* fsbase;\n    int64_t rax_1 = *(uint64_t*)((char*)fsbase + 0x28);\n    int32_t* rax_3 = __errno_location();\n    char* tm_zone = arg4->tm_zone;\n    uint64_t i_12 = (uint64_t)arg4->tm_hour;\n    int32_t r13 = *(uint32_t*)rax_3;\n    char* tm_zone_1 = &data_41af54;\n    int32_t var_4d4 = (uint32_t)i_12;\n    \n    if (tm_zone)\n        tm_zone_1 = tm_zone;\n    \n    int32_t var_4d4_1;\n    \n    if ((int32_t)i_12 <= 0xc)\n    {\n        int32_t rax_12 = 0xc;\n        \n        if (var_4d4)\n            rax_12 = var_4d4;\n        \n        var_4d4_1 = rax_12;\n    }\n    else\n        var_4d4_1 = (uint32_t)i_12 - 0xc;\n    \n    char rax_4 = *(uint8_t*)arg3;\n    int64_t result = 0;\n    \n    if (rax_4)\n    {\n        char* r8 = arg3;\n        int64_t r13_1 = (int64_t)arg7;\n        int64_t result_1 = 0;\n        \n        while (true)\n        {\n            char var_500;\n            char* r14_2;\n            \n            if (rax_4 != 0x25)\n            {\n                int64_t rax_5 = 0;\n                int64_t r14_1 = 1;\n                \n                if ((int32_t)r13_1 >= 0)\n                    rax_5 = r13_1;\n                \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_custom_strftime",
          "confidence": 0.86,
          "rationale": "The function processes a format string with '%' tokens and uses time struct fields (tm_hour, tm_zone) along with date format literals like \"%m/%d/%y\", \"%Y-%m-%d\", \"%H:%M:%S\", indicating it implements custom date/time formatting similar to strftime.",
          "evidence_refs": [
            "strings:%m/%d/%y",
            "strings:%Y-%m-%d",
            "strings:%H:%M:%S",
            "imports:__errno_location",
            "imports:memset",
            "imports:memcpy",
            "imports:__ctype_toupper_loc"
          ],
          "tags": [],
          "alt_names": [
            "ai_timestamp_formatter",
            "ai_format_time_string"
          ]
        },
        "explain": {
          "summary": "The function implements a custom date/time formatting routine similar to strftime, formatting a struct tm into a string based on a format pattern.",
          "details": [
            "It reads the tm_zone field from a struct tm and falls back to a default string if none is provided.",
            "It computes a 12hour adjustment for the hour field (tm_hour) and stores it in a local variable.",
            "It iterates over a format string (arg3), handling '%' specifiers and using helper functions like memset, memcpy, and __ctype_toupper_loc to build the output buffer (arg1).",
            "The presence of format strings '%m/%d/%y', '%Y-%m-%d', and '%H:%M:%S' indicates support for common date and time placeholders."
          ],
          "evidence_refs": [
            "strings:'%m/%d/%y'",
            "strings:'%Y-%m-%d'",
            "strings:'%H:%M:%S'",
            "imports:__errno_location",
            "imports:memset",
            "imports:__ctype_toupper_loc",
            "imports:memcpy",
            "call:0x404760",
            "call:0x4049c0"
          ],
          "unknowns": [
            "Exact handling of all format specifiers beyond those hinted at in the snippet.",
            "Purpose and usage of the arg7 parameter.",
            "Full control flow after the truncated loop."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x4168e0",
      "original_name": "sub_4168e0",
      "final_name": "ai_compute_bucket_capacity",
      "score": 80.2,
      "bb_count": 22,
      "insn_est": 89,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        }
      ],
      "import_refs": [
        "__errno_location"
      ],
      "string_refs": [],
      "constants": [
        "0xaaaaaaaaaaaaaaab",
        "0x419014",
        "0x5f800000",
        "0x404760",
        "0x419018",
        "0x5f000000",
        "0x8000000000000000"
      ],
      "snippets": {
        "asm": "  0x4168e0  endbr64 \n  0x4168e4  test    sil, sil\n  0x4168e7  jne     0x416930\n  0x416930  mov     r9, 0xaaaaaaaaaaaaaaab\n  0x41693a  mov     eax, 0xa\n  0x41693f  cmp     rdi, rax\n  0x416942  cmovae  rax, rdi\n  0x416946  mov     rsi, rax\n  0x416949  or      rsi, 0x1\n  0x41694d  cmp     rsi, 0xffffffffffffffff\n  0x416951  je      0x4169c4\n  0x4168e9  test    rdi, rdi\n  0x4168ec  js      0x4169e1\n  0x4169c4  mov     rax, rsi\n  0x4169c7  shr     rax, 0x3d\n  0x4169cb  setne   al\n  0x4169ce  bt      rsi, 0x3c\n  0x4169d3  movzx   eax, al\n  0x4169d6  jb      0x416a0b\n  0x416953  nop     dword [rax+rax]\n  0x4169e1  mov     rax, rdi\n  0x4169e4  and     edi, 0x1\n  0x4169e7  pxor    xmm1, xmm1\n  0x4169eb  shr     rax, 0x1\n  0x4169ee  or      rax, rdi\n  0x4169f1  cvtsi2ss xmm1, rax\n  0x4169f6  addss   xmm1, xmm1\n  0x4169fa  divss   xmm1, xmm0\n  0x4169fe  comiss  xmm1, dword [rel data_419014]\n  0x416a05  jb      0x41690c\n  ... (336 bytes total, truncated)",
        "hlil": "if (arg2 != 0)\ngoto label_41693a\nint32_t zmm1\nif (arg1 s< 0)\nzmm1 = float.s(arg1 u>> 1 | (zx.q(arg1.d) & 1))\nzmm1 = (zmm1 f+ zmm1) f/ arg3\nif (zmm1 f< 1.84467441e+19f)\nlabel_41690c:\nif (not(zmm1 f< 9.22337204e+18f))\narg1 = int.q(zmm1 f- 9.22337204e+18f) ^ 0x8000000000000000\ngoto label_41693a\narg1 = int.q(zmm1)\nlabel_41693a:\nint64_t rax_1 = 0xa\nif (arg1 u>= 0xa)\nrax_1 = arg1\nint64_t result = rax_1 | 1\nif (result != -1)\nwhile (true)\nint64_t rax_3\nint64_t rdx_1\nrdx_1:rax_3 = mulu.dp.q(result, -0x5555555555555555)\nint64_t rax_7 = result - ((rdx_1 & 0xfffffffffffffffe) + result u/ 3)\nif (result u<= 9)\nif (rax_7 != 0)\nbreak\nresult += 2\nif (rax_7 != 0)\nint64_t r8_1 = 0x10\nint64_t rdi_1 = 9\nint64_t rcx_1 = 3\nuint64_t temp1_1\nwhile (true)\nrcx_1 += 2\nrdi_1 += r8_1\ntemp1_1 = modu.dp.q(0:result, rcx_1)\nif (rdi_1 u>= result)\nbreak\nr8_1 += 8\nif (temp1_1 == 0)\n// ... truncated",
        "pseudoc": "{\n    if (arg2)\n        goto label_41693a;\n    \n    int32_t zmm1;\n    \n    if (arg1 < 0)\n    {\n        zmm1 = (float)(arg1 >> 1 | ((uint64_t)(uint32_t)arg1 & 1));\n        zmm1 = (zmm1 + zmm1) / arg3;\n        \n        if (zmm1 < 1.84467441e+19f)\n        {\n        label_41690c:\n            \n            if (!(zmm1 < 9.22337204e+18f))\n            {\n                arg1 = (int64_t)(zmm1 - 9.22337204e+18f) ^ 0x8000000000000000;\n                goto label_41693a;\n            }\n            \n            arg1 = (int64_t)zmm1;\n        label_41693a:\n            int64_t rax_1 = 0xa;\n            \n            if (arg1 >= 0xa)\n                rax_1 = arg1;\n            \n            int64_t result = rax_1 | 1;\n            \n            if (result != -1)\n            {\n                while (true)\n                {\n                    int64_t rax_3;\n                    int64_t rdx_1;\n                    rdx_1 = HIGHQ(result * -0x5555555555555555);\n                    rax_3 = LOWQ(result * -0x5555555555555555);\n                    int64_t rax_7 = result - ((rdx_1 & 0xfffffffffffffffe) + result / 3);\n                    \n                    if (result <= 9)\n                    {\n                        if (rax_7)\n                            break;\n                        \n                        result += 2;\n                    }\n                    else\n                    {\n                        if (rax_7)\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_compute_bucket_capacity",
          "confidence": 0.78,
          "rationale": "The function calculates a size/count based on input values, using floating-point scaling and magic constants for division, and is used by callers to determine allocation sizes for data structures, suggesting it computes a bucket or table capacity.",
          "evidence_refs": [
            "constants:0xaaaaaaaaaaaaaaab",
            "constants:0x5f800000",
            "constants:0x5f000000",
            "constants:0x8000000000000000",
            "call:0x404760"
          ],
          "tags": [],
          "alt_names": [
            "ai_calc_table_capacity",
            "ai_compute_allocation_size"
          ]
        },
        "explain": {
          "summary": "sub_4168e0 computes a suitable allocation count (nmemb) based on input parameters, scaling and rounding the requested size, then adjusting it to an odd number and iteratively finding a value that satisfies certain divisibility constraints (likely a prime or nonmultiple of small factors) for hashtable sizing.",
          "details": [
            "If arg2 is zero, the function derives a floatingpoint estimate from arg1 and arg3, handling negative arg1 specially, then clamps the result within 64bit limits.",
            "The resulting integer is forced to be at least 10, made odd (|1), and then a loop uses magicnumber multiplication (0x5555555555555555) to test divisibility, incrementing by 2 until a suitable value is found.",
            "The final value is returned and used by callers (e.g., sub_416a40, sub_40b590) to allocate memory for data structures such as hash tables."
          ],
          "evidence_refs": [
            "imports:__errno_location",
            "call:0x404760",
            "strings:none"
          ],
          "unknowns": [
            "Exact role of arg2 flag and why it bypasses the floatingpoint path",
            "Full termination condition of the loop (full primality test not fully visible)",
            "Precise mathematical meaning of the magic constants beyond division by 3 approximation"
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": []
    },
    {
      "addr": "0x416a40",
      "original_name": "sub_416a40",
      "final_name": "ai_initialize_object_pool",
      "score": 78.1,
      "bb_count": 9,
      "insn_est": 62,
      "callers": 2,
      "callees": [
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x40c7b0",
          "name": "ai_validate_float_bounds",
          "original_name": "sub_40c7b0"
        },
        {
          "addr": "0x4168e0",
          "name": "ai_compute_bucket_capacity",
          "original_name": "sub_4168e0"
        },
        {
          "addr": "0x404a50",
          "name": "ai_calloc_wrapper",
          "original_name": "calloc"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        }
      ],
      "import_refs": [
        "malloc",
        "calloc",
        "__errno_location",
        "free"
      ],
      "string_refs": [],
      "constants": [
        "0x4046d0",
        "0x419600",
        "0x40c7b0",
        "0x404760",
        "0x419020",
        "0x3f4ccccd",
        "0x4168e0",
        "0x4046b0",
        "0x404a50"
      ],
      "snippets": {
        "asm": "  0x416a40  endbr64 \n  0x416a44  push    rbp {__saved_rbp}\n  0x416a45  mov     rbp, rsp {__saved_rbp}\n  0x416a48  push    r15 {__saved_r15}\n  0x416a4a  mov     r15, rsi\n  0x416a4d  push    r14 {__saved_r14}\n  0x416a4f  mov     r14, rdx\n  0x416a52  push    r13 {__saved_r13}\n  0x416a54  mov     r13, rcx\n  0x416a57  push    r12 {__saved_r12}\n  0x416a59  mov     r12, rdi\n  0x416a5c  mov     edi, 0x50\n  0x416a61  push    rbx {__saved_rbx}\n  0x416a62  sub     rsp, 0x8\n  0x416a66  call    malloc\n  0x416a6b  test    rax, rax\n  0x416a6e  je      0x416b13\n  0x416b13  xor     ebx, ebx  {0x0}\n  0x416b15  jmp     0x416ae8\n  0x416a74  mov     rbx, rax\n  0x416a77  lea     rax, [rel data_419600]\n  0x416a7e  mov     qword [rbx+0x28], rax  {data_419600}\n  0x416a82  mov     rdi, rbx\n  0x416a85  call    sub_40c7b0\n  0x416a8a  test    al, al\n  0x416a8c  je      0x416b00\n  0x416ae8  add     rsp, 0x8\n  0x416aec  mov     rax, rbx\n  0x416aef  pop     rbx {__saved_rbx}\n  0x416af0  pop     r12 {__saved_r12}\n  ... (209 bytes total, truncated)",
        "hlil": "int64_t* result = malloc(0x50)\nif (result != 0)\nresult[5] = &data_419600\nif (sub_40c7b0(result) == 0)\n*__errno_location() = 0x16\nsize_t nmemb = sub_4168e0(arg1, 0, 0.800000012f)\nresult[2] = nmemb\nif (nmemb != 0)\nint64_t rax_1 = calloc(nmemb, 0x10)\n*result = rax_1\nif (rax_1 != 0)\nresult[6] = arg2\nresult[7] = arg3\nresult[1] = rax_1 + (nmemb << 4)\nresult[8] = arg4\nresult[9] = 0\n*(result + 0x18) = zx.o(0)\nreturn result\nfree(result)\nreturn nullptr",
        "pseudoc": "{\n    int64_t* result = malloc(0x50);\n    \n    if (result)\n    {\n        result[5] = &data_419600;\n        \n        if (!sub_40c7b0(result))\n            *(uint32_t*)__errno_location() = 0x16;\n        else\n        {\n            size_t nmemb = sub_4168e0(arg1, 0, 0.800000012f);\n            result[2] = nmemb;\n            \n            if (nmemb)\n            {\n                int64_t rax_1 = calloc(nmemb, 0x10);\n                *(uint64_t*)result = rax_1;\n                \n                if (rax_1)\n                {\n                    result[6] = arg2;\n                    result[7] = arg3;\n                    result[1] = rax_1 + (nmemb << 4);\n                    result[8] = arg4;\n                    result[9] = 0;\n                    *(uint128_t*)((char*)result + 0x18) = {0};\n                    return result;\n                }\n            }\n        }\n        \n        free(result);\n    }\n    \n    return nullptr;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_initialize_object_pool",
          "confidence": 0.78,
          "rationale": "The function allocates a struct, validates input via sub_40c7b0, computes element count with sub_4168e0, allocates a buffer with calloc, and initializes fields, typical of an object pool or buffer initialization routine.",
          "evidence_refs": [
            "imports:malloc",
            "imports:calloc",
            "imports:free",
            "imports:__errno_location",
            "call:0x40c7b0",
            "call:0x4168e0"
          ],
          "tags": [
            "config"
          ],
          "alt_names": [
            "ai_alloc_and_init",
            "ai_create_buffer_struct"
          ]
        },
        "explain": {
          "summary": "sub_416a40 allocates and initializes a custom data structure. It first allocates a 0x50byte block, validates it with sub_40c7b0, computes an element count via sub_4168e0, allocates a buffer of that many 16byte entries with calloc, stores several arguments into the structure, and returns the pointer. On any failure it sets errno to 0x16, frees allocated memory, and returns nullptr.",
          "details": [
            "Allocates a 0x50byte struct with malloc and stores a sentinel pointer (&data_419600) at offset 0x28.",
            "Calls sub_40c7b0 to validate the struct; on failure sets errno (0x16) and frees the struct.",
            "Computes a count (nmemb) using sub_4168e0 with arguments arg1 and a float constant 0.8, stores it at offset 0x10.",
            "If nmemb > 0, allocates nmemb * 0x10 bytes with calloc, stores the buffer pointer, calculates the end pointer, and records arg2arg4 in subsequent fields.",
            "Initializes additional fields to zero and returns the initialized structure; otherwise frees resources and returns nullptr."
          ],
          "evidence_refs": [
            "imports:malloc",
            "imports:calloc",
            "imports:free",
            "imports:__errno_location",
            "call:0x40c7b0",
            "call:0x4168e0"
          ],
          "unknowns": [
            "Exact semantic meaning of the stored sentinel &data_419600",
            "Purpose of the arguments arg1arg4 and the overall structure",
            "Detailed behavior of sub_4168e0 beyond the count calculation"
          ],
          "confidence": 0.93
        }
      },
      "is_boring": false,
      "tags": [
        "config"
      ]
    },
    {
      "addr": "0x416b20",
      "original_name": "sub_416b20",
      "final_name": "ai_resolve_path",
      "score": 430.3,
      "bb_count": 109,
      "insn_est": 491,
      "callers": 2,
      "callees": [
        {
          "addr": "0x404750",
          "name": "ai_fatal_abort",
          "original_name": "abort"
        },
        {
          "addr": "0x4049e0",
          "name": "ai_get_current_working_directory",
          "original_name": "getcwd"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x40c560",
          "name": "ai_buffer_grow",
          "original_name": "sub_40c560"
        },
        {
          "addr": "0x40c840",
          "name": "ai_cleanup_linked_structure",
          "original_name": "sub_40c840"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404aa0",
          "name": "ai_safe_memory_copy",
          "original_name": "__memcpy_chk"
        },
        {
          "addr": "0x40c5e0",
          "name": "ai_expand_buffer",
          "original_name": "sub_40c5e0"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404c10",
          "name": "ai_memcpy_wrapper",
          "original_name": "mempcpy"
        },
        {
          "addr": "0x404830",
          "name": "ai_readlink_wrapper",
          "original_name": "readlink"
        },
        {
          "addr": "0x40c560",
          "name": "ai_buffer_grow",
          "original_name": "sub_40c560"
        },
        {
          "addr": "0x404a40",
          "name": "ai_memory_byte_search",
          "original_name": "rawmemchr"
        },
        {
          "addr": "0x404ac0",
          "name": "ai_file_stat",
          "original_name": "stat"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x40c5e0",
          "name": "ai_expand_buffer",
          "original_name": "sub_40c5e0"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404c20",
          "name": "ai_memmove_wrapper",
          "original_name": "memmove"
        },
        {
          "addr": "0x404ad0",
          "name": "ai_copy_memory",
          "original_name": "memcpy"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x410b30",
          "name": "ai_strdup",
          "original_name": "sub_410b30"
        },
        {
          "addr": "0x40c940",
          "name": "ai_safe_malloc",
          "original_name": "sub_40c940"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x416a40",
          "name": "ai_initialize_object_pool",
          "original_name": "sub_416a40"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        },
        {
          "addr": "0x40c840",
          "name": "ai_cleanup_linked_structure",
          "original_name": "sub_40c840"
        }
      ],
      "import_refs": [
        "abort",
        "getcwd",
        "__errno_location",
        "free",
        "free",
        "malloc",
        "__memcpy_chk",
        "__errno_location",
        "free",
        "__errno_location",
        "mempcpy",
        "readlink",
        "rawmemchr",
        "stat",
        "strlen",
        "strlen",
        "memmove",
        "memcpy",
        "malloc",
        "free",
        "free",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0xfffffffffffff7b0",
        "0xfffffffffffffbc0",
        "0xfffffffffffff3a0",
        "0xd58",
        "0xfffffffffffff390",
        "0xfffffffffffff398",
        "0x400",
        "0xfffffffffffff7a0",
        "0xfffffffffffff7a8",
        "0xfffffffffffffbb0",
        "0xfffffffffffffbb8",
        "0x404760",
        "0x4046b0",
        "0xfffffffffffff3a1",
        "0x4049e0",
        "0x4048f0",
        "0xfffffffffffff2d8",
        "0x404a40",
        "0xfffffffffffff2c0",
        "0xfffffffffffff2c8",
        "0xfffffffffffff2a4",
        "0xfffffffffffff2b0",
        "0xfffffffffffff2b8",
        "0xfffffffffffff2a8",
        "0x40e430",
        "0x4046d0",
        "0x40c560",
        "0x404aa0",
        "0x40c840",
        "0xfffffffffffff2d0"
      ],
      "snippets": {
        "asm": "  0x416b20  endbr64 \n  0x416b24  push    rbp {__saved_rbp}\n  0x416b25  mov     rbp, rsp {__saved_rbp}\n  0x416b28  push    r15 {__saved_r15}\n  0x416b2a  push    r14 {__saved_r14}\n  0x416b2c  lea     r14, [rbp-0x850 {var_858}]\n  0x416b33  push    r13 {__saved_r13}\n  0x416b35  lea     r13, [rbp-0x440 {var_448}]\n  0x416b3c  push    r12 {__saved_r12}\n  0x416b3e  lea     r12, [rbp-0xc60 {var_c68}]\n  0x416b45  push    rbx {__saved_rbx}\n  0x416b46  sub     rsp, 0xd58\n  0x416b4d  mov     rax, qword [fs:0x28]\n  0x416b56  mov     qword [rbp-0x38 {var_40}], rax\n  0x416b5a  xor     eax, eax  {0x0}\n  0x416b5c  mov     qword [rbp-0xc70 {buf_1}], r12 {var_c68}\n  0x416b63  mov     qword [rbp-0xc68 {size_1}], 0x400\n  0x416b6e  mov     qword [rbp-0x860 {var_868}], r14 {var_858}\n  0x416b75  mov     qword [rbp-0x858 {var_860}], 0x400\n  0x416b80  mov     qword [rbp-0x450 {var_458}], r13 {var_448}\n  0x416b87  mov     qword [rbp-0x448 {var_450}], 0x400\n  0x416b92  test    rdi, rdi\n  0x416b95  je      0x416e80\n  0x416e80  call    __errno_location\n  0x416e85  mov     dword [rax], 0x16\n  0x416e8b  jmp     0x416e43\n  0x416b9b  movzx   eax, byte [rdi]\n  0x416b9e  mov     r9, rdi\n  0x416ba1  test    al, al\n  0x416ba3  je      0x416e38\n  ... (2380 bytes total, truncated)",
        "hlil": "void var_858\nvoid* r14 = &var_858\nvoid var_448\nvoid* r13 = &var_448\nchar var_c68\nchar* r12 = &var_c68\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nchar* buf_1 = &var_c68\nuint64_t size_1 = 0x400\nvoid* var_868 = &var_858\nint64_t var_860 = 0x400\nvoid* var_458 = &var_448\nint64_t var_450 = 0x400\nint64_t result\nif (arg1 == 0)\n*__errno_location() = 0x16\nresult = 0\nchar i_1 = *arg1\nchar* r9_1 = arg1\nif (i_1 == 0)\n*__errno_location() = 2\nresult = 0\nuint64_t size = 0x400\nchar* buf = &var_c68\nchar* r10_1\nif (i_1 == 0x2f)\nvar_c68 = 0x2f\nvoid var_c67\nr10_1 = &var_c67\nlabel_416c4e:\nchar var_d48_1 = 0\nint64_t* var_d40_1 = nullptr\nint32_t var_d64_1 = 0\nvoid* var_d58_1 = &var_858\nchar* var_d50_1 = &var_c68\nchar* r12_1 = r9_1\nvoid* var_d60_1 = &var_448\nchar* buf_2 = buf\nwhile (true)\n// ... truncated",
        "pseudoc": "{\n    void var_858;\n    void* r14 = &var_858;\n    void var_448;\n    void* r13 = &var_448;\n    char var_c68;\n    char* r12 = &var_c68;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    char* buf_1 = &var_c68;\n    uint64_t size_1 = 0x400;\n    void* var_868 = &var_858;\n    int64_t var_860 = 0x400;\n    void* var_458 = &var_448;\n    int64_t var_450 = 0x400;\n    int64_t result;\n    \n    if (!arg1)\n    {\n        *(uint32_t*)__errno_location() = 0x16;\n        result = 0;\n    }\n    else\n    {\n        char i_1 = *(uint8_t*)arg1;\n        char* r9_1 = arg1;\n        \n        if (!i_1)\n        {\n            *(uint32_t*)__errno_location() = 2;\n            result = 0;\n        }\n        else\n        {\n            uint64_t size = 0x400;\n            char* buf = &var_c68;\n            char* r10_1;\n            \n            if (i_1 == 0x2f)\n            {\n                var_c68 = 0x2f;\n                void var_c67;\n                r10_1 = &var_c67;\n            label_416c4e:\n                char var_d48_1 = 0;\n                int64_t* var_d40_1 = nullptr;\n                int32_t var_d64_1 = 0;\n                void* var_d58_1 = &var_858;\n                char* var_d50_1 = &var_c68;\n                char* r12_1 = r9_1;\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_resolve_path",
          "confidence": 0.86,
          "rationale": "The function validates a path argument, checks for null or empty strings, distinguishes absolute paths (starting with '/') and likely builds a canonical absolute path using buffers of size 0x400, calling getcwd for relative paths and setting errno on errors, matching typical realpath/canonicalize behavior.",
          "evidence_refs": [
            "imports:getcwd",
            "imports:__errno_location",
            "imports:malloc",
            "imports:free"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_realpath",
            "ai_canonicalize_path"
          ]
        },
        "explain": {
          "summary": "sub_416b20 validates a pathname argument, sets appropriate errno values for null or empty inputs, and builds a normalized absolute path using a 0x400byte buffer. It distinguishes absolute paths (starting with '/') from relative ones, uses getcwd for the latter, and employs dynamic allocation and safe copying to assemble the final path.",
          "details": [
            "If arg1 is NULL, errno is set to 0x16 (EINVAL) and the function returns 0.",
            "If the first byte of arg1 is zero, errno is set to 2 (ENOENT) and the function returns 0.",
            "When the path starts with '/', the function initializes a buffer with '/' and proceeds to canonicalize the path.",
            "For relative paths, it likely calls getcwd to obtain the current working directory and prepends it to the supplied path.",
            "Memory for temporary buffers is allocated with malloc/realloc and freed with free; copies are performed with __memcpy_chk for safety.",
            "The function may abort on unrecoverable errors via the imported abort routine."
          ],
          "evidence_refs": [
            "imports:abort",
            "imports:getcwd",
            "imports:__errno_location",
            "imports:malloc",
            "imports:free",
            "imports:__memcpy_chk",
            "call:0x404750",
            "call:0x4049e0",
            "call:0x404760"
          ],
          "unknowns": [
            "Exact handling of symbolic links or path components beyond the initial checks",
            "The final return value and how the constructed path is delivered to the caller",
            "Whether additional helper functions are invoked for further normalization"
          ],
          "confidence": 0.73
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x417490",
      "original_name": "sub_417490",
      "final_name": "ai_collect_file_acl_info",
      "score": 463.0,
      "bb_count": 306,
      "insn_est": 1186,
      "callers": 3,
      "callees": [
        {
          "addr": "0x4248e8"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40b910",
          "name": "ai_compute_file_mode_flags",
          "original_name": "sub_40b910"
        },
        {
          "addr": "0x40b910",
          "name": "ai_compute_file_mode_flags",
          "original_name": "sub_40b910"
        },
        {
          "addr": "0x40b9e0",
          "name": "ai_collect_file_metadata",
          "original_name": "sub_40b9e0"
        },
        {
          "addr": "0x410b30",
          "name": "ai_strdup",
          "original_name": "sub_410b30"
        },
        {
          "addr": "0x40b9e0",
          "name": "ai_collect_file_metadata",
          "original_name": "sub_40b9e0"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x40cb80",
          "name": "ai_locale_number_format",
          "original_name": "sub_40cb80"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x416b20",
          "name": "ai_resolve_path",
          "original_name": "sub_416b20"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x404ce0",
          "name": "ai_get_file_security_context",
          "original_name": "getfilecon"
        },
        {
          "addr": "0x40e040",
          "name": "ai_cleanup_unlabeled_label",
          "original_name": "sub_40e040"
        },
        {
          "addr": "0x4046c0",
          "name": "ai_strcmp_wrapper",
          "original_name": "strcmp"
        },
        {
          "addr": "0x404a60",
          "name": "ai_readlink_check",
          "original_name": "__readlink_chk"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x404d10",
          "name": "ai_get_file_security_context",
          "original_name": "lgetfilecon"
        },
        {
          "addr": "0x40e040",
          "name": "ai_cleanup_unlabeled_label",
          "original_name": "sub_40e040"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4047f0",
          "name": "ai_reallocarray_wrapper",
          "original_name": "reallocarray"
        },
        {
          "addr": "0x40bcc0",
          "name": "ai_validate_string_prefix_length",
          "original_name": "sub_40bcc0"
        },
        {
          "addr": "0x40cb80",
          "name": "ai_locale_number_format",
          "original_name": "sub_40cb80"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        },
        {
          "addr": "0x410b30",
          "name": "ai_strdup",
          "original_name": "sub_410b30"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4048b0",
          "name": "ai_list_extended_attributes",
          "original_name": "listxattr"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x4048b0",
          "name": "ai_list_extended_attributes",
          "original_name": "listxattr"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404c80",
          "name": "ai_get_extended_attribute",
          "original_name": "getxattr"
        },
        {
          "addr": "0x40e430",
          "name": "ai_memory_exhausted_abort",
          "original_name": "sub_40e430"
        },
        {
          "addr": "0x40f580",
          "name": "ai_resolve_uid_to_name",
          "original_name": "sub_40f580"
        },
        {
          "addr": "0x404720",
          "name": "ai_safe_snprintf_wrapper",
          "original_name": "__snprintf_chk"
        },
        {
          "addr": "0x40f580",
          "name": "ai_resolve_uid_to_name",
          "original_name": "sub_40f580"
        },
        {
          "addr": "0x40b9e0",
          "name": "ai_collect_file_metadata",
          "original_name": "sub_40b9e0"
        },
        {
          "addr": "0x414030",
          "name": "ai_init_dynamic_array",
          "original_name": "sub_414030"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404c30",
          "name": "ai_error_handler",
          "original_name": "error"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x40b9e0",
          "name": "ai_collect_file_metadata",
          "original_name": "sub_40b9e0"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4048c0",
          "name": "ai_gettext_wrapper",
          "original_name": "dcgettext"
        },
        {
          "addr": "0x40bc10",
          "name": "ai_report_error",
          "original_name": "sub_40bc10"
        },
        {
          "addr": "0x4046d0",
          "name": "ai_allocate_memory",
          "original_name": "malloc"
        },
        {
          "addr": "0x404aa0",
          "name": "ai_safe_memory_copy",
          "original_name": "__memcpy_chk"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x40f5f0",
          "name": "ai_get_group_name_by_gid",
          "original_name": "sub_40f5f0"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4140a0",
          "name": "ai_compute_display_width",
          "original_name": "sub_4140a0"
        },
        {
          "addr": "0x40bcc0",
          "name": "ai_validate_string_prefix_length",
          "original_name": "sub_40bcc0"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x404ba0",
          "name": "ai_memory_realloc_wrapper",
          "original_name": "realloc"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x40b910",
          "name": "ai_compute_file_mode_flags",
          "original_name": "sub_40b910"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x404760",
          "name": "ai_get_errno_location",
          "original_name": "__errno_location"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4048e0",
          "name": "ai_string_length",
          "original_name": "strlen"
        },
        {
          "addr": "0x4046b0",
          "name": "ai_free_memory",
          "original_name": "free"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "dcgettext",
        "strlen",
        "strlen",
        "strlen",
        "strlen",
        "strlen",
        "strlen",
        "strlen",
        "dcgettext",
        "getfilecon",
        "strcmp",
        "__readlink_chk",
        "free",
        "malloc",
        "__errno_location",
        "strlen",
        "lgetfilecon",
        "__errno_location",
        "reallocarray",
        "strlen",
        "__errno_location",
        "free",
        "listxattr",
        "malloc",
        "listxattr",
        "free",
        "getxattr",
        "__snprintf_chk",
        "__errno_location",
        "error",
        "free",
        "dcgettext",
        "__errno_location",
        "dcgettext",
        "malloc",
        "__memcpy_chk",
        "strlen",
        "__errno_location",
        "realloc",
        "strlen",
        "free",
        "free",
        "strlen",
        "free",
        "__errno_location",
        "free",
        "strlen",
        "free",
        "__stack_chk_fail"
      ],
      "string_refs": [
        "unlabeled",
        "error canonicalizing %s",
        "system.nfs4_acl",
        "system.posix_acl_access",
        "system.posix_acl_default",
        "cannot access %s",
        "cannot read symbolic link %s"
      ],
      "constants": [
        "0x308",
        "0xfffffffffffffd00",
        "0x423318",
        "0xfffffffffffffcfc",
        "0x423320",
        "0x423328",
        "0x1a0",
        "0x4047f0",
        "0xffffffff",
        "0x4232c9",
        "0x423330",
        "0x4232ca",
        "0x40e430",
        "0xfffffffffffffd08",
        "0x40bcc0",
        "0x423332",
        "0x416b20",
        "0x42333c",
        "0x40b910",
        "0xfffffffffffffcf0",
        "0x4048e0",
        "0xfffffffffffff000",
        "0x41af8e",
        "0x4048c0",
        "0x40bc10",
        "0xfff",
        "0x1000",
        "0xff8",
        "0x423342",
        "0x423349"
      ],
      "snippets": {
        "asm": "  0x417490  endbr64 \n  0x417494  push    rbp {__saved_rbp}\n  0x417495  mov     rbp, rsp\n  0x417498  push    r15 {__saved_r15}\n  0x41749a  push    r14 {__saved_r14}\n  0x41749c  push    r13 {__saved_r13}\n  0x41749e  push    r12 {__saved_r12}\n  0x4174a0  mov     r12, rcx\n  0x4174a3  push    rbx {__saved_rbx}\n  0x4174a4  mov     ebx, esi\n  0x4174a6  sub     rsp, 0x308\n  0x4174ad  mov     qword [rbp-0x300 {var_308}], rdi\n  0x4174b4  mov     r13, qword [rel data_423318]\n  0x4174bb  mov     dword [rbp-0x304 {var_30c}], edx\n  0x4174c1  mov     r15, qword [rel data_423320]\n  0x4174c8  mov     rax, qword [fs:0x28]\n  0x4174d1  mov     qword [rbp-0x38 {var_40}], rax\n  0x4174d5  xor     eax, eax  {0x0}\n  0x4174d7  cmp     r13, qword [rel data_423328]\n  0x4174de  je      0x417ed0\n  0x417ed0  mov     edx, 0x1a0\n  0x417ed5  mov     rsi, r13\n  0x417ed8  mov     rdi, r15\n  0x417edb  call    reallocarray\n  0x417ee0  test    rax, rax\n  0x417ee3  je      0x418318\n  0x4174e4  lea     rax, [r13+r13*2]\n  0x4174e9  lea     rax, [r13+rax*4]\n  0x4174ee  shl     rax, 0x4\n  0x4174f2  add     r15, rax\n  ... (5565 bytes total, truncated)",
        "hlil": "int64_t __saved_rbp_1\nint64_t __saved_rbp = __saved_rbp_1\nint64_t __saved_r15_1\nint64_t __saved_r15 = __saved_r15_1\nint64_t __saved_r14_1\nint64_t __saved_r14 = __saved_r14_1\nint64_t __saved_r13_1\nint64_t __saved_r13 = __saved_r13_1\nint64_t __saved_r12_1\nint64_t __saved_r12 = __saved_r12_1\nint64_t __saved_rbx_1\nint64_t __saved_rbx = __saved_rbx_1\nuint64_t rbx = zx.q(arg2)\nvoid var_338\nvoid* i = &var_338\nuint64_t nmemb = data_423318\nvoid* optr = data_423320\nvoid* fsbase\nint64_t rax = *(fsbase + 0x28)\nif (nmemb == data_423328)\nvoid* optr_1 = reallocarray(optr, nmemb, 0x1a0)\nif (optr_1 == 0 && (optr == 0 || nmemb != 0))\nsub_40e430()\nnoreturn\ndata_423320 = optr_1\nnmemb = data_423318\noptr = optr_1\ndata_423328 <<= 1\nint64_t* r15 = optr + nmemb * 0xd0\n*r15 = 0\nr15[0x19] = 0\nvoid* rdi_1 = &r15[1] & 0xfffffffffffffff8\n__builtin_memset(rdi_1, 0, zx.q((r15.d - rdi_1.d + 0xd0) u>> 3) << 3)\nr15[0x15].d = rbx.d\n*(r15 + 0xc4) = 0xffffffff\nif (data_4232c9 == 0 && data_4232ca != 0)\nchar rax_87 = sub_40bcc0(arg1)\n*(r15 + 0xc4) = zx.d(rax_87)\nif (rax_87 != 0)\ndata_4232c9 = 1\n// ... truncated",
        "pseudoc": "{\n    int64_t __saved_rbp_1;\n    int64_t __saved_rbp = __saved_rbp_1;\n    int64_t __saved_r15_1;\n    int64_t __saved_r15 = __saved_r15_1;\n    int64_t __saved_r14_1;\n    int64_t __saved_r14 = __saved_r14_1;\n    int64_t __saved_r13_1;\n    int64_t __saved_r13 = __saved_r13_1;\n    int64_t __saved_r12_1;\n    int64_t __saved_r12 = __saved_r12_1;\n    int64_t __saved_rbx_1;\n    int64_t __saved_rbx = __saved_rbx_1;\n    uint64_t rbx = (uint64_t)arg2;\n    void var_338;\n    void* i = &var_338;\n    uint64_t nmemb = data_423318;\n    void* optr = data_423320;\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (nmemb == data_423328)\n    {\n        void* optr_1 = reallocarray(optr, nmemb, 0x1a0);\n        \n        if (!optr_1 && (!optr || nmemb))\n        {\n            sub_40e430();\n            /* no return */\n        }\n        \n        data_423320 = optr_1;\n        nmemb = data_423318;\n        optr = optr_1;\n        data_423328 <<= 1;\n    }\n    \n    int64_t* r15 = (char*)optr + nmemb * 0xd0;\n    *(uint64_t*)r15 = 0;\n    r15[0x19] = 0;\n    void* rdi_1 = &r15[1] & 0xfffffffffffffff8;\n    __builtin_memset(rdi_1, 0, (uint64_t)(((uint32_t)r15 - (uint32_t)rdi_1 + 0xd0) >> 3) << 3);\n    r15[0x15] = (uint32_t)rbx;\n    *(uint32_t*)((char*)r15 + 0xc4) = 0xffffffff;\n    \n    if (!data_4232c9 && data_4232ca)\n    {\n        char rax_87 = sub_40bcc0(arg1);\n        *(uint32_t*)((char*)r15 + 0xc4) = (uint32_t)rax_87;\n        \n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_collect_file_acl_info",
          "confidence": 0.78,
          "rationale": "The function expands a dynamic array of structures, initializes entries, and references ACL-related strings (system.nfs4_acl, system.posix_acl_access, system.posix_acl_default) and SELinux context via getfilecon, indicating it gathers file ACL and security metadata.",
          "evidence_refs": [
            "strings:system.nfs4_acl",
            "strings:system.posix_acl_access",
            "strings:system.posix_acl_default",
            "strings:cannot access %s",
            "strings:cannot read symbolic link %s",
            "imports:getfilecon",
            "imports:dcgettext"
          ],
          "tags": [
            "file_io"
          ],
          "alt_names": [
            "ai_store_file_metadata",
            "ai_process_acl_entry"
          ]
        },
        "explain": {
          "summary": "sub_417490 expands a dynamically allocated array of ACL entry structures, initializes a new entry, and populates fields based on the provided arguments and global state. It handles memory growth with reallocarray, zeroes the new entry, sets type flags, and may compute ACL type via sub_40bcc0, preparing data for later processing of file ACLs.",
          "details": [
            "If the current number of entries (data_423318) equals the allocated capacity (data_423328), the function doubles the capacity using reallocarray with an element size of 0x1a0 bytes.",
            "A new entry is allocated at the end of the array, cleared with memset, and fields such as the file identifier (rbx) and a default flag (0xffffffff) are set.",
            "When a specific global flag (data_4232c9) is not set but another flag (data_4232ca) is, the function calls sub_40bcc0(arg1) to determine an ACL type, storing the result in the entry.",
            "The function references strings related to ACL types ('system.nfs4_acl', 'system.posix_acl_access', 'system.posix_acl_default') and error messages, indicating its role in ACL handling."
          ],
          "evidence_refs": [
            "strings:'system.nfs4_acl'",
            "strings:'system.posix_acl_access'",
            "strings:'system.posix_acl_default'",
            "imports:dcgettext",
            "imports:strlen",
            "imports:getfilecon",
            "call:0x40e430",
            "call:0x40bcc0"
          ],
          "unknowns": [
            "Exact semantics of arg1 and arg2 (e.g., file path vs. mode) and the meaning of global variables data_4232c9/data_4232ca.",
            "Precise structure layout of the ACL entry beyond the fields observed."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "file_io"
      ]
    },
    {
      "addr": "0x418b20",
      "original_name": "sub_418b20",
      "final_name": "ai_print_formatted_config_value",
      "score": 177.4,
      "bb_count": 30,
      "insn_est": 128,
      "callers": 5,
      "callees": [
        {
          "addr": "0x40bbb0",
          "name": "ai_get_config_option",
          "original_name": "sub_40bbb0"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x404bd0",
          "name": "ai_printf_chk_wrapper",
          "original_name": "__printf_chk"
        },
        {
          "addr": "0x40ecd0",
          "name": "ai_dispatch_operation",
          "original_name": "sub_40ecd0"
        },
        {
          "addr": "0x40bd80",
          "name": "ai_map_status_code",
          "original_name": "sub_40bd80"
        },
        {
          "addr": "0x40cb80",
          "name": "ai_locale_number_format",
          "original_name": "sub_40cb80"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x40be90",
          "name": "ai_lazy_stdout_write",
          "original_name": "sub_40be90"
        },
        {
          "addr": "0x404960",
          "name": "ai_file_stream_overflow",
          "original_name": "__overflow"
        },
        {
          "addr": "0x4048f0",
          "name": "ai_stack_canary_failure",
          "original_name": "__stack_chk_fail"
        }
      ],
      "import_refs": [
        "__printf_chk",
        "__printf_chk",
        "__printf_chk",
        "__overflow",
        "__stack_chk_fail"
      ],
      "string_refs": [],
      "constants": [
        "0x2a0",
        "0x423342",
        "0x423349",
        "0x40bbb0",
        "0x423348",
        "0x41af59",
        "0x4230c0",
        "0x40be90",
        "0x423100",
        "0x4230d0",
        "0x423333",
        "0x423344",
        "0x40ecd0",
        "0x423334",
        "0x4232dc",
        "0x200",
        "0xfffffffffffffd50",
        "0x4232d0",
        "0x40cb80",
        "0xfffffffffffffd64",
        "0xcccccccccccccccd",
        "0x41af6b",
        "0x404bd0",
        "0x4232c4",
        "0x40bd80",
        "0x4232ac",
        "0x4232c0",
        "0x422fa8",
        "0x423350",
        "0x4048f0"
      ],
      "snippets": {
        "asm": "  0x418b20  endbr64 \n  0x418b24  push    rbp {__saved_rbp}\n  0x418b25  mov     rbp, rsp {__saved_rbp}\n  0x418b28  push    r12 {__saved_r12}\n  0x418b2a  mov     r12, rsi\n  0x418b2d  push    rbx {__saved_rbx}\n  0x418b2e  mov     rbx, rdi\n  0x418b31  sub     rsp, 0x2a0\n  0x418b38  mov     rax, qword [fs:0x28]\n  0x418b41  mov     qword [rbp-0x18 {var_20}], rax\n  0x418b45  xor     eax, eax  {0x0}\n  0x418b47  cmp     byte [rel data_423342], 0x0\n  0x418b4e  je      0x418b62\n  0x418b62  cmp     byte [rel data_423349], 0x0\n  0x418b69  je      0x418ba6\n  0x418b50  mov     edi, 0x4\n  0x418b55  call    sub_40bbb0\n  0x418b5a  test    al, al\n  0x418b5c  jne     0x418d40\n  0x418ba6  cmp     byte [rel data_423348], 0x0\n  0x418bad  je      0x418be7\n  0x418b6b  cmp     byte [rbx+0xb8], 0x0\n  0x418b72  lea     rsi, [rel data_41af59]\n  0x418b79  jne     0x418c60\n  0x418d40  lea     rdi, [rel data_4230c0]\n  0x418d47  call    sub_40be90\n  0x418d4c  lea     rdi, [rel data_423100]\n  0x418d53  call    sub_40be90\n  0x418d58  lea     rdi, [rel data_4230d0]\n  0x418d5f  call    sub_40be90\n  ... (573 bytes total, truncated)",
        "hlil": "void* fsbase\nint64_t rax = *(fsbase + 0x28)\nif (data_423342 != 0 && sub_40bbb0(4) != 0)\nsub_40be90(&data_4230c0)\nsub_40be90(&data_423100)\nsub_40be90(&data_4230d0)\nif (data_423349 != 0)\nchar* rsi = &data_41af59\nif (arg1[0x17].b != 0)\nuint64_t i_1 = arg1[4]\nif (i_1 != 0)\nchar var_2a4 = 0\nrsi = &var_2a4\nuint64_t i\nrsi -= 1\nuint64_t i_2 = i_1 u/ 0xa\n*rsi = i_1.b - (i_2.b + (i_2 << 2).b) * 2 + 0x30\ni = i_1\ni_1 = i_2\ndo while (i u> 9)\nuint64_t rdx_1 = 0\nif (data_423344 != 4)\nrdx_1 = zx.q(data_4232c4)\n__printf_chk(2, \"%*s \", rdx_1, rsi)\nif (data_423348 != 0)\nvoid* const rcx_2 = &data_41af59\nif (arg1[0x17].b != 0)\nchar var_2b8[0x14]\nvoid* rax_15\nint16_t x87control\nint80_t st0_1\nst0_1, rax_15 = sub_40cb80(arg1[0xb], &var_2b8, data_4232dc, 0x200, data_4232d0, x87control)\nrcx_2 = rax_15\nuint64_t rdx_2 = 0\nif (data_423344 != 4)\nrdx_2 = zx.q(data_4232c0)\n__printf_chk(2, \"%*s \", rdx_2, rcx_2)\nif (data_423333 != 0)\nuint64_t rdx_3 = 0\nif (data_423344 != 4)\n// ... truncated",
        "pseudoc": "{\n    void* fsbase;\n    int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);\n    \n    if (data_423342 && sub_40bbb0(4))\n    {\n        sub_40be90(&data_4230c0);\n        sub_40be90(&data_423100);\n        sub_40be90(&data_4230d0);\n    }\n    \n    if (data_423349)\n    {\n        char* rsi = &data_41af59;\n        \n        if (arg1[0x17])\n        {\n            uint64_t i_1 = arg1[4];\n            \n            if (i_1)\n            {\n                char var_2a4 = 0;\n                rsi = &var_2a4;\n                uint64_t i;\n                \n                do\n                {\n                    rsi -= 1;\n                    uint64_t i_2 = i_1 / 0xa;\n                    *(uint8_t*)rsi = (uint8_t)i_1 - ((uint8_t)i_2 + (char)(i_2 << 2)) * 2 + 0x30;\n                    i = i_1;\n                    i_1 = i_2;\n                } while (i > 9);\n            }\n        }\n        \n        uint64_t rdx_1 = 0;\n        \n        if (data_423344 != 4)\n            rdx_1 = (uint64_t)data_4232c4;\n        \n        __printf_chk(2, \"%*s \", rdx_1, rsi);\n    }\n    \n    if (data_423348)\n    {\n        void* const rcx_2 = &data_41af59;\n        \n        if (arg1[0x17])\n        {\n// ... truncated"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_print_formatted_config_value",
          "confidence": 0.78,
          "rationale": "The function conditionally formats numeric data into a string and prints it using __printf_chk, handling configuration-like globals and calling helper routines for validation, indicating a status/config output routine.",
          "evidence_refs": [
            "imports:__printf_chk",
            "call:0x40bbb0",
            "call:0x40be90"
          ],
          "tags": [
            "config",
            "file_io"
          ],
          "alt_names": [
            "ai_display_status_output",
            "ai_format_and_print_number"
          ]
        },
        "explain": {
          "summary": "sub_418b20 formats and prints data based on several global flags. It may clear internal buffers, convert a numeric argument to a decimal string, and output it with a width specifier using __printf_chk.",
          "details": [
            "If data_423342 is set and sub_40bbb0(4) returns true, it calls sub_40be90 on three data structures, likely resetting or printing them.",
            "When data_423349 is true, it builds a decimal string from arg1[4] (if arg1[0x17] is set) using manual division, then prints it with a field width (data_4232c4) via __printf_chk(\"%*s \").",
            "A similar block guarded by data_423348 prints another string from a global buffer.",
            "The function reads the stack guard value (fsbase+0x28) but does not otherwise use it, indicating stack protection."
          ],
          "evidence_refs": [
            "imports:__printf_chk",
            "call:0x40bbb0",
            "call:0x40be90",
            "call:0x418b20"
          ],
          "unknowns": [
            "Exact semantics of sub_40be90 and the meaning of the global data_4233xx variables.",
            "The full purpose of the second conditional block (data_423348) which is truncated."
          ],
          "confidence": 0.78
        }
      },
      "is_boring": false,
      "tags": [
        "config",
        "file_io"
      ]
    },
    {
      "addr": "0x418d90",
      "original_name": "sub_418d90",
      "final_name": "ai_register_atexit_handler",
      "score": 12.2,
      "bb_count": 1,
      "insn_est": 4,
      "callers": 1,
      "callees": [
        {
          "addr": "0x404c60",
          "name": "ai_register_exit_handler",
          "original_name": "__cxa_atexit"
        }
      ],
      "import_refs": [
        "__cxa_atexit"
      ],
      "string_refs": [],
      "constants": [
        "0x423008",
        "0x404c60"
      ],
      "snippets": {
        "asm": "  0x418d90  endbr64 \n  0x418d94  mov     rdx, qword [rel data_423008]\n  0x418d9b  xor     esi, esi  {0x0}\n  0x418d9d  jmp     __cxa_atexit",
        "hlil": "return __cxa_atexit(arg1, nullptr, data_423008) __tailcall",
        "pseudoc": "{\n    /* tailcall */\n    return __cxa_atexit(arg1, nullptr, data_423008);\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_register_atexit_handler",
          "confidence": 0.93,
          "rationale": "The function simply forwards its argument to __cxa_atexit with a static DSO handle, registering a cleanup routine for program termination.",
          "evidence_refs": [
            "imports:__cxa_atexit",
            "constants:0x423008"
          ],
          "tags": [
            "process"
          ],
          "alt_names": [
            "ai_atexit_register",
            "ai_register_exit_callback"
          ]
        },
        "explain": {
          "summary": "sub_418d90 is a thin wrapper that registers a function to be called at program termination via __cxa_atexit, passing the provided function pointer, a null argument, and a static DSO handle located at data_423008.",
          "details": [
            "The function performs a tail call to __cxa_atexit with arg1 as the cleanup function, nullptr as the argument, and data_423008 as the DSO handle.",
            "This registers the supplied function for execution when the process exits, enabling resource cleanup or finalization."
          ],
          "evidence_refs": [
            "imports:__cxa_atexit",
            "call:0x404c60",
            "constants:0x423008"
          ],
          "unknowns": [
            "The specific cleanup routine passed as arg1",
            "The exact meaning or contents of the data_423008 constant"
          ],
          "confidence": 0.96
        }
      },
      "is_boring": true,
      "tags": [
        "process"
      ]
    },
    {
      "addr": "0x418da4",
      "original_name": "_fini",
      "final_name": "ai_no_op",
      "score": 2.7,
      "bb_count": 1,
      "insn_est": 4,
      "callers": 0,
      "callees": [],
      "import_refs": [],
      "string_refs": [],
      "constants": [],
      "snippets": {
        "asm": "  0x418da4  endbr64 \n  0x418da8  sub     rsp, 0x8\n  0x418dac  add     rsp, 0x8\n  0x418db0  retn     {__return_addr}",
        "hlil": "return ",
        "pseudoc": "{\n    return;\n}"
      },
      "llm": {
        "rename": {
          "suggested_name": "ai_no_op",
          "confidence": 0.96,
          "rationale": "Function contains only a return statement and performs no operations; typical empty stub or placeholder.",
          "evidence_refs": [],
          "tags": [],
          "alt_names": [
            "ai_empty_function",
            "ai_stub"
          ]
        },
        "explain": {
          "summary": "The _fini function is a no-op that immediately returns without performing any operations.",
          "details": [
            "The function contains only a return instruction and no other code.",
            "It has no imports, strings, constants, or calls, indicating no side effects."
          ],
          "evidence_refs": [],
          "unknowns": [],
          "confidence": 0.99
        }
      },
      "is_boring": true,
      "tags": []
    }
  ],
  "notes": {
    "guardrails": "Input validated (override active)",
    "analysis_warnings": [
      "Safety override active (--i-know-what-im-doing). Input: /usr/bin/ls"
    ]
  }
}